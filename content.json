{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"10-正则表达式匹配","text":"Category Difficulty Pass rate Tags Companies algorithms Hard 25.22% string / dynamic-programming / backtracking airbnb / facebook / google / twitter / uber 1. 题目给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 12'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 123456789101112131415161718192021222324252627282930313233示例 1:输入:s = \"aa\"p = \"a\"输出: false解释: \"a\" 无法匹配 \"aa\" 整个字符串。示例 2:输入:s = \"aa\"p = \"a*\"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。示例 3:输入:s = \"ab\"p = \".*\"输出: true解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。示例 4:输入:s = \"aab\"p = \"c*a*b\"输出: true解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。示例 5:输入:s = \"mississippi\"p = \"mis*is*p*.\"输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/regular-expression-matching 2. 解法2.1 解法一：递归法 参考：Joy p为空。s为空，则返回true；s不为空，则返回false。 当p的第二个元素是 * 时，有两种情况，满足一种就可以（即 || ）： 剔除p中前两个元素，再来判断是否匹配。 例如：s = &quot;aab&quot;, p = &quot;c*a*b&quot;。其中 c* 可以是0个c，所以可以无视掉。 直接判断s = &quot;aab&quot; 和 p = &quot;a*b&quot;是否匹配。 当 s[0] == p[0] || p[0] == '.' 时，剔除s中第一个元素，再来判断是否匹配。 例如：s = &quot;aab&quot;, p = &quot;a*b&quot;。a*可以匹配0~多个，s[0] = 'a'被匹配，可以删除。接下来比较s = &quot;ab&quot; 和 p = &quot;a*b&quot;是否匹配。 如果第二个元素不是 *，那就只能是 a-z 或者 '.' 了。当第一个元素两两匹配时，我们就可以删除掉这俩元素了，因为没有 *的情况下，a-z 和 '.'只能匹配一次。例如：s = &quot;aab&quot;, p = &quot;.a*b&quot;。因为 p[1] = 'a', p[0] = '.', s[0] = 'a'，两者匹配。所以剔除掉首元素，接下来判断s = &quot;ab&quot;, p = &quot;a*b&quot;是否匹配。 执行用时: 300 ms, 在所有 cpp 提交中击败了29.78%的用户内存消耗: 15.5 MB, 在所有 cpp 提交中击败了14.56%的用户 1234567891011class Solution {public: bool isMatch(string s, string p) { if (p.empty()) return s.empty(); if (p.size() &gt; 1 &amp;&amp; p[1] == '*') return isMatch(s, p.substr(2)) || (!s.empty() &amp;&amp; (s[0] == p[0] || p[0] == '.') &amp;&amp; isMatch(s.substr(1), p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == '.') &amp;&amp; isMatch(s.substr(1), p.substr(1)); }}; 2.2 解法二：动态规划 参考：乔碧萝殿下❤，Krahets dp数组的样子: s=&quot;abb&quot;,p=&quot;ab*c*&quot;，方便大家理解。为什么加 '#' 见步骤5。1 表示 true，0 表示 false。 12345 # a b * c *# 1 0 0 0 0 0a 0 1 0 1 0 1b 0 0 1 1 0 1b 0 0 0 1 0 1 建立二维数组 dp，dp[i][j] 表示 s 的前 i 个元素和 p 的前 j 个元素是否匹配。 首先分析最简单的情况：s[i] == p[j]。此时若s的前i-1个元素和p的前j-1个元素相匹配，那么s的前i个元素和p的前j个元素也必相匹配。即此时的状态转移方程为: dp[i][j] = dp[i - 1][j - 1]。 第二种情况，当 p[j] == '.' 时，和2中情况相同，状态转移方程仍为：dp[i][j] = dp[i - 1][j - 1]。 第三种比较复杂的情况，当 p[j] == '*'时。此时我们必须要考虑 '*' 之前的元素，分为以下两种情况： s[i] != p[j - 1]：dp[i][j] = dp[i][j - 2]，此时表示 * 前面的字母根本和 s[i] 中字母不相同。例如： s = &quot;abb&quot;, p = &quot;ab*c*&quot;，对于p中第二个 * 来说，其前面的字母c满足这种情况，c*相当于匹配了0次c，相当于直接剔除 c*，是否匹配取决于s = &quot;abb&quot;, p = &quot;ab*&quot;。 s[i] == p[j - 1] || p[j] == '.'，此时表示匹配上了，但是不知道匹配了几次。 匹配多次： dp[i][j] = dp[i-1][j]例如：s = &quot;abbb&quot;, p = &quot;ab*&quot;，此时代表匹配了3次b。和s = &quot;abb&quot;, p = &quot;ab*的匹配状态相同，继而又和s = &quot;ab&quot;, p = &quot;ab*的匹配状态相同。 匹配一次：dp[i][j] = dp[i][j - 1]例如：s = &quot;ab&quot;, p = &quot;ab*&quot;。若s = &quot;ab&quot;, p = &quot;ab匹配，那么它肯定也匹配。 匹配零次：dp[i][j] = dp[i][j - 2]例如：s = &quot;ab&quot;, p = &quot;abc*&quot;，对于c来说匹配了0次，那么c*就没有什么意义，也就可以剔除掉c*。 考虑边界值的问题。因为如果当 i=0 时，dp[i][j] = dp[i - 1][j - 1]就会数组越界。这里我们的处理办法是行和列各增加一个维度，即: dp[m + 1][n + 1]。这时读者可能会有疑问，还有 dp[j - 2] 的情况呢，你这里只增加了 1 ，j = 0 时仍然会数组越界啊？实际上我们观察步骤4，dp[j - 2]只出现在 p[j] == '*' 的情况下，而 * 不可能是 p 的首元素的。 数组 dp 的初始化。我们只需要对第一列和第一行进行初始化即可，其他地方均赋值为 false。我们的行和列都比原来增加了1，我们可以假设在 s 和 p 前面都加了一个字符'#'。例如 s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;，那么dp的第一行就是代表 s[0] 和 p 的前 j 个元素是否匹配。此时 dp[0][0] = true，因为 s[0] = p[0] = '#'。 第一行的初始化：因为我们的 p 始终和 '#'进行匹配判断，并且 p[0] = '#' ，那么后面只要出现了 '*'，那它肯定匹配了0次；单独出现 a-z 或者 '.' 肯定无法与 s[0] = '#' 匹配，因为 p 首元素就是 #。 第一列的初始化：例如 s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;，那么dp的第一行就是 p[0] 和 s 的前 i 个元素是否匹配。我们可以看出，只有 p[0] = s[0] = '#' 是匹配的，其他地方都不匹配。'#' 和 '#' 匹配。'#' 和 '#a' 不匹配。'#' 和 '#ab' 也不匹配。'#' 和 '#abb' 也不匹配。 下面举两个例子方便大家理解初始化规则，只需看第一列和第一行即可。初始化例子1：s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;时： 12345 # a b * c *# 1 0 0 0 0 0a 0 1 0 1 0 1b 0 0 1 1 0 1b 0 0 0 1 0 1 初始化例子2：s = &quot;#abb&quot;, p = &quot;#a*b*c*&quot;时： 12345 # a * b * c *# 1 0 1 0 1 0 1a 0 1 1 0 1 0 1b 0 0 0 1 1 0 1b 0 0 0 0 1 0 1 执行用时: 4 ms, 在所有 cpp 提交中击败了98.13%的用户内存消耗: 8.4 MB, 在所有 cpp 提交中击败了91.48%的用户 123456789101112131415161718192021222324252627282930class Solution {public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); bool dp[m + 1][n + 1]; // 初始化 for (auto &amp;i : dp) for (auto &amp;j : i) j = false; dp[0][0] = true; for (auto j = 0; j &lt; n; ++ j) { if (p[j] == '*') dp[0][j + 1] = dp[0][j - 1]; } for (auto i = 0; i &lt; m; ++ i) { for (auto j = 0; j &lt; n; ++ j) { if (s[i] == p[j] || p[j] == '.') dp[i + 1][j + 1] = dp[i][j]; else if (p[j] == '*') { if (s[i] != p[j - 1] &amp;&amp; p[j - 1] != '.') dp[i + 1][j + 1] = dp[i + 1][j - 1]; else dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j] || dp[i + 1][j - 1]; } } } return dp[m][n]; }}; 2.3 解法三：有限状态自动机没学过，日后再更。","link":"/2019/10/27/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"1-两数之和","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 46.90% array / hash-table adobe / airbnb / amazon / apple / bloomberg / dropbox / facebook / linkedin / microsoft / uber / yahoo / yelp 1. 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找 出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 1234示例:给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum 2. 解法2.1 解法一例如：nums = [1, 2, 3, 7, 11, 15], target = 9。2和7是答案，对于7或者2(此例7在后面，所以是对于7)来说，在它前面的元素中必定有另一个答案。所以我们将每个元素及其前面的元素都加入map中，遍历到下一个元素时就可以判断另一个答案在不在map中。 执行用时: 12 ms, 在所有 cpp 提交中击败了92.01%的用户内存消耗: 10.5 MB, 在所有 cpp 提交中击败了13.80%的用户 123456789101112131415161718//复杂度为O(n)class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; res; map&lt;int, int&gt; m; int another; for (unsigned i = 0; i &lt; nums.size(); ++ i) { another = target - nums[i]; if (m.find(another) != m.end()) { res.push_back(m[another]); res.push_back(i); } m[nums[i]] = i; } return res; }};","link":"/2019/10/15/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"11-盛最多水的容器","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 58.84% array / two-pointers bloomberg 1. 题目给定 $n$ 个非负整数 $a1，a2，…，an$，每个数代表坐标中的一个点 $(i, ai)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, ai)$ 和 $(i, 0)$。找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 $n$ 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 123示例:输入: [1,8,6,2,5,4,8,3,7]输出: 49 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/container-with-most-water/ 2. 解法2.1 解法一：双指针法 参考：Krahets 指针 $l$，$r$ 分别指向最左边和最右边的木板，根据规则移动两个指针。获取每次移动之后的容器的大小，最后得到一个最大值。 由题意可知，$S = 底\\times高 = (r - l) \\times min(h[l], h[r])$，面积是由两个木板中的短板决定的。 无论我们移动哪一侧的木板，底 $(r - l)$ 都会减1。 如果我们选择短板一侧的指针向内移一格，那么容器的宽 $min(h[l], h[r])$ 可能变小也可能变大。 如果我们选择长板一侧的指针向内移一格，那么容器的宽 $min(h[l], h[r])$ 可能不变也可能变小。 所以，我们可以推断出，只有向内移动短板一侧的指针， $S$ 才可能会变大（虽然也可能变小）。但是向内移动长板一侧的指针，$S$ 一定不会变大。 执行用时: 16 ms, 在所有 cpp 提交中击败了95.90%的用户内存消耗: 9.8 MB, 在所有 cpp 提交中击败了75.70%的用户 123456789101112131415class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int left = 0; int right = height.size() - 1; int maxS = 0; while (left != right) { if (height[left] &lt; height[right]) maxS = max(maxS, (right - left) * height[left ++]); else maxS = max(maxS, (right - left) * height[right --]); } return maxS; }};","link":"/2019/10/28/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"12-整数转罗马数字","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 61.47% math / string twitter 1. 题目罗马数字包含以下七种字符： I，V，X，L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 123456789101112131415161718192021示例 1:输入: 3输出: \"III\"示例 2:输入: 4输出: \"IV\"示例 3:输入: 9输出: \"IX\"示例 4:输入: 58输出: \"LVIII\"解释: L = 50, V = 5, III = 3.示例 5:输入: 1994输出: \"MCMXCIV\"解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/integer-to-roman/ 2. 解法2.1 解法一：字典寻找法 我们将个、十、百、千位所有可能出现的数字的罗马字母都罗列出来，然后求出所求数字的个、十、百、千位的值，找出对应的罗马字母即可。 执行用时: 8 ms, 在所有 cpp 提交中击败了91.78%的用户内存消耗: 8.3 MB, 在所有 cpp 提交中击败了90.53%的用户 12345678910class Solution {public: string intToRoman(int num) { string ge[10] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}; string shi[10] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}; string bai[10] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}; string qian[4] = {\"\", \"M\", \"MM\", \"MMM\"}; return qian[num / 1000] + bai[(num % 1000) / 100] + shi[(num % 100) / 10] + ge[num % 10]; }}; 2.2 解法二：贪心算法 我们列出所有最小单位的罗马字母组合，假设输入整数为 num。 从最大的数开始匹配，看 num 能匹配几次，每次匹配 num 都要减去这个数。 若 num 开始小于最大的数，则从第二大的数再次开始匹配，直至 num 变为 0。 我给出两种代码，一种是利用反向迭代器，一种利用普通迭代器，主要是为了熟悉迭代器操作。 执行用时 :28 ms, 在所有 cpp 提交中击败了22.65%的用户内存消耗 :15.3 MB, 在所有 cpp 提交中击败了70.87%的用户 1 反向迭代器： 1234567891011121314151617181920class Solution {public: string intToRoman(int num) { map&lt;int, string&gt; romanMap= { {1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"} }; map&lt;int, string&gt;::reverse_iterator r_iter = romanMap.rbegin(); string res = \"\"; while (r_iter != romanMap.rend()) { if (num &gt;= r_iter-&gt;first) { res += r_iter-&gt;second; num -= r_iter-&gt;first; } else r_iter ++; } return res; }}; 2 普通迭代器： 1234567891011121314151617181920class Solution {public: string intToRoman(int num) { map&lt;int, string&gt; romanMap= { {1, \"I\"}, {4, \"IV\"}, {5, \"V\"}, {9, \"IX\"}, {10, \"X\"}, {40, \"XL\"}, {50, \"L\"}, {90, \"XC\"}, {100, \"C\"}, {400, \"CD\"}, {500, \"D\"}, {900, \"CM\"}, {1000, \"M\"} }; auto iter = -- romanMap.end(); string res = \"\"; while (iter != -- romanMap.begin()) { if (num &gt;= iter-&gt;first) { res += iter-&gt;second; num -= iter-&gt;first; } else -- iter; } return res; }};","link":"/2019/10/31/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"},{"title":"13-罗马数字转整数","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 59.40% math / string bloomberg / facebook / microsoft / uber / yahoo 1. 题目罗马数字包含以下七种字符： I，V，X，L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 123456789101112131415161718192021示例 1:输入: \"III\"输出: 3示例 2:输入: \"IV\"输出: 4示例 3:输入: \"IX\"输出: 9示例 4:输入: \"LVIII\"输出: 58解释: L = 50, V= 5, III = 3.示例 5:输入: \"MCMXCIV\"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer/ 2. 解法2.1 解法一 我们可以发现，如果前一个字母小于后一个字母（例如：CM），那么它俩肯定是组合数（即CM = M-C = 900）。 所以我们只要发现 s[i] &lt; s[i + 1] 那么我们就加上它俩之差。 其余的都是单个字母，加上单个字母的值。 我们给出两种代码，一种是正序遍历，一种是逆序遍历，显然逆序遍历更加简洁。 执行用时: 24 ms, 在所有 cpp 提交中击败了62.53%的用户内存消耗: 10.7 MB, 在所有 cpp 提交中击败了84.86%的用户 正序遍历： 1234567891011121314151617181920212223242526class Solution {public: int romanToInt(string s) { unordered_map&lt;char, int&gt; romanMap= { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} }; int n = s.size(); int num[n]; int sum = 0; for (auto i = 0; i &lt; n; ++ i) { num[i] = romanMap[s[i]]; } if (n == 1) return romanMap[s[0]]; for (auto i = 0; i &lt; n - 1; ++ i) { if (num[i] &lt; num[i + 1]) { sum = sum + num[i + 1] - num[i]; i ++; } else sum += num[i]; } if (num[n - 2] &gt;= num[n - 1]) sum += num[n-1]; return sum; }}; 逆序遍历： 12345678910111213class Solution {public: int romanToInt(string s) { unordered_map&lt;char, int&gt; romanMap= { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} }; int sum = romanMap[s.back()]; // auto i = s.size() - 2 报错 for (int i = s.size() - 2; i &gt;= 0; -- i) { sum += romanMap[s[i]] &gt;= romanMap[s[i + 1]] ? romanMap[s[i]] : -romanMap[s[i]]; } return sum; }};","link":"/2019/11/01/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"title":"14-最长公共前缀","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 35.13% string yelp 1. 题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 12345678示例 1:输入: [\"flower\",\"flow\",\"flight\"]输出: \"fl\"示例 2:输入: [\"dog\",\"racecar\",\"car\"]输出: \"\"解释: 输入不存在公共前缀。 说明： 所有输入只包含小写字母 a-z 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix/ 2. 解法2.1 解法一 从第一个位置开始，判断每个字符串该位置是否全部相等。 即：若 vector&lt;string&gt; 字符串为 str1, str2, str3。 我们比较 str1[0], str2[0], str3[0] 是否全部相等。 若相等，比较 str1[1], str2[1], str3[1] 是否全部相等。 依次下去比较，直至第一次不全部相等时结束。 执行用时: 8 ms, 在所有 cpp 提交中击败了71.92%的用户内存消耗: 8.7 MB, 在所有 cpp 提交中击败了92.56%的用户 1. 将 vector&lt;string&gt; 视为二维数组： 1234567891011121314151617181920class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { string res = \"\"; int m = strs.size(); int maxSize = 0; for (auto i = 0; i &lt; m; ++ i) { if (strs[i].size() &gt; maxSize) maxSize = strs[i].size(); } for (auto i = 0; i &lt; maxSize; ++ i) { for (auto j = 0; j &lt; m - 1; ++ j) { if (strs[j][i] != strs[j + 1][i]) return res; } res += strs[0][i]; } return res; }}; 2. 利用迭代器： 123456789101112131415161718192021class Solution {public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) { auto iter = strs.begin(); string res = \"\"; int maxSize = 0; for (auto i = 0; i &lt; strs.size(); ++ i) { if ((*(iter + i)).size() &gt; maxSize) maxSize = (*(iter + i)).size(); } for (auto i = 0; i &lt; maxSize; ++ i) { for (auto j = 0; j &lt; strs.size() - 1; ++ j) { if ((*(iter + j))[i] != (*(iter + j + 1))[i]) { return res; } } res += (*iter)[i]; } return res; }};","link":"/2019/11/02/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"title":"15-三数之和","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 24.31% array / two-pointers adobe / amazon / bloomberg / facebook / microsoft 1. 题目给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 $a，b，c ，$使得 $a + b + c = 0$ ？找出所有满足条件且不重复的三元组。 注意： 答案中不可以包含重复的三元组。 123456例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum/ 2. 解法2.1 解法一：双指针法 首先对数组从大到小排序，数组的大小为 n 。 固定一个数，从其右侧的数中寻找另外两个数。假设我们固定的数为 nums[k], k = 0 to n-1 , 另外两个数初始时分别为 nums[l], nums[r] , 其中 l = k + 1, r = n - 1 。 令 sum = nums[k] + nums[l] + nums[r] 。 若 sum &lt; 0 ，则我们要增大 sum ，此时只能对 l 向右挪一格，即：l ++ 。 若 sum &gt; 0 ，则我们要减小 sum ，此时只能对 r 向左挪一格，即：r -- 。 若 sum == 0 ，此时这三个数就我们需要的数，将他们加入结果里。此时，l 和 r 之间的数还可能有我们需要的数，我们此时需要左右都向内移动，即：l ++, r -- 。。 避免重复的数据。 当 sum == 0 时，我们需要 l 和 r 都向内移动。此时需要过滤掉和当前 nums[l], nums[r] 重复的数据，我们巧妙的使用了两个while循环，同时需注意 l 要一直小于 r。while (l &lt; r &amp;&amp; nums[l] == nums[++ l]) { }while (l &lt; r &amp;&amp; nums[r] == nums[-- r]) { } 同时，我们也要在 k 的循环中过滤掉和当前 nums[k] 重复的数字。这里的 k &lt; len - 2主要是防止数组越界。while (k &lt; len - 2 &amp;&amp; nums[k] == nums[++ k]) { } 当 l &gt;= r 时，说明与当前固定的 nums[k] 相组合的两个数已经找完，所以要进入下一个 nums[k]。 执行用时: 112 ms, 在所有 cpp 提交中击败了98.73%的用户内存消耗: 14.6 MB, 在所有 cpp 提交中击败了86.17%的用户 1234567891011121314151617181920212223242526272829303132class Solution {public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; res; int len = nums.size(); if (len &lt; 3) { return res; } sort(nums.begin(), nums.end()); int k = 0; while(k &lt; len - 2 &amp;&amp; nums[k] &lt;= 0) { int l = k + 1; int r = len - 1; while (l &lt; r) { int sum = nums[k] + nums[l] + nums[r]; if (sum == 0) { res.push_back({nums[k], nums[l], nums[r]}); while (l &lt; r &amp;&amp; nums[l] == nums[++ l]) { } while (l &lt; r &amp;&amp; nums[r] == nums[-- r]) { } } else if (sum &lt; 0) { ++ l; } else { -- r; } } while (k &lt; len - 2 &amp;&amp; nums[k] == nums[++ k]) { } } return res; }};","link":"/2019/11/04/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"16-最接近的三数之和","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 41.91% array / two-pointers bloomberg 1. 题目给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum-closest/ 2. 解法2.1 解法一：双指针法 与第15题三数之和类似。三数之和是当和为 target 是我们需要的值，此题则是$|sum - target|$最小时，是我们需要的值。 其余部分和三数之和相同。参考链接：15 - 三数之和 执行用时: 12 ms, 在所有 cpp 提交中击败了 72.29% 的用户内存消耗: 8.7 MB, 在所有 cpp 提交中击败了 87.01% 的用户 1234567891011121314151617181920212223242526272829class Solution {public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) { if (nums.size() &lt; 3) return 0; sort(nums.begin(), nums.end()); int sum; long res = INT_MAX; for (auto k = 0; k &lt; nums.size() - 2; ++ k) { int l = k + 1; int r = nums.size() - 1; while (l &lt; r) { sum = nums[k] + nums[l] + nums[r]; if (abs(sum - target) &lt; abs(res - target)) res = sum; if (sum &lt; target) { while (l &lt; r &amp;&amp; nums[l] == nums[++ l]) { } } else if (sum &gt; target) { while (l &lt; r &amp;&amp; nums[r] == nums[-- r]) { } } else { return target; } } } return res; }};","link":"/2019/11/07/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"17-电话号码的字母组合","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 51.27% string / backtracking amazon / dropbox / facebook / google / uber 1. 题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 1234示例:输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/ 2. 解法2.1 解法一：递归法以 digits = &quot;23&quot;为例： 我们递归函数只接受两个参数：上一次的结果 res ，这一次要结合的数字 digits[i]。 首先用第一个数字初始化我们的 res，例如第一个数字是 2 ，那么 res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} 。 第二个数字是 3，m[3] = &quot;def&quot;。那么 m[3] 和 res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}怎么组合呢？ 首先 res 暂时只有3个元素，和 m[3] 组合后应该有 $3 \\times 3 = 9$ 个元素。 总的来说，元素的添加顺序是， res.push_back(res[0] + 'e'); res.push_back(res[0] + 'f');结果：res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;} res.push_back(res[1] + 'e'); res.push_back(res[1] + 'f');结果：res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;} res[0] += 'd'; res[1] += 'd'; res[2] += 'd';结果：res = {&quot;ad&quot;, &quot;bd&quot;, &quot;cd&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;} 我们得出一个规律，假设当前数字中所含字母长度为 l（n=3或4）。我们可以将前 l-1 个字母和 res 进行排列组合加入到 res中。为什么要剩下一个字母呢，因为我们 res 中还有一些元素仍然是上次的结果，我们把最后一个字母直接加入到上次的结果的元素后。 当然你也可以选择将所以字母和 res 进行排列组合，然后删除前面的无效的元素。 执行用时: 4 ms, 在所有 cpp 提交中击败了 77.47% 的用户内存消耗: 8.4 MB, 在所有 cpp 提交中击败了 90.68% 的用户 123456789101112131415161718192021222324252627282930class Solution {public: string m[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; res; for (auto i = 0; i &lt; digits.size(); ++ i) { combine(res, digits[i]); } return res; } void combine(vector&lt;string&gt; &amp;res, char ch) { int n = res.size(); int digit = static_cast&lt;int&gt;(ch) - 48; int l = m[digit].size(); if (n == 0) { for (auto j = 0; j &lt; l; ++ j) { string s(1, m[digit][j]); res.push_back(s); } return; } for (auto i = 0; i &lt; n; ++ i) { for (auto j = 0; j &lt; l - 1; ++ j) res.push_back(res[i] + m[digit][j]); res[i] += m[digit][l - 1]; } return; }}; 2.2 解法二：使用队列 每次从队头取出一个元素，与m[]中字符串中的每个字符分别组合，然后放入队尾。 执行用时: 0 ms, 在所有 cpp 提交中击败了 100.00% 的用户内存消耗: 8.7 MB, 在所有 cpp 提交中击败了 48.35% 的用户 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { map&lt;char, string&gt; m = { {'2', \"abc\"}, {'3', \"def\"}, {'4', \"ghi\"}, {'5', \"jkl\"}, {'6', \"mno\"}, {'7', \"pqrs\"}, {'8', \"tuv\"}, {'9', \"wxyz\"} }; queue&lt;string&gt; q; vector&lt;string&gt; res; // 先处理第一个数字。是为了使q不为空。 for (auto i : m[digits[0]]) { string s(1, i); q.push(s); } for (auto i = 1; i &lt; digits.size(); ++ i) { int len = q.size(); for (auto j = 0; j &lt; len; ++ j) { string s = q.front(); for (auto k = 0; k &lt; m[digits[i]].size(); ++ k) { q.push(s + m[digits[i]][k]); } q.pop(); } } while (!q.empty()) { res.push_back(q.front()); q.pop(); } return res; }}; 2.3 深度优先遍历 第一段代码来自 zefengsong。第二份代码是参考 GQXING 修改了的第一份代码。图来自 LeetCode 如图所示。 执行用时: 0 ms, 在所有 cpp 提交中击败了 100.00% 的用户内存消耗: 8.5 MB, 在所有 cpp 提交中击败了 79.75% 的用户 代码一： path 引用传值。 1234567891011121314151617181920212223class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt;res; if(digits.empty()) return res; vector&lt;string&gt;letter({\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}); string path = \"\"; DFS(digits, 0, path, res, letter); return res; } void DFS(string digits, int pos, string&amp; path, vector&lt;string&gt;&amp; res, vector&lt;string&gt;&amp; letter){ if(pos == digits.size()){ res.push_back(path); return; } for(auto c: letter[digits[pos] - '0']){ path.push_back(c); DFS(digits, pos + 1, path, res, letter); path.pop_back(); } }}; 代码二： path 非引用传值。 虽然我们知道，在传递字符串时，最好使用引用传值。但是我们的目的是在一次递归里不修改 path 的值(否则我们就要像代码1一样，还要删除 path 的尾元素)，所以我们不使用引用传值。 123456789101112131415161718192021class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt;res; if(digits.empty()) return res; vector&lt;string&gt;letter({\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}); string path = \"\"; DFS(digits, 0, path, res, letter); return res; } void DFS(string digits, int pos, string path, vector&lt;string&gt;&amp; res, vector&lt;string&gt;&amp; letter){ if(pos == digits.size()){ res.push_back(path); return; } for(auto c: letter[digits[pos] - '0']){ DFS(digits, pos + 1, path + c, res, letter); } }};","link":"/2019/11/10/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"title":"18-四数之和","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 36.01% array / hash-table / two-pointers linkedin 1. 题目给定一个包含 $n$ 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 $a$，$b$，$c$ 和 $d$ ，使得 $a + b + c + d$ 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 12345678910示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum 2. 解法2.1 解法一：双指针法与前面三数之和类似，还是采用双指针法，双指针是用来选择后两个数的，因此前面还需要两个循环，来选择前两个数。 需要注意的是这四个数，都需要进行去重处理。双指针的去重我不再赘述，详情参考 LeetCode(C++)刷题计划：15-三数之和。 下面我们讲一下，前两个数的去重代码，以 nums = [0, 0, 1, 1, 1, 2] 为例。 首先第一个数的去重代码 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; nums[i] == nums[i - 1] 的作用就是判断当前数是否和前一个数相等。 i &gt; 0，是为了防止第一个数的 nums[0] == nums[-1]，这样数组就越界了。 第二个数的去重代码 if (k &gt; i + 1 &amp;&amp; nums[k] == nums[k - 1]) continue; nums[k] == nums[k - 1] 的作用和前面一样。 k &gt; i + 1 的目的倒不是防止越界，因为不可能越界。它主要为了防止过度去重。举个例子：nums = [0, 0, 1, 1, 1, 2]。当 i = 2 时, nums[i] = 1。此时 k = i + 1 = 3, nums[k] = 1。如果我们没有 k &gt; i + 1 这句，他会认为 nums[k] 是重复数据(因为 nums[k] == nums[k - 1])。但是实际上是nums[k] 和 nums[i] (k = i + 1)在比较是否相等，然而这两个数是可以相等的。我们需要避免的是，在同一个 nums[i] 下，连续的 nums[k] 不能相等， nums[i] 不在我们的比较范围内。 执行用时: 76 ms, 在所有 cpp 提交中击败了42.69%的用户内存消耗: 8.9 MB, 在所有 cpp 提交中击败了96.88%的用户 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) { vector&lt;vector&lt;int&gt;&gt; res; int n = nums.size(); if (n &lt; 4) return res; sort(nums.begin(), nums.end()); for (auto i = 0; i &lt; n - 3; ++ i) { if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for (auto k = i + 1; k &lt; n - 2; ++ k) { if (k &gt; i + 1 &amp;&amp; nums[k] == nums[k - 1]) continue; int l = k + 1; int r = n - 1; while (l &lt; r) { int sum = nums[i] + nums[k] + nums[l] + nums[r]; if (sum == target) { res.push_back({nums[i], nums[k], nums[l], nums[r]}); while (l &lt; r &amp;&amp; nums[l] == nums[++ l]) { } while (l &lt; r &amp;&amp; nums[r] == nums[--r ]) { } } else if (sum &lt; target) { ++ l; } else { -- r; } } } } return res; }};","link":"/2019/11/14/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"19-删除链表的倒数第N个节点","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 36.08% linked-list / two-pointers Unknown 1. 题目给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。 12345示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 2. 解法：双指针法如何找到链表的倒数第 $n$ 个节点？ 定义两个指针 l1，l2，均指向头结点。 先让 l1 向右移动 n - 1 次。 然后再同时向右移动 l1 和 l2，等到 l1 移动到尾节点时， l2 此时指向倒数第 n 个节点。 需要注意的是，我们目的是要 删除 倒数第 n 个节点，所以我们要找到倒数第 n + 1 个节点。也就是步骤 2 中，l1 总共应该向右移动 n 次。 接下来，思考这么一个问题。 假如我们的链表长度为 $n$，而我们要删除倒数第 $n$ 个元素（也就是第一个元素），这时会有什么问题呢？ 答案很明显，我们无法找到倒数第 $n+1$ 个元素，也就是第0个元素，但是我们没有第0个元素，这时就无法删除第一个元素了。 有的人可能会说，那我们直接对这种情况特殊处理就好啦。但是，需要注意的是，我们的复杂度要求是 只遍历一遍链表 ，也就是我们先前并不知道链表的长度，也就无法判断是否是这种情况。 在这里，我们给出两种解决办法。 2.1 解法一向头结点前增加一个结点，也就是添加了第0个元素。 注意一个问题。 最后返回的是 h-&gt;next，开头我们定义了 l1 = l2 = h, l1-&gt;next = head，即：h-&gt;next = head，那么能不能返回 head 呢？答案是不能。在删除的是第一个元素的情况下结果会出错，例如： 123456输入：[1,2,3,4,5] 5输出：[1,2,3,4,5]预期结果：[2,3,4,5] 因为我们的目的是删除该头结点，我们并没有对 head 这个头结点有任何操作，那么最后返回 head 的话就必定会有头结点存在。 我们会在解法二中看到，处理删除第一个元素的情况是返回 head-&gt;next。 执行用时: 8 ms, 在所有 cpp 提交中击败了72.41%的用户内存消耗: 8.6 MB, 在所有 cpp 提交中击败了76.23%的用户 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 头结点前增加一个结点 ListNode* l1 = new ListNode(-1); l1-&gt;next = head; ListNode* l2 = l1; ListNode* h = l2; for (auto i = 0; i &lt; n; ++ i) { l1 = l1-&gt;next; } while (l1-&gt;next) { l1 = l1-&gt;next; l2 = l2-&gt;next; } l2-&gt;next = l2-&gt;next-&gt;next; return h-&gt;next; }}; 2.1 解法二 参考【微笑永恒】 先让 l1 向右移动 n - 1 次，若此时 l1-&gt;next 为空，说明我们要删除第一个元素。直接返回 head-&gt;next 即可。 若 l1-&gt;next 不为空，l1 再向右移动一次，即共移动 n 次。 执行用时: 4 ms, 在所有 cpp 提交中击败了96.70%的用户内存消耗: 8.4 MB, 在所有 cpp 提交中击败了90.51%的用户 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* l1 = head; ListNode* l2 = l1; // 右移n-1次 for (auto i = 0; i &lt; n - 1; ++ i) { l1 = l1-&gt;next; } // 判断要删除的元素是不是第一个元素 if (!l1-&gt;next) return head-&gt;next; // 应该右移n次，补上一次 l1 = l1-&gt;next; // 两个指针同时移动，直到l1到末尾 while (l1-&gt;next) { l1 = l1-&gt;next; l2 = l2-&gt;next; } // 删除该元素 l2-&gt;next = l2-&gt;next-&gt;next; return head; }};","link":"/2019/11/14/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"2-两数相加","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 46.90% linked-list / math adobe / airbnb / amazon / bloomberg / microsoft 1. 题目给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 1234示例:输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-two-numbers 2. 解法2.1 解法一例如(2 -&gt; 4 -&gt; 3) +(5 -&gt; 6 -&gt; 4 -&gt; 2)新建一个链表h，用于存储每一步相加的结果。首先循环内的条件为l1 || l2，即l1或l2有一个不为空时。对于l1和l2，如果没有到达尾部，则链表指向下一个（next），并且sum加上其值；如果某链表到达尾部之后（即为NULL时），链表则不动，也不再加上该链表的值。将对应位置两个数相加，如果&gt;=10，进位标志(carry)为true。此时下一次循环的sum要额外加1。循环结束后，如果最后两个数字相加&gt;=10（即carry==true），则还要增加一个节点，值为1。注意：我们并没有使用h的头结点，我们先是令其指向next，再赋值。主要是考虑最后一次循环，不这样的话会创建一个新的无用的节点。最后我们释放掉无用的头结点，因为如果调用次数多会溢出。 执行用时：28 ms, 在所有 cpp 提交中击败了91.26%的用户内存消耗：10.3 MB, 在所有 cpp 提交中击败了84.73%的用户 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(-1); //头结点，不保存任何信息 ListNode *h = head; int sum; bool carry = false; while (l1 || l2) { sum = 0; if (l1) { sum += l1-&gt;val; l1 = l1-&gt;next; } if (l2) { sum += l2-&gt;val; l2 = l2-&gt;next; } if (carry) sum ++; carry = (sum &gt;= 10 ? true : false); head-&gt;next = new ListNode(0); head = head-&gt;next; head-&gt;val = sum % 10; } if (carry) head-&gt;next = new ListNode(1); // 释放头结点（初始创建的val = -1 的节点），c++要手动释放，否则调用次数多会溢出 ListNode *ptrDelete = h; h = h-&gt;next; delete ptrDelete; return h; // 参考https://leetcode-cn.com/u/chenlele/ }};","link":"/2019/10/16/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"20-有效的括号","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 39.88% string / stack airbnb / amazon / bloomberg / facebook / google / microsoft / twitter / zenefits 1. 题目给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 12345678910111213141516171819示例 1:输入: \"()\"输出: true示例 2:输入: \"()[]{}\"输出: true示例 3:输入: \"(]\"输出: false示例 4:输入: \"([)]\"输出: false示例 5:输入: \"{[]}\"输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses/ 2. 解法 通过栈来解决。 遇见左括号就压入栈中，遇见右括号，则判断当前栈顶元素是否是对应的左括号。若是，则将该左括号出栈；若不是，则返回 false。 最后根据栈是否为空来判断括号是否有效，栈为空则有效。 执行用时: 4 ms, 在所有 cpp 提交中击败了75.87%的用户内存消耗: 8.6 MB, 在所有 cpp 提交中击败了71.46%的用户 1234567891011121314151617class Solution {public: bool isValid(string s) { stack&lt;char&gt; st; map&lt;char, char&gt; m = { {'(', ')'}, {'[', ']'}, {'{', '}'} }; for (auto c : s) { if (!st.empty() &amp;&amp; m[st.top()] == c) { st.pop(); } else if (m[c] == 0) { // m[c] == 0即：是右括号的情况 return false; }else { st.push(c); } } return st.empty(); }};","link":"/2019/11/15/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"},{"title":"21-合并两个有序链表","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 57.92% linked-list amazon / apple / linkedin / microsoft 1. 题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 1234示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/ 2. 解法2.1 解法一：归并排序 创建一个新的链表 h ，用于存储合并后的链表。 遍历两个链表。比较两者当前的 val 大小，小的则加入到 h 中，并向后移，另外一个链表不用移动。直至某一个链表遍历到尾部，结束。 此时肯定有一个链表没有遍历到尾部，将这个链表剩余的元素依次加入到 h 后面即可。 执行用时: 8 ms, 在所有 cpp 提交中击败了96.15%的用户内存消耗: 9.1 MB, 在所有 cpp 提交中击败了73.70%的用户 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* h = new ListNode(0); ListNode* head = h; while(l1 &amp;&amp; l2) { if (l1-&gt;val &lt; l2-&gt;val) { h-&gt;next = new ListNode(l1-&gt;val); h = h-&gt;next; l1 = l1-&gt;next; } else { h-&gt;next = new ListNode(l2-&gt;val); h = h-&gt;next; l2 = l2-&gt;next; } } if (l1) { while(l1) { h-&gt;next = new ListNode(l1-&gt;val); h = h-&gt;next; l1 = l1-&gt;next; } } else if (l2) { while(l2) { h-&gt;next = new ListNode(l2-&gt;val); h = h-&gt;next; l2 = l2-&gt;next; } } ListNode* ptrDelete = head; head = head-&gt;next; delete ptrDelete; return head; }}; 2.2 解法二：递归（两种）2.2.1 简单递归 参考zxyperfect 递归思路： 我们每次从两个链表的头结点选出一个较小的放在结果中，并在原链表中删除该结点，然后继续比较两个链表。直至一个链表为空。 递归结束条件：当某个链表为空时，递归结束，但我们返回的是另一个链表。因为另一个链表剩下的肯定是值最大的那部分。例如：if(l1 == nullptr) { return l2; }。 执行用时: 12 ms, 在所有 cpp 提交中击败了69.38%的用户内存消耗: 9 MB, 在所有 cpp 提交中击败了74.60%的用户 12345678910111213141516171819class Solution {public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { if(l1 == nullptr){ return l2; } if(l2 == nullptr){ return l1; } if(l1-&gt;val &lt;= l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; } else{ l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } }}; 2.2.2 利用swap函数递归 参考 StefanPochmann swap函数介绍：swap(a, b) ：交换a和b。在此结构体中的意思就是 a-&gt;next 和 b-&gt;next 交换，a-&gt;val 和 b-&gt;val 也交换。 首先注意，我们的合并后的链表是 a 头结点所指向的链表，也就是 a 所走过的位置, 都被按顺序加了进来。 总的思想就是：若 a-&gt;val &gt; b-&gt;val ，就 swap(a, b) ，把 a 放到小的那个节点。反之，a 继续向所在节点后面移动，继续比较，a 会始终保持在较小的那个节点上。 若 a 所在链表到达尾部时（a = nullptr），说明另外一个链表剩余的都是最大的几个值，我们这时仍需要 swap(a, b) ，将 a 放到另一个链表剩余的值上。 后续我会画个图例出来。 执行用时 :8 ms, 在所有 cpp 提交中击败了95.91%的用户内存消耗 :8.7 MB, 在所有 cpp 提交中击败了97.11%的用户 12345678910111213141516/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* a, ListNode* b) { if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b); if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b); return a; }};","link":"/2019/11/19/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"22-括号生成","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 72.20% string / backtracking google / uber / zenefits 1. 题目给出 $n$ 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 123456789例如，给出 n = 3，生成结果为：[ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/generate-parentheses/ 2. 解法2.1 解法一：回溯以 n = 3 为例：我们的字符串 s 一共有 6 个位置来放置 '(' 和 ')'。 首先我们知道：第一个位置一定是 '('，此时 s = ( _ _ _ _ _。 此时我们考虑第二个位置，我们选择可以放置'(' 或 ')'。那么什么情况下，我们可以有两个选择呢？很容易想到，应该是当 '(' 的数量大于 ')' 的数量 并且 '(' 的数量小于 n 时，即 if (left &lt; N &amp;&amp; left &gt; right)。可以思考 s = ( ( ) _ _ _ 和 s = ( ( ( ) _ _这两种情况下，下一个位置应该放哪种括号。 步骤2中，我们可以有两个选择。那么我们接下来就应该考虑什么情况下只有一种选择。 只能放置 '('。易知，当 '(' 的数量等于 ')' 的数量时，我们只能向后添加 '(' 。可以思考 s = ( ( ) ) _ _ 和 s = ( ) ( ) _ _这两种情况下，下一个位置应该放哪种括号。 只能放置 ')'。易知，当 '(' 的数量等于 n 时，我们只能向后添加 ')' 。可以思考 s = ( ( ( _ _ _ 和 s = ( ) ( ( _ _这两种情况下，下一个位置应该放哪种括号。 我们的回溯函数 void backtrack(int left, int right, const string &amp;s) 中，left 和 right 代表的是 s 中左右括号的数量。当 left + right == 2 * N 时，回溯结束。 注意：初始情况下，我们必须要先添加一个 '('，此时 s = ( _ _ _ _ _，所以参数 left = 1, right = 0。 执行用时: 4 ms, 在所有 cpp 提交中击败了96.60%的用户内存消耗: 17.4 MB, 在所有 cpp 提交中击败了36.95%的用户 12345678910111213141516171819202122232425class Solution {public: vector&lt;string&gt; res; int N; vector&lt;string&gt; generateParenthesis(int n) { N = n; string s = \"\"; backtrack(1, 0, s + \"(\"); return res; } void backtrack(int left, int right, const string &amp;s) { if (left + right == 2 * N) { res.push_back(s); return; } if (left &lt; N &amp;&amp; left &gt; right) { backtrack(left + 1, right, s + \"(\"); backtrack(left, right + 1, s + \")\"); } else if (left == N) { backtrack(left, right + 1, s + \")\"); } else if (left == right) { backtrack(left + 1, right, s + \"(\"); } }}; 2.2 解法二：动态规划 参考 rockrock2，Yuyu 首先看 n 较小时的结果。 n = 0 是，res = { &quot;&quot; }，为空。 n = 1 是，res = { &quot;()&quot; }。 n = 2 是，res = { &quot;(())&quot;, &quot;()()&quot; }。 n = 3 是，res = { &quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot; }。 问题来了，你没有考虑过每一个 n 的结果，都和比它小的 n 的结果，有点关联？ 我们可以这么看待这个问题： n = i 的结果其实就是比 n = i - 1 多了一对括号。我们可能会想，那么这对括号应该如何放置呢？而事实上，我们应该这样想，那么 n = 1..i-1 的结果，应该如何放到这对括号里呢？也就是这对括号，是不动的。 我们只有两个地方可以放，一是这一对括号内部，二是括号外部。外部： 其实放在括号左侧或者右侧都行。但是放在右侧，结果会按照字典序排列，因此我们选择放在右侧。但是要知道，放在左侧也是可以的。 我们要对所有 n &lt; i 的情况遍历，要保证最后括号一共 i 对。 所以如果内部放 n = 0 的结果，右侧就要放 n = i - 1 的结果，排列所有情况。 如果内部放 n = 1 的结果，右侧就要放 n = i - 2 的结果，排列所有情况。 以此类推。。。最后，内部放 n = i - 1 的结果，右侧就要放 n = 0 的结果，排列所有情况。 我们可以得出状态方程：dp[i] = '(' + dp[k] + ')' + dp[i-1-k], k = 0..i-1 执行用时: 8 ms, 在所有 cpp 提交中击败了82.13%的用户内存消耗: 9.9 MB, 在所有 cpp 提交中击败了97.08%的用户 1234567891011121314151617181920// dp[0] = \"\"// dp[i] = '(' + dp[k] + ')' + dp[i-1-k], k = 0..i-1 (按字典序)// 或者dp[i] = dp[k] + '(' + dp[i-1-k] + ')', k = 0..i-1 (非字典序)class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt; vector&lt;string&gt; &gt; dp(n + 1, vector&lt;string&gt;()); dp[0] = {\"\"}; for (auto i = 1; i &lt; n + 1; ++ i) { for (auto k = 0; k &lt; i; ++ k) { for (auto s1 : dp[k]) { for (auto s2 : dp[i - 1 - k]) { dp[i].push_back(\"(\" + s1 + \")\" + s2); } } } } return dp[n]; }};","link":"/2019/11/21/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"title":"23-合并K个排序链表","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 72.20% linked-list / divide-and-conquer / heap airbnb / amazon / facebook / google / linkedin / microsoft / twitter / uber 1. 题目合并 $k$ 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 12345678示例:输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-k-sorted-lists 2. 解法2.1 解法一：全部合并再排序暴力而有效的解法：我们将 $k$ 个链表全部放入向量中，然后进行排序，最后再放回到一个链表中。 当然我们也可以使用优先队列，那么在放入元素时自动进行了排序。 两者的性能是几乎没有任何差别的。 2.1.1 向量 vector 执行用时: 32 ms, 在所有 cpp 提交中击败了89.24%的用户内存消耗: 11.7 MB, 在所有 cpp 提交中击败了63.01%的用户 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { vector&lt;int&gt; elem; ListNode *head = new ListNode(0); ListNode *h = head; for (auto &amp;vec : lists) { while(vec) { elem.push_back(vec-&gt;val); vec = vec-&gt;next; } } sort(elem.begin(), elem.end()); for (auto i : elem) { head-&gt;next = new ListNode(i); head = head-&gt;next; } ListNode *ptrDelete = h; h = h-&gt;next; delete ptrDelete; return h; }}; 2.1.2 优先队列 priority_queue 执行用时: 36 ms, 在所有 cpp 提交中击败了78.17%的用户内存消耗: 11.6 MB, 在所有 cpp 提交中击败了66.99%的用户 1234567891011121314151617181920212223class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; ListNode *head = new ListNode(0); ListNode *h = head; for (auto &amp;vec : lists) { while(vec) { q.push(vec-&gt;val); vec = vec-&gt;next; } } while (!q.empty()) { head-&gt;next = new ListNode(q.top()); q.pop(); head = head-&gt;next; } ListNode *ptrDelete = h; h = h-&gt;next; delete ptrDelete; return h; }}; 2.2 解法二：两两合并链表利用 LeetCode-21题：合并两个有序链表 ，将合并 $k$ 个链表转化为合并 $k-1$ 次两个链表。 也就是将前两个链表合并成新的链表，新链表再和第三个链表合并，合并出的新链表再和第四个链表合并……不过这个方法的复杂度很高。 执行用时: 1428 ms, 在所有 cpp 提交中击败了5.02%的用户内存消耗: 13.9 MB, 在所有 cpp 提交中击败了17.09%的用户 123456789101112131415class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { ListNode *res = nullptr; for (auto vec : lists) { res = mergeTwoLists(res, vec); } return res; } ListNode* mergeTwoLists(ListNode* a, ListNode* b) { if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b); if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b); return a; }}; 2.3 解法三：分治 参考 Sun 两两合并链表，最后变成了 $\\frac{k}{2}$ 个链表，继续合并，链表数目 $\\frac{k}{2}$ -&gt; $\\frac{k}{4}$ -&gt; $\\frac{k}{8}$… ，直至最后变为一个链表。 我们使用队列实现该操作，将队列前两个链表合并后并弹出，合并后的链表添加到队列尾部，如此循环，直至队列中只有一个链表。 执行用时: 28 ms, 在所有 cpp 提交中击败了96.42%的用户内存消耗: 14.2 MB, 在所有 cpp 提交中击败了17.09%的用户 12345678910111213141516171819202122232425class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { if (lists.size() == 0) return NULL; if (lists.size() == 1) return lists[0]; queue&lt;ListNode*&gt; q; for (auto vec : lists) q.push(vec); while(q.size() &gt; 1) { ListNode* l1 = q.front(); q.pop(); ListNode* l2 = q.front(); q.pop(); q.push(mergeTwoLists(l1, l2)); } return q.front(); } ListNode* mergeTwoLists(ListNode* a, ListNode* b) { if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b); if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b); return a; }};","link":"/2019/12/08/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"24-两两交换链表中的节点","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 72.20% linked-list bloomberg / microsoft / uber 1. 题目给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 12示例:给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 2. 解法2.1 解法一：递归解法我们以 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 为例。 我们拿出中间两个节点进行分析，例如 3 -&gt; 4 。 我们最终要使 4 指向 3 ，上一个节点指向 4，3 指向下一个节点。即 上一节点 -&gt; 4 -&gt; 3 -&gt; 下一节点。 我们对每一对节点都是 步骤2 中这样操作的。 现在有两个问题，递归函数返回什么？怎么使用递归函数的返回值？ 假设我们在某次调用递归时完成了前两个节点的交换，得到了 4 -&gt; 3 ，这时 结点 4 应该返回给上一次递归函数的结果，结点 3 应该指向下一次的递归函数的返回值。 然后，传递给递归函数的结点应该向后移动两位。 递归结束的条件？当我们的结点数不足两个时，递归结束。 执行用时: 8 ms, 在所有 cpp 提交中击败了49.37%的用户内存消耗: 8.7 MB, 在所有 cpp 提交中击败了73.37%的用户 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head) { if (head == nullptr || head-&gt;next == nullptr) { return head; } ListNode *next = head-&gt;next; head-&gt;next = swapPairs(next-&gt;next); next-&gt;next = head; return next; }}; 2.2 解法二：非递归解法我们用两个图来描述这个算法的过程。 实线箭头是原来的链表结构，虚线是我们改变之后的。 ①②③④是我们交换链表的过程顺序。 注意，p 指针最后会更新（如④所示）。 当 p 之后的结点数不足两个时，循环结束。 执行用时: 8 ms, 在所有 cpp 提交中击败了49.37%的用户内存消耗: 8.6 MB, 在所有 cpp 提交中击败了79.04%的用户 1234567891011121314151617class Solution {public: ListNode* swapPairs(ListNode* head) { ListNode *p = new ListNode(-1); p-&gt;next = head; ListNode *h = p; while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) { ListNode *c = p-&gt;next; ListNode *n = p-&gt;next-&gt;next; p-&gt;next = c-&gt;next; c-&gt;next = n-&gt;next; n-&gt;next = c; p = c; } return h-&gt;next; }};","link":"/2019/12/11/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"3-无重复字符的最长子串","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 36.10% hash-table / two-pointers / string / sliding-window adobe / amazon / bloomberg / yelp 1. 题目给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 123456789101112131415示例 1:输入: \"abcabcbb\"输出: 3解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例 2:输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例 3:输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是**子串**的长度，\"pwke\" 是一个子序列，不是子串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters 2. 解法2.1 解法一2.1.1 滑动窗口法：我们依次将每个字符及其下标（从1开始，最后会解释为什么从1）存进map中。当遇到某个重复的字符 ch 时并且 m[s[i]] &gt;= left，就把 left 设置为前一个与他重复的 ch 的value值加1，此时 (i-left+1)（i从0开始）就是上一个无重复子串的长度。例如：jbpnbwwe i=0, s[i]='j', left=1, m['j']=0 (因为m中没有‘j’),所以将 m['j'] = i+1 = 1存入map。 同理 'b', 'p', 'n' 都是插入map中。 此时 i=4, s[i]='b', left=1, m['b']=2 &gt; left ; 此时无重复子串长度为4 (&quot;jbpn&quot;), left 值变为 'b' 的下一位的下标值即5; 同时更新 m['b'] 的值为5。 往后同理。 2.2.2 为什么 m[s[i]] &gt;= left，而不是 m[s[i]] &gt; left考虑如果当前 left 所对应的字符就是下一次重复的字符。极端情况例如 &quot;abbbbb&quot;。 2.2.3 为什么 m[s[i]] = i + 1 ，而不直接等于 i？left为什么初值为1考虑极端情况。例如：只有一个字母 a（或者是无重复字符串 &quot;abcd&quot;）假如 left=0，那么就会进入if语句中，left 会加1，而我们并没有重复的字符，left 不应该加1。主要就是因为map中，如果没有元素c，那么 m[c] 会返回0。 执行用时 :16 ms, 在所有 cpp 提交中击败了75.44%的用户内存消耗 :10.8 MB, 在所有 cpp 提交中击败了79.63%的用户 1234567891011121314151617181920class Solution {public: int lengthOfLongestSubstring(string s) { // 在不需要排序功能的情况下，建议使用unordered_map，它比map快。 unordered_map&lt;char, int&gt; m; int max = 0; int left = 1; for (auto i = 0; i &lt; s.size(); ++ i) { if (m[s[i]] &gt;= left) { max = (max &gt; (i-left+1) ? max : (i-left+1)); left = m[s[i]] + 1; } // 字符s[i]对应的位置为i+1,因为map不存在该元素时会返回0； m[s[i]] = i + 1; } // 可能出现一种情况：整个字符串没有重复的，就需要如下代码。 max = (max &gt; (s.size()-left+1) ? max : (s.size()-left+1)); return max; }};","link":"/2019/10/17/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"4-寻找两个有序数组的中位数","text":"Category Difficulty Pass rate Tags Companies algorithms Hard 36.29% array / binary-search / divide-and-conquer adobe / apple / dropbox / google / microsoft / yahoo / zenefits 1. 题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 123456789示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 2. 解法2.1 解法一：归并排序将两个数组进行归并排序，从小到大依次存入vector中。取中位数即可。 执行用时: 24 ms, 在所有 cpp 提交中击败了76.59%的用户内存消耗: 11.3 MB, 在所有 cpp 提交中击败了72.07%的用户 1234567891011121314151617181920212223242526272829class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;double&gt; v; int i1 = 0, i2 = 0; while(i1 != nums1.size() &amp;&amp; i2 != nums2.size()) { if (nums1[i1] &lt;= nums2[i2]) { v.push_back(nums1[i1]); ++ i1; } else { v.push_back(nums2[i2]); ++ i2; } } if (i1 != nums1.size()) { for (i1; i1 &lt; nums1.size(); ++ i1) v.push_back(nums1[i1]); } else { for (i2; i2 &lt; nums2.size(); ++ i2) v.push_back(nums2[i2]); } if ((nums1.size() + nums2.size())%2) return v[(nums1.size() + nums2.size())/2]; else return (v[(nums1.size() + nums2.size())/2] + v[(nums1.size() + nums2.size())/2 - 1]) / 2; }}; 2.2 解法二：递归二分法 题目要求复杂度为O(log(m+n))，所以肯定要使用二分法。 同时我们可以将题目转化为求第k个最小数，即k=(m+n)/2； 对两个序列的第k/2个值进行比较，若nums1[k] &gt; nums2[k]，则nums2的前k/2个数中肯定没有我们要求的第k个最小数。我们将前nums2中前k/2个数剔除。 对新序列的nums1和nums2继续进行求第k1(此时k1=k-k/2)个最小数。 当然我们会遇到一些特殊情况，比如某序列太短，例如(nums1.size() &lt; nums2.size())，此时肯定是nums1可能会出现没有第k/2个数（nums2不会出现这种情况），此时替换为该序列的最后一个值即可。为了简化代码，如果(nums1.size() &gt; nums2.size())，我们就递归函数getKthElem重新传参，将参数调换（即nums1 &lt;-&gt; nums2等）。 由此产生的另外一种需要考虑的问题是，步骤4中的k1=k-k/2是否完全正确？我们每次剔除的元素该不该是k/2个？ 当然不一定，因为有的序列可能没有那么多元素，这时我们需要令k=k-我们剔除的数，即：k=k-min(k/2,len)。在代码中我们不能将 min函数 作为一个参数，因为我们定义了int i = start1 + min(k / 2, len1) - 1, 在实际代码中我们使用(j - start2 + 1)来替代它。 那么问题来了，6中这种替换是正确的吗？ 其实这种替换是无妨的，因为们剔除的元素始终小于k/2个，当len &lt; k/2时，剔除了len个元素，我们此时只是不是严格的二分了。我们每次少剔除几个元素在逻辑上是没有问题的（当然多的话就会有问题），因为在k/2前的这几个元素肯定不是我们要找的第k个最小数。 递归函数什么时候结束呢？ 两种情况：一是某个序列的长度变为了0，那么我们只需在另一个序列中找第k个最小数即可；二是k=1时，此时找的是两个序列的第1个最小值，那么就是两个序列第一个元素较小的那个。 执行用时: 8 ms, 在所有 cpp 提交中击败了99.98%的用户内存消耗: 9.7 MB, 在所有 cpp 提交中击败了86.47%的用户 12345678910111213141516171819202122232425262728293031class Solution {public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int m = nums1.size(); int n = nums2.size(); int k = (m + n) / 2; if ((m + n) % 2) return getKthElem(nums1, 0, m - 1, nums2, 0, n - 1, k + 1); else return (getKthElem(nums1, 0, m - 1, nums2, 0, n - 1, k) + getKthElem(nums1, 0, m - 1, nums2, 0, n - 1, k + 1)) * 0.5; } int getKthElem(vector&lt;int&gt;&amp; nums1, int start1, int end1, vector&lt;int&gt;&amp; nums2, int start2, int end2, int k) { int len1 = end1 - start1 + 1; int len2 = end2 - start2 + 1; if (len1 &gt; len2) return getKthElem(nums2, start2, end2, nums1, start1, end1, k); if (len1 == 0) return nums2[start2 + k - 1]; if (k == 1) return min(nums1[start1], nums2[start2]); int i = start1 + min(k / 2, len1) - 1; int j = start2 + min(k / 2, len2) - 1; if (nums1[i] &gt; nums2[j]) // 注意：(j - start2 + 1) = min(k / 2, len1) // 但是我们不能将min函数作为参数。 return getKthElem(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1)); else return getKthElem(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1)); } // 参考https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/};","link":"/2019/10/19/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"title":"5-最长回文子串","text":"Category Difficulty Pass rate Tags Companies algorithms Hard 36.29% string / dynamic-programming amazon / bloomberg / microsoft 1. 题目给定一个字符串s，找到s中最长的回文子串。你可以假设s的最大长度为 1000。 12345678示例 1：输入: \"babad\"输出: \"bab\"注意: \"aba\" 也是一个有效答案。示例 2：输入: \"cbbd\"输出: \"bb\" 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-palindromic-substring/ 2. 解法 参考：windliang 2.1 解法一：最长共同子串(动态规划法)2.1.1 为什么用可以最长共同子串？ 假设s2是s1的逆序字符串。 若s1中有回文子串，则s1和s2中一定有相同的该子串。例如：s1 = &quot;afbcbfae&quot;, 则s2 = &quot;eafbcbfa&quot;,那么fbcbf就是它俩的共同最长子串，也是s1的最长回文子串。 不过需要注意一些特例：s1 = &quot;abc123cba&quot;, 则s2 = &quot;abc321cba&quot;;我们发现它俩有两个共同子串abc和bca，但是这两个都不是回文子串。 对于3中的情况，我们需要加一步判断来解决该问题。即s1中abc和s2中abc他们的下标是否对应。对于s2中子串abc来讲，其中a在s1逆置之前的下标应该是8(即:s1.size() - 1)。通用的说法就是，当s2[j] == s[i]时，设s2中的该字符c在s2中的下标为j，它在逆置之前，在s1中的下标为jBefore，那么jBefore = s1.size() - 1 - j，此时s1中下标为i，d[i][j]是该回文串的长度，那么就必须满足i = jBefore + d[i][j] - 1。那么我们可以推断出，当s1[i] == s[j]时，只要满足该条件，那么就是回文子串。 2.1.2 动态规划法 我们设置一个二维n*n数组d表示两个字符串每个字符相等的关系。（字符串长度为n） 若s1[i] == s[j]，则d[i][j] = d[i-1][j-1] + 1。当i=0或者j=0时，上述公式会越界。所以我们直接令d[i][j] = 1。 例如s1 = &quot;afbcbfae&quot;，那么d为 s1\\s2 e a f b c b f a a 0 1 0 0 0 0 0 1 f 0 0 2 0 0 0 1 0 b 0 0 0 3 0 1 0 0 c 0 0 0 0 4 0 0 0 b 0 0 0 1 0 5 0 0 f 0 0 1 0 0 0 6 0 a 0 1 0 0 0 0 0 7 e 1 0 0 0 0 0 0 0 我们只需记录下d中最大数对应的下标即可。 我们观察到d[2][3]=3(行为i，列为j)，此时j = 3, jBefroe = 8-1-3 = 4; i = 2而jBefore + d[i][j] - 1 = 4+3-1 = 6,所以此时不是回文子串。 再看d[6][7]=7，此时j = 7, jBefroe = 8-1-7 = 0; i = 6而jBefore + d[i][j] - 1 = 0+7-1 = 6,所以此时是回文子串。 对于s1 = &quot;abc123cba&quot;来说，d为 s1\\s2 a b c 3 2 1 c b a a 1 0 0 0 0 0 0 0 1 b 0 2 0 0 0 0 0 1 0 c 0 0 3 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 2 0 0 0 0 1 0 0 0 0 3 0 0 0 1 0 0 0 0 0 c 0 0 1 0 0 0 1 0 0 b 0 1 0 0 0 0 0 2 0 a 1 0 0 0 0 0 0 0 3 我们观察到d[2][2]=3(行为i，列为j)，此时j = 2, jBefroe = 9-1-2 = 6; i=2而jBefore + d[i][j] - 1 = 6+3-1 = 7,所以此时不是回文子串。 再看d[8][8]=3，此时j = 8, jBefroe = 9-1-8 = 0; i = 8而jBefore + d[i][j] - 1 = 0+3-1 = 2,所以此时也不是回文子串。 执行用时 :320 ms, 在所有 cpp 提交中击败了22.88%的用户内存消耗 :13.3 MB, 在所有 cpp 提交中击败了47.92%的用户 1234567891011121314151617181920212223242526272829303132333435// 时间复杂度O(n^2),空间复杂度O(n^2)class Solution {public: string longestPalindrome(string s) { int n = s.size(); if (n == 0) return \"\"; string s1 = s; reverse(s1.begin(), s1.end()); int d[n][n]; int maxLen = 0; int maxEnd = 0; for (auto i = 0; i &lt; n; ++ i) { for (auto j = 0; j &lt; n; ++ j) { if (s[i] == s1[j]) { if (i &gt; 0 &amp;&amp; j &gt; 0) d[i][j] = d[i-1][j-1] + 1; else d[i][j] = 1; } else { d[i][j] = 0; } if (d[i][j] &gt; maxLen) { int jBeforeReverse = n - 1 - j; if (jBeforeReverse + d[i][j] - 1 == i) { maxLen = d[i][j]; maxEnd = i; } } } } return s.substr(maxEnd - maxLen + 1, maxLen); }}; 2.2解法二：最长共同子串(改进)在解法一中我们使用了二维数组，实际上使用一维数组也可以解决。解法一中，当i=0时，我们计算出j=1…n的值，i=1时，我们又根据前一列计算出这一列的j=1…n的值。实际上，我们计算某一列的值时，只需要使用它的左上角的元素（d[i][j] = d[i-1][j-1] + 1），即前一列的信息。 我们规定若s1[i] == s[j]，则d[j] = d[j-1] + 1。当j=0时，上述公式会越界。所以我们直接令d[j] = 1。 但是我们必须要注意到如下的问题：假设i=0时，我们已经求出一组d的值，当i=1时，如果我们j从0——n来循环，那么比如求出d[1] = d[0] + 1（此时d[0]还是上一次的信息）。我们再求d[2] = d[1] + 1，但这时d[1]的值已经被修改了，不是i=0时的值了。所以我们的j必须从n——0来循环。 执行用时 :268 ms, 在所有 cpp 提交中击败了28.68%的用户内存消耗 :8.7 MB, 在所有 cpp 提交中击败了96.28%的用户 12345678910111213141516171819202122232425262728293031323334class Solution {public: string longestPalindrome(string s) { int n = s.size(); if (n == 0) return \"\"; string s1 = s; reverse(s1.begin(), s1.end()); int d[n]; int maxLen = 0; int maxEnd = 0; for (auto i = 0; i &lt; n; ++ i) { for (auto j = n - 1; j &gt;= 0; -- j) { if (s[i] == s1[j]) { if (i &gt; 0 &amp;&amp; j &gt; 0) d[j] = d[j-1] + 1; else d[j] = 1; } else { d[j] = 0; } if (d[j] &gt; maxLen) { int jBeforeReverse = n - 1 - j; if (jBeforeReverse + d[j] - 1 == i) { maxLen = d[j]; maxEnd = i; } } } } return s.substr(maxEnd - maxLen + 1, maxLen); }}; 2.3 解法三：中心拓展法核心思想就是指定一个中心元素，分别比较两侧的元素是否相等。当然我们会遇到奇数个或偶数个的回文子串。对于奇数个的，我们指定一个中心元素；对于偶数个的，我们指定两个中心元素；然后向两侧拓展比较。 执行用时 :20 ms, 在所有 cpp 提交中击败了90.24%的用户内存消耗 :8.7 MB, 在所有 cpp 提交中击败了96.28%的用户 12345678910111213141516171819202122232425262728// 时间复杂度O(n^2),空间复杂度O(1)class Solution {public: string longestPalindrome(string s) { int n = s.size(); if (n == 0) return \"\"; int start = 0, maxLen = 0; for (auto i = 0; i &lt; n; ++ i) { int len1 = expandFromCenter(s, i, i); int len2 = expandFromCenter(s, i, i + 1); int len = max(len1, len2); if (len &gt; maxLen) { maxLen = len; start = i - (len - 1)/2; } } return s.substr(start, maxLen); } int expandFromCenter(string &amp;s, int left, int right) { while (left &gt;= 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) { left --; right ++; } // 每次到循环最后，left多减了1，right多加了1 return (right - left - 1); }}; 2.4 解法四：Manacher’s Algorithm 马拉车算法好复杂，日后再更。","link":"/2019/10/21/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"6-Z字形变换","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 45.35% string Unknown 1. 题目将一个给定字符串根据给定的行数，以从上往下、从左到右进行Z字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 请你实现这个将字符串进行指定行数变换的函数：string convert(string s, int numRows); 123456789101112示例 1:输入: s = \"LEETCODEISHIRING\", numRows = 3输出: \"LCIRETOESIIGEDHN\"示例 2:输入: s = \"LEETCODEISHIRING\", numRows = 4输出: \"LDREOEIIECIHNTSG\"解释:L D RE O E I IE C I H NT S G 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/zigzag-conversion 2. 解法2.1 解法一按每行从左到右依次输出。以示例2为例， 123456789L D RE O E I IE C I H NT S G对应的下标如下：0 6 121 5 7 11 132 4 8 10 143 9 15 我们的任务是找出每一行的下标。 对于第一行和最后一行来说，它只有3个数，而其他行是它的二倍，有6个数。 我们以下标0-5为第一组，6-11为第二组，以此类推，每6个数一组，不足6个数的也算作一组。 6是怎么求的呢？k = 2 * (numRows - 1) = 2*(4-1) = 6 一共有多少组呢？loopNum = (n + k - 1) / k;(n为s的长度)，注意：不足k个的也算作一组。 对于第一行和最后一行来说，初值为i（start1 = i），我们只需要每次循环加上k即可。 对于其他行，我们每组有两个数。前一个数和步骤5中一样，初值为i（start1 = i）；第二个数的初值是关键，start2 = start1 + (numRows-(i+1))*2；每次循环都加上k即可，循环总次数为numRows。 执行用时 :8 ms, 在所有 cpp 提交中击败了97.82%的用户内存消耗 :10.3 MB, 在所有 cpp 提交中击败了88.53%的用户 1234567891011121314151617181920212223242526272829303132class Solution {public: string convert(string s, int numRows) { int n = s.size(); if (numRows == 1) return s; int k = 2 * (numRows - 1); string str = \"\"; int loopNum = (n + k - 1) / k; for (auto i = 0; i &lt; numRows; ++ i) { int start1 = i; int start2 = 0; if (i != 0 &amp;&amp; i != (numRows -1)) start2 = start1 + (numRows-(i+1))*2; for (auto j = 0; j &lt; loopNum; ++ j) { if (start1 &lt; n) { str += s[start1]; start1 += k; } if (i != 0 &amp;&amp; i != (numRows -1)) { if (start2 &lt; n) { str += s[start2]; start2 += k; } } if (start1 &gt;= n &amp;&amp; start2 &gt;= n) break; } } return str; }}; 2.2 解法二 参考：麓山南路飞行员 主要思想就是：一共有numRows行，找出每个字符所在的行数，依次添加到该行。关键代码int row = i % k &lt; numRows ? i % k : k - i % k; 以示例2为例， 123456789L D RE O E I IE C I H NT S G对应的下标如下： 行数：0 6 12 01 5 7 11 13 12 4 8 10 14 23 9 15 3 易知k = 6, numsRows = 4，我们以下标0-5为例。第一种情况是下标0-3，第二种情况是下标4-5，这两种情况区分的标志是i % k &lt; numRows。 很容易知道第一种情况的行数为i % k；第二种情况，对于5来说，row = 1 = 6 - 5；对于11来说，row = 1 = 6 - 11...，11怎么才能变成5呢，当然是对6取余啦。所以第二种情况行数为k - i % k。 执行用时 :20 ms, 在所有 cpp 提交中击败了58.47%的用户内存消耗 :12.7 MB, 在所有 cpp 提交中击败了78.71%的用户 123456789101112131415161718class Solution {public: string convert(string s, int numRows) { if (numRows == 1) return s; int n = s.size(); int k = 2 * (numRows - 1); string str; vector&lt;string&gt; res(numRows); for (auto i = 0; i &lt; n; ++ i) { int row = i % k &lt; numRows ? i % k : k - i % k; res[row] += s[i]; } for (auto i : res) str += i; return str; }};","link":"/2019/10/21/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"title":"7-整数反转","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 33.23% math apple / bloomberg 1. 题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 1234567891011示例 1:输入: 123输出: 321示例 2:输入: -123输出: -321示例 3:输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-integer 2. 解法2.1 解法一利用求余，求出从后往前每一位的值。再利用horner法则(多项式求值)，令X=10求出翻转后的值。 执行用时: 0 ms, 在所有 cpp 提交中击败了100%的用户内存消耗: 8 MB, 在所有 cpp 提交中击败了93.37%的用户 12345678910111213141516class Solution {public: int reverse(int x) { long res = 0; int remainder; while (x != 0) { remainder = x % 10; x = (x - remainder) / 10; res = 10 * res + remainder; } if (res &lt; INT_MIN || res &gt; INT_MAX) return 0; else return res; }};","link":"/2019/10/22/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"title":"8-字符串转换整数 (atoi)","text":"Category Difficulty Pass rate Tags Companies algorithms Medium 18.57% math / string amazon / bloomberg / microsoft / uber 1. 题目请你来实现一个atoi函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 1234567891011121314151617181920212223242526示例 1:输入: \"42\"输出: 42示例 2:输入: \" -42\"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3:输入: \"4193 with words\"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。示例 4:输入: \"words and 987\"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5:输入: \"-91283472332\"输出: -2147483648解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/string-to-integer-atoi 2. 解法2.1 解法一 先找出第一个非空字符的下标 noSpaceIndex 判断正负性 negative，找出数字开始的下标 startIndex 计算出当前下标的数字 curDigit，判断是否溢出 horner法则求出和。 需要注意的是溢出的处理办法：if (res &gt; INT_MAX/10 || (res &gt;= INT_MAX/10 &amp;&amp; curDigit &gt; 7)) 首先我们知道 INT_MAX = 2^31 - 1 = 2147483647，INT_MIN = -2^31 = -2147483648;，res是结果的绝对值。 我们要理解为什么正负溢出对的处理方式相同。举四个例子即可：2147483647，2147483648，-2147483647，-2147483648。其中只有 2147483648 和 -2147483648 会判断成溢出，实际上 -2147483648 是没有溢出的，但是我们最终得到的结果都是INT_MIN = -2147483648，所以并无大碍。 执行用时 :4 ms, 在所有 cpp 提交中击败了93.61%的用户内存消耗 :8.3 MB, 在所有 cpp 提交中击败了93.80%的用户 1234567891011121314151617181920212223242526class Solution {public: int myAtoi(string str) { bool negative = false; int startIndex = 0; int res = 0; int curDigit = 0; while (str[startIndex] == ' ') startIndex ++; if (str[startIndex] == '-') { negative = true; startIndex ++; } else if (str[startIndex] == '+') { startIndex ++; } for (auto i = startIndex;i &lt; str.size() &amp;&amp; isdigit(str[i]); ++ i) { curDigit = str[i] - '0'; if (res &gt; INT_MAX/10 || (res &gt;= INT_MAX/10 &amp;&amp; curDigit &gt; 7)) return (negative ? INT_MIN : INT_MAX); res = res * 10 + curDigit; // res = res * 10 - 48 + static_cast&lt;int&gt;(str[i]); } return (negative ? -res : res); }};","link":"/2019/10/24/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/"},{"title":"9-回文数","text":"Category Difficulty Pass rate Tags Companies algorithms Easy 56.68% math Unknown 1. 题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 12345678910111213示例 1:输入: 121输出: true示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-number 2. 解法2.1 解法一 我们将该数字翻转得到的数字和原数字相等，此时它就是回文数。 考虑翻转后会溢出的问题，我们设置翻转后的数字设置为long类型即可。 当然2中方法并不适用所有情况，我们可以使用以下方法判断. 12if (reverse &gt; INT_MAX / 10 || (reverse &gt;= INT_MAX &amp;&amp; (temp % 10) &gt; 7)) return false; 执行用时: 4 ms, 在所有 cpp 提交中击败了99.52%的用户内存消耗: 7.9 MB, 在所有 cpp 提交中击败了95.45%的用户 1234567891011121314class Solution {public: bool isPalindrome(int x) { if (x &lt; 0) return false; int temp = x; long reverse = 0; while (temp) { reverse = reverse * 10 + temp % 10; temp = temp / 10; } return (reverse == x); }}; 2.2 解法二 我们没有必要将整个数字翻转，只需要将后一半数字反转，再与前一半的数字相比较即可。 例如1234321，后一半的数是321，翻转得到123，前一半的数是123，两者相等，则是回文数。 需要注意奇回文数和偶回文数的处理。 执行用时: 16 ms, 在所有 cpp 提交中击败了75.83%的用户内存消耗: 8.1 MB, 在所有 cpp 提交中击败了82.64%的用户 1234567891011121314151617181920class Solution {public: bool isPalindrome(int x) { int digit = 0; if (x &lt; 0) return false; int temp = x; while (temp) { temp = temp /10; digit ++; } int left = 0, right = 0; left = x / pow(10, (digit + 1) / 2); for (auto i = 0; i &lt; digit / 2; ++ i) { right = right * 10 + x % 10; x = x / 10; } return (left == right ? true : false); }};","link":"/2019/10/26/9-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"title":"执行`hexo d` 时，提示连接Github的22端口超时","text":"问题预览： 1234ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 1.1 问题描述具体错误信息如下： 1234567891011ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (F:\\Program Files\\hexo\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (events.js:210:5) at ChildProcess.cp.emit (F:\\Program Files\\hexo\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) 一开始我把目光聚焦在后面的 Error: Spawn failed 上，但是没有学过前端的我并看不懂。但是，真正的错误是在上面一部分信息里。 12345678ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.ssh：连接到主机github.com端口22：连接超时致命：无法从远程存储库读取。请确保您具有正确的访问权限，并且存储库存在。 1.2 解决办法直接暴力解决：重新配置密钥 git bash 窗口依次输入:（注意：双引号里改为你的Github的名字和邮箱） 1git config --global user.name \"MagicConchCpp\" 1git config --global user.email \"csuzhangyang@gmail.com\" 生成新秘钥： 1ssh-keygen -t rsa -C \"csuzhangyang@gmail.com\" 选择文件路径，然后遇到下面这个直接回车。 123$ ssh-keygen -t rsa -C \"csuzhangyang@gmail.com\"Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/lenovo/.ssh/id_rsa): 文件已经存在，是否重写？输入 y ，回车。 12/c/Users/lenovo/.ssh/id_rsa already exists.Overwrite (y/n)? y 然后设置密码什么的，不用管，直接两下回车。 12345Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/lenovo/.ssh/id_rsa.Your public key has been saved in /c/Users/lenovo/.ssh/id_rsa.pub.The key fingerprint is: 新秘钥保存在 /c/Users/lenovo/.ssh/id_rsa.pub 。打开这个文件，复制其中的的内容。在 github 中，打开 setting -&gt; SSH and GPG keys 。删除原来的，把新的复制进去，即解决。重新执行 hexo d。","link":"/2019/12/06/hexo%20d%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA%E8%BF%9E%E6%8E%A5Github%E7%9A%8422%E7%AB%AF%E5%8F%A3%E8%B6%85%E6%97%B6/"},{"title":"hexo博客内图片不能正常显示，但本地文件可以显示","text":"1.1 问题描述markdown文件中，插入图片的方式为 ![](文件路径) ，此时markdown文件可以正常显示图片。但是一上传到博客上，便不能正常显示。 1.2 解决办法 修改 hexo 目录下的 .config.yml 文件，将 post_asset_folder: false 修改为 post_asset_folder: true。 安装一个图片路径转换的插件。在hexo文件夹下打开 Git bush。输入 1npm install https://github.com/7ym0n/hexo-asset-image --save 注意： 这使经过修改的插件代码，网上流传的另一份代码 npm install https://github.com/CodeFalling/hexo-asset-image --save 并不能使用。 如果你之前安装了这个错误的插件，请将 /node_modules/hexo-asset-image/index.js这个文件替换成下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) {return str.split(m, i).join(m).length;}var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data){var config = hexo.config;if(config.post_asset_folder){ var link = data.permalink;if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1;else var beginPos = getPosition(link, '/', 3) + 1;// In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\".var endPos = link.lastIndexOf('/') + 1;link = link.substring(beginPos, endPos);var toprocess = ['excerpt', 'more', 'content'];for(var i = 0; i &lt; toprocess.length; i++){ var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function(){ if ($(this).attr('src')){ // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) { // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem){ return elem != ''; }); var srcArray = src.split('/').filter(function(elem){ return elem != '' &amp;&amp; elem != '.'; }); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info(\"update link as:--&gt;\"+config.root + link + src); } }else{ console.info&amp;&amp;console.info(\"no src attr, skipped...\"); console.info&amp;&amp;console.info($(this)); } }); data[key] = $.html();}}}); 安装完上述插件后，当我们创建新文章时 hexo new post &quot;new article&quot; ，就自动在 new article.md 文件的同目录下创建一个同名的文件夹，这里就是文件夹 new article 。我们把在 new article.md 使用的图片放入该文件夹中。 我们的文件目录如下所示： 123456- _post - pictures - hexo.png - new article - hexo.png - new article.md 这里我们给出两种办法来引用图片。 直接使用代码 ![](hexo.png) （虽然没有写文件夹的名字，但是可以的），hexo.png 是我们存在 new article 文件夹内的图片。这时你会发现markdown预览中无法显示这张图片，但是当你将博客上传到网站时，网站上是可以正常显示的。 使用代码 ![](new article/hexo.png)不仅可以本地预览，上传到网站也可以正常显示。 本地无法预览也是件很不舒服的事情，其实我们还可以另外创建一个文件夹 pictures ，里面专门存放所有文章的图片，代码 ![](pictures/hexo.png) 不仅可以本地预览，上传到网站也可以正常显示。 注意： 不管采取哪种办法，都要创建一个和md文件同名的文件夹，里面放上需要的图片。如果 2和3 中代码无法实现网站上的正常显示，那就使用 1 中的代码。因为 2和3 中代码我无法保证每个人都成功。","link":"/2019/12/11/hexo%E5%8D%9A%E5%AE%A2%E5%86%85%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%EF%BC%8C%E4%BD%86%E6%9C%AC%E5%9C%B0%E5%8F%AF%E4%BB%A5/"},{"title":"利用graphviz软件和pycallgraph库自动生成Python代码函数调用关系图","text":"参考 https://pycallgraph.readthedocs.io/en/master/guide/index.html 1.下载并安装graphviz 下载地址: https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi 安装（路径可任意选择） 配置环境变量，在Path中添加： 1例如我安装在F:\\Program Files (x86)，那么就添加环境变量F:\\Program Files (x86)\\Graphviz2.38\\bin 2.安装pycallgraph库 cmd窗口命令行输入：pip install pycallgraph 3.使用注意：你的程序, 只有你运行中使用了某个函数，才能显示在流图中。用户没有使用的功能则不会出现在流图中。 在代码开头调用该库，如下： 1234from pycallgraph import PyCallGraphfrom pycallgraph.output import GraphvizOutputfrom pycallgraph import Configfrom pycallgraph import GlobbingFilter 主函数操作： （最终会保存在你的.py文件相同的文件夹里，名字为graph.png） 1234567891011121314151617181920212223242526272829303132333435363738def main(): # 你的主函数代码。if __name__ == \"__main__\": config = Config() # 关系图中包括(include)哪些函数名。 #如果是某一类的函数，例如类gobang，则可以直接写'gobang.*'，表示以gobang.开头的所有函数。（利用正则表达式）。 config.trace_filter = GlobbingFilter(include=[ 'main', 'draw_chessboard', 'draw_chessman', 'draw_chessboard_with_chessman', 'choose_save', 'choose_turn', 'choose_mode', 'choose_button', 'save_chess', 'load_chess', 'play_chess', 'pop_window', 'tip', 'get_score', 'max_score', 'win', 'key_control' ]) # 该段作用是关系图中不包括(exclude)哪些函数。(正则表达式规则) # config.trace_filter = GlobbingFilter(exclude=[ # 'pycallgraph.*', # '*.secret_function', # 'FileFinder.*', # 'ModuleLockManager.*', # 'SourceFilLoader.*' # ]) graphviz = GraphvizOutput() graphviz.output_file = 'graph.png' with PyCallGraph(output=graphviz, config=config): main() 产生的图片效果如下所示：","link":"/2018/10/11/%E5%88%A9%E7%94%A8graphviz%E8%BD%AF%E4%BB%B6%E5%92%8Cpycallgraph%E5%BA%93%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Python%E4%BB%A3%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE/"},{"title":"如何保存MATLAB GUI界面中的图片","text":"代码来源自网络，作者未知，侵删。原生支持png，bmp，jpg格式。另外自行添加了清晰度比较高的eps格式（荐）。 新建一个按钮，按钮的代码如下。 其中第二行的 new_axes=copyobj(handles.axes1,new_f_handle) 的 handles.axes1 意思是保存的是axes1中的图，以此类推。 12345678910111213141516171819202122232425262728function pushbutton19_Callback(hObject, eventdata, handles)% hObject handle to pushbutton19 (see GCBO)% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)% 以下内容拷贝到按钮函数下。 new_f_handle=figure('visible','off'); %新建一个不可见的figure new_axes=copyobj(handles.axes1,new_f_handle); %axes1是GUI界面内要保存图线的Tag，将其copy到不可见的figure中 set(new_axes,'Units','normalized','Position',[0.1 0.1 0.8 0.8]);%将图线缩放 [filename pathname fileindex]=uiputfile({'*.png';'*.bmp';'*.jpg';'*.eps';},'图片保存为'); if filename~=0%未点“取消”按钮或未关闭 file=strcat(pathname,filename); switch fileindex %根据不同的选择保存为不同的类型 case 1 print(new_f_handle,'-dpng',file);% print(new_f_handle,'-dpng',filename);效果一样，将图像打印到指定文件中 fprintf('&gt;&gt;已保存到：%s\\n',file); case 2 print(new_f_handle,'-dbmp',file); fprintf('&gt;&gt;已保存到：%s\\n',file); case 3 print(new_f_handle,'-djpg',file); fprintf('&gt;&gt;已保存到：%s\\n',file); case 4 print(new_f_handle,'-depsc',file); fprintf('&gt;&gt;已保存到：%s\\n',file); end msgbox(' 图线已成功保存！','完成！'); end","link":"/2018/09/16/%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98MATLAB%20GUI%E7%95%8C%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/"},{"title":"《UNIX网络编程》第一步：编写自己的daytime客户端，并从daytime服务器获取时间","text":"1. 首先下载《UNIX网络编程》配套源代码源代码地址 2. 复制到虚拟机内(以Ubuntu系统为例),并解压。解压命令：tar zxvf unpv13e.tar.gz 以下加粗部分的代码块，均为要在终端执行的命令。 3. 在终端进入unpv13e目录。 终端执行 ./configure 如果出错，先执行命令 chmod +x configure ，再执行 ./configure 进入lib目录 cd lib ，并执行命令 make 返回上一级目录 cd .. ，并进入libfree目录 cd libfree ，再执行 make（这一步可能会有error，没关系，只要在unpv13e文件夹中生成了libunp.a文件就可以）最终会在unpv13e文件夹中生成libunp.a文件 4. 将libunp.a文件复制到/usr/lib/ 返回到unpv13e目录， cd .. 执行复制命令，sudo cp libunp.a /usr/lib 5. 修改unpv13e/lib/unp.h，并将它和unpv13e/config.h拷贝到/usr/include中 用vim编辑unp.h, vim lib/unp.h, 将#include “../config.h”*修改为#include “config.h”* 拷贝unp.h, sudo cp lib/unp.h /usr/include 拷贝configure.h, sudo cp config.h /usr/include 6.安装xinetd服务 Ubuntu系统中：执行命令， apt install xinetd Centos系统中：执行命令， yum -y install xinetd* 7. 执行daytime客户端 找到文件daytimetcpcli.c，在unpv13e/intro目录中，利用cd命令进入该目录。 编译该文件， gcc daytimetcpcli.c -lunp 会生成a.out文件，再执行 ./a.out 127.0.0.1，获取本机时间。 如果出现错误： connect error:Connection refused,表示daytime服务器程序没设置好。 Ubuntu系统的解决办法： 找到/etc/xinetd.d目录，cd /etc/xinetd.d 用vim编辑daytime文件，sudo vim daytime（要用超级用户权限才可以修改，因此要加上sudo） daytime文件中的两个disable = yes 改为 disable = no，保存退出vim。 重启xinetd服务，执行命令，service xinetd restart 此时再次执行步骤7。 Centos系统的解决办法： 找到/etc/xinetd.d目录，cd /etc/xinetd.d 将daytime-stream和daytime-dgram两个文件中的disable = yes 均改为 disable = no。用vim编辑这两个文件，sudo vim daytime-stream和sudo vim daytime-dgram（要用超级用户权限才可以修改，因此要加上sudo）。 回到主目录，cd ~。重启xinetd服务，执行命令，/etc/init.d/xinetd restart 此时再次执行步骤7。 8. 注 daytime服务器有许多种，127.0.0.1只是本机地址时间，可以更换别的服务器。 目前手头只有Ubuntu 18系统和Centos6.8系统，因此只有这两个系统的教程。 9. 结果 Ubuntu下 Centos下","link":"/2018/11/12/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/"},{"title":"记录LaTeX遇到的问题(持续更新...)","text":"用于记录使用 $\\LaTeX$ 过程中遇到的问题，有以下几大方面： 脚注 段落缩进 数学公式 图表 页面总体设计 插入代码 正文 列表 表格 参考文献 @Author：CSU张扬@Email：csuzhangyang@gmail.com or csuzhangyang@qq.com 脚注： 对于在标题(section)中加脚注，要在\\footnote前加上\\protect。例如： 1\\section{语音信号的数字水印技术（LSB算法\\protect\\footnote{即LeastSignificant Bits（最低有效位）算法。}）} 如果出现脚注计数不从1开始，可以在代码前加上命令： 1\\setcounter{footnote}{0} 去除目录中出现的脚注：中括号内放入目录（即标题）显示的内容 1\\section[语音信号的数字水印技术（LSB算法）]{语音信号的数字水印技术（LSB算法\\protect\\footnote{即LeastSignificant Bits（最低有效位）算法}）} 段落缩进 强制缩进，在开头加上以下命令：（em是当前文字的宽度） 1\\hspace*{2em} 数学公式 阴影盒子不加gather环境如何居中。前后加上$$即可。 1$$\\shadowbox{$Y(k)=\\frac{1}{2}\\left(X(k+\\omega\\pi)+X(k-\\omega\\pi)\\right)$}$$ 多行公式显示(加*表示不编号，不加则编号) 123456\\begin{equation*}\\begin{split}f&apos;(n) &amp;= f(n)+\\sum_{n=0}^{N－1}g(k)W(k)cos[\\frac {(2n + 1)k\\pi }{2N}]\\\\ &amp;= f(n)+w(n,k) \\end{split} \\end{equation*} 图表 修改图表的图1，图2，变成按章节的图1.1，图2.2等。. 改成 - 可以显示成 图1-1. 12345\\renewcommand {\\thetable} {\\thesection{}.\\arabic{table}}\\renewcommand {\\thefigure} {\\thesection{}.\\arabic{figure}}% 每一章都要手动清零\\setcounter{table}{0}\\setcounter{figure}{0} 页面总体设计 调节页边距 1234\\usepackage{geometry}%\\geometry{a4paper,left=2.54cm,right=2.54cm,top=3.18cm,bottom=3.18cm}% 中等\\geometry{a4paper,left=2.54cm,right=2.54cm,top=1.91cm,bottom=1.91cm} 页眉和页脚（加在导言区） 123456\\usepackage{fancyhdr}\\usepackage{lastpage}\\pagestyle{fancy}\\fancyhf{}\\fancyhead[C]{\\leftmark}\\fancyfoot[C]{Page \\thepage\\ of \\pageref{LastPage}} 插入代码 代码字体、大小控制 1234% 导言区\\usepackage{fontspec}\\newfontfamily\\consolas{Consolas}\\lstset{numbers=left,language=Matlab,basicstyle=\\footnotesize\\consolas,numberstyle=\\footnotesize,tabsize=2, keywordstyle= \\color{blue!70},frame=shadowbox, rulesepcolor= \\color{red!20!green!20!blue!20} } %插入代码的格式（序号位置，语言，代码字体大小、字体名称，序号字体大小，缩进，关键词颜色，阴影） 正文 局部文字 使用某种字体 12345678% 导言区\\usepackage{fontspec}\\newfontfamily\\consolas{Consolas}\\newfontfamily\\monaco{Monaco}%正文区{\\consolas def choosesave()}{\\monaco def choosesave()} 强制空行 12% 强制空行1cm\\vspace{1cm} 列表 列表带圈数字可以增加到二位数参考链接 12345678910111213141516171819202122232425262728293031323334353637383940414243\\documentclass{article}\\usepackage{enumitem}\\usepackage{tikz}\\usepackage{etoolbox}% line width可以调整圈的粗细，inner sep调节圈的大小(可以为负数)。\\newcommand{\\circled}[2][]{\\tikz[baseline=(char.base),line width = 0.7pt] {\\node[shape = circle, draw, inner sep = 1pt] (char) {\\phantom{\\ifblank{#1}{#2}{#1}}};% \\node at (char.center) {\\makebox[0pt][c]{#2}};}}\\robustify{\\circled}\\begin{document}\\newcommand{\\dcircled}[1]{\\circled[00]{#1}}\\begin{enumerate}[label=\\dcircled{\\arabic*}, noitemsep]\\item I\\item am\\item happy\\item to\\item join\\item with\\item you\\item today\\item in\\item what\\item will\\item go\\item down\\item in\\item history\\item as\\item the\\item greatest\\item demonstration\\item for\\item freedom\\item in\\item the\\item history\\item of\\item our\\item nation.\\end{enumerate}\\end{document} 列表编号加上颜色（创建一个新环境即可） 1234567\\newenvironment{colorlist}[1]{\\begin{list}{\\textcolor{blue}{\\ding{#1}}}{}}{\\end{list}}\\begin{colorlist}{42}\\item\\item\\end{colorlist} 列表变为数字或字母 1234567\\usepackage{enumerate}\\begin{enumerate}[(i)]\\item Xidian\\item Computer\\item Application\\end{enumerate}% 可以使用 A，a，I，i，1 作为可选项产生 \\Alph，\\alph，\\Roman，\\roman，\\arabic 的效果。 列表编号开始值，设置为任意数值 1234567891011121314151617181920212223242526272829\\documentclass{article}\\begin{document} % 对于数字编号 \\begin{enumerate} \\addtocounter{enumi}{41} \\item This item is numbered `42.&apos; \\end{enumerate} % 对于字母编号 \\begin{enumerate}[(a)] \\addtocounter{enumi}{5}% This cannot be more than 25 \\item This one is ``numbered&apos;&apos; `(f)&apos; \\end{enumerate}\\end{document}% （如果您有更深层次的嵌套列表，相关的计数器是enumii，enumiii和enumiv。）% 双层嵌套\\documentclass{article}\\begin{document} % 对于数字编号 \\begin{enumerate} \\addtocounter{enumi}{41} \\item This item is numbered `42.&apos; % 对于字母编号 \\begin{enumerate}[(a)] \\addtocounter{enumii}{5}% This cannot be more than 25 \\item This one is ``numbered&apos;&apos; `(f)&apos; \\end{enumerate} \\end{enumerate}\\end{document} 列表之间的行距缩小：导言区加入如下命令 1234\\usepackage{enumitem}\\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\\parskip,topsep=5pt}\\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\\parskip,topsep=5pt}\\setdescription{itemsep=0pt,partopsep=0pt,parsep=\\parskip,topsep=5pt} 表格 表格不同的列使用不同的字体 1234\\begin{tabular}{&gt;{\\heiti}r &gt;{\\kaishu}l}黑体 &amp; 楷体还是黑体 &amp; 还是楷体\\end{tabular} 表格不同的列使用不同的字号 1234\\begin{tabular}{&gt;{\\small}r &gt;{\\Huge}l}小 &amp; 大小小 &amp; 大大\\end{tabular} 表格设置文字两端对齐 1234567\\begin{tabular}{&gt;{\\heiti}r &gt;{\\kaishu}l}% 两端对齐，用4em是因为有最多四个字，根据实际情况修改该值。 \\makebox[4em][s]{课\\hspace{\\fill}程}：&amp; 微机原理与接口技术\\\\ \\makebox[4em][s]{学生姓名}： &amp; 神奇海螺\\\\ \\makebox[4em][s]{三\\hspace{\\fill}个\\hspace{\\fill}字}： &amp; 杨老师\\\\ \\makebox[4em][s]{学\\hspace{\\fill}院}：&amp; 信息科学与工程学院\\\\ \\end{tabular} 跨页表格（使用longtable环境） 123456789101112131415161718192021\\usepackage{longtable}\\newcommand\\meta[1]{\\emph{$\\langle$#1$\\rangle$}}\\begin{longtable}{|l|l|}\\hline\\endfirsthead\\multicolumn{2}{l}{（续表）}\\\\\\hline\\endhead\\multicolumn{2}{c}{\\itshape 接下一页表格......}\\\\[2ex]\\endfoot\\hline\\endlastfoot% 下面是你的表格内容% =================================================== %\\hlineD0～D7 &amp; 双向数据总线，以便和 CPU 之间传递命令、数据和状态。\\\\\\hlineCLK &amp; 时钟输入线，以产生内部时钟 \\\\\\hline% ==================================================== %\\end{longtable} 表格内的内容添加脚注 在tabular环境中添加脚注，不能简单地使用\\footnote{……}。应该在要添加脚注的地方使用\\footnotemark[n]标记，其中n表示脚注的编号；在tabular或table环境外则用\\footnotetext[n]{……}填入脚注内容，注意这里的[n]应该与表格中的\\footnotemark中的[n]一一对应。 123456789101112131415\\begin{table}[htbp]\\centering\\begin{tabular}{ll} \\toprule % after \\\\: \\hline or \\cline{col1-col2} \\cline{col3-col4} ... $D_4 D_3$ &amp; 功能 \\\\ \\midrule 00 &amp; 8字符显示，左端输入\\footnotemark[1] \\\\ 01 &amp; 16字符显示，左端输入 \\\\ 10 &amp; 8字符显示，左端输入 \\\\ 11 &amp; 16字符显示，右端输入 \\\\ \\bottomrule\\end{tabular}\\end{table}\\footnotetext[1]{RESET后，设定该种方式} 表格中添加列表环境(1) 缺点：表格中每一个格子内，必须有列表的序号（·或者123…）。 12345678910111213141516171819202122232425262728293031323334353637383940414243\\documentclass{article}\\usepackage{array}\\makeatletter\\newcolumntype{e}[1]{%--- Enumerated cells --- &gt;{\\minipage[t]{\\linewidth}% \\NoHyper% Hyperref adds a vertical space \\let\\\\\\tabularnewline \\enumerate \\addtolength{\\rightskip}{0pt plus 50pt}% for raggedright \\setlength{\\itemsep}{-\\parsep}}% p{#1}% &lt;{\\@finalstrut\\@arstrutbox\\endenumerate \\endNoHyper \\endminipage}}\\newcolumntype{i}[1]{%--- Itemized cells --- &gt;{\\minipage[t]{\\linewidth}% \\let\\\\\\tabularnewline \\itemize \\addtolength{\\rightskip}{0pt plus 50pt}% \\setlength{\\itemsep}{-\\parsep}}% p{#1}% &lt;{\\@finalstrut\\@arstrutbox\\enditemize\\endminipage}}\\AtBeginDocument{% \\@ifpackageloaded{hyperref}{}% {\\let\\NoHyper\\relax\\let\\endNoHyper\\relax}}\\makeatother\\begin{document}\\begin{tabular}[t]{|i{2.5cm}|e{3cm}|}\\hline \\item Item A \\item Item B &amp; \\item Item 1 \\item Item 2 \\\\\\hline \\item Item C &amp; \\item Item 3 \\item Item 4 \\\\\\hline\\end{tabular}\\end{document} 表格中添加列表环境(2) 特点：克服了(1)的缺点，但是每一个列表之间距离很大。 123456789101112131415161718192021222324252627282930\\begin{table} \\centering \\begin{tabular}{|p{2cm}|p{6cm}|p{6cm}|} \\hline 结构 &amp; 背景 &amp; 重点/贡献\\\\ \\hline 三层结构 &amp; \\begin{itemize} \\item 雾计算基本结构 \\end{itemize} &amp; \\begin{itemize} \\item 将计算和存储设施扩展到网络边缘并减轻云数据中心的负担。 \\end{itemize} \\\\ \\hline 基于SDN的雾计算 &amp; \\begin{itemize} \\item 数据和控制平面的分离。 \\item 在边缘元素中集成控制器功能，即边缘切换。 \\item 与雾和云管理软件进行通信。 \\end{itemize} &amp; \\begin{itemize} \\item 改进控制器开关延迟性能。 \\item 有效地管理边缘切换的搜索，编译和网络资源。 \\item 处理与雾相关的流量，旨在减少延迟和碳足迹。 \\end{itemize} \\\\\\hline\\end{tabular} \\caption{三层结构和 SDN 结构的区别}\\end{table} 参考文献 添加参考文献到目录中，加入第二行的代码，编译两次 123456\\begin{thebibliography}{99}\\addcontentsline{toc}{section}{参考文献} % 加入这一行，编译两次\\bibitem{1} 梁建武,杨迎泽. 微机原理与接口技术. 北京: 中国铁道出版社. 2016, 02.\\bibitem{2} 王爽. 汇编语言(第三版). 北京:清华大学出版社. 2014, 04.\\bibitem{3} Star ES8086使用说明.\\end{thebibliography}","link":"/2019/01/21/%E8%AE%B0%E5%BD%95LaTeX%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...)/"}],"tags":[{"name":"string","slug":"string","link":"/tags/string/"},{"name":"dynamic-programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"backtracking","slug":"backtracking","link":"/tags/backtracking/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"hash-table","slug":"hash-table","link":"/tags/hash-table/"},{"name":"two-pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"linked-list","slug":"linked-list","link":"/tags/linked-list/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"divide-and-conquer","slug":"divide-and-conquer","link":"/tags/divide-and-conquer/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"sliding-window","slug":"sliding-window","link":"/tags/sliding-window/"},{"name":"binary-search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"graphviz","slug":"graphviz","link":"/tags/graphviz/"},{"name":"pycallgraph","slug":"pycallgraph","link":"/tags/pycallgraph/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"UNIX网络编程","slug":"UNIX网络编程","link":"/tags/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"}],"categories":[{"name":"LeetCode(C++)","slug":"LeetCode-C","link":"/categories/LeetCode-C/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"MATLAB","slug":"MATLAB","link":"/categories/MATLAB/"},{"name":"UNIX","slug":"UNIX","link":"/categories/UNIX/"},{"name":"LaTeX","slug":"LaTeX","link":"/categories/LaTeX/"},{"name":"UNIX网络编程","slug":"UNIX/UNIX网络编程","link":"/categories/UNIX/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}