<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2.4 const限定符</title>
    <url>/2020/01/05/CPP-Primer/Notes/2.4const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
    <content><![CDATA[<ul>
<li><a href="#2-4-1-const的引用-reference-to-const">2.4.1 const的引用(reference to const)</a><ul>
<li><a href="#【1】初始化和对const的引用">【1】初始化和对const的引用</a></li>
</ul>
</li>
<li><a href="#2-4-2-指针和const">2.4.2 指针和const</a><ul>
<li><a href="#【1】指向常量的指针-pointer-to-const">【1】指向常量的指针(pointer to const)</a></li>
<li><a href="#【3】const指针-const-pointer">【2】const指针(const pointer)</a></li>
</ul>
</li>
<li><a href="#2-4-3-顶层const">2.4.3 顶层const</a><ul>
<li><a href="#【1】顶层底层const的区别">【1】顶层/底层const的区别</a></li>
</ul>
</li>
<li><a href="#2-4-4-constexpr和常量表达式">2.4.4 constexpr和常量表达式</a><ul>
<li><a href="#【1】constexpr变量">【1】constexpr变量</a></li>
<li><a href="#【2】字面值类型">【2】字面值类型</a></li>
<li><a href="#【3】指针和constexpr">【3】指针和constexpr</a></li>
</ul>
</li>
<li><a href="#关于引用的一些补充知识">关于引用的一些补充知识</a><ul>
<li><a href="#【1】对常量的引用和普通引用的相同点-不同点">【1】对常量的引用和普通引用的相同点/不同点</a></li>
<li><a href="#【2】有没有-int-amp-const-r-i">【2】有没有 int &amp;const r = i</a></li>
</ul>
</li>
</ul>
<ol>
<li><code>const</code> 对象创建后，值不能被改变。</li>
<li><code>const</code> 对象必须被初始化。</li>
</ol>
<p><strong>这两条对以下所述的 <code>const</code> 类型都适合。</strong></p>
<h3 id="const对象仅在文件内有效"><a href="#const对象仅在文件内有效" class="headerlink" title="const对象仅在文件内有效"></a>const对象仅在文件内有效</h3><ol>
<li>如果在多个文件中出现了同名的 <code>const</code> 变量时，相当于在不同文件里分别定义了一个独立的变量。</li>
<li>若我们希望在文件之间共享，只在一个文件里定义它，其他文件里声明它（<code>extern</code>）。</li>
</ol>
<h2 id="2-4-1-const的引用-reference-to-const"><a href="#2-4-1-const的引用-reference-to-const" class="headerlink" title="2.4.1 const的引用(reference to const)"></a>2.4.1 const的引用(reference to const)</h2><p>即：对常量的引用</p>
<h3 id="【1】初始化和对const的引用"><a href="#【1】初始化和对const的引用" class="headerlink" title="【1】初始化和对const的引用"></a>【1】初始化和对const的引用</h3><ol>
<li><p>引用类型必须和引用的对象类型不需要一致，只要能够转化成引用的类型即可。因此，常量引用可以绑定 常量/非常量对象、字面值、表达式。</p>
</li>
<li><p>非常量引用不能绑定一个常量对象。</p>
</li>
<li><p>对常量的引用 不能被用作 修改所指的对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">1</span>;  <span class="comment">// 错误，r是常量引用</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h2><h3 id="【1】指向常量的指针-pointer-to-const"><a href="#【1】指向常量的指针-pointer-to-const" class="headerlink" title="【1】指向常量的指针(pointer to const)"></a>【1】指向常量的指针(pointer to const)</h3><p>性质和对 <code>const</code> 的引用几乎类似。</p>
<ol>
<li>指针类型必须和所指对象的类型一致。</li>
<li>指向常量的指针可以绑定 常量/非常量对象。</li>
<li>普通指针不能绑定一个常量对象。</li>
<li>指向常量的指针 不能通过该指针 修改所指的对象的值。</li>
</ol>
<p>唯一的不同就是第2条：对常量的引用可以绑定字面值、表达式。指向常量的指针不能。</p>
<p><strong>注意：</strong><br>我们不能通过 <code>*p</code> 来修改所指对象的值，但是我们可以修改 <code>p</code> 的值，此时 <code>p</code> 指向另一个对象。也就是说 <code>*p</code> 是一个不可修改的左值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x61fe3c 1</span></span><br><span class="line"><span class="keyword">int</span> *q = &amp;j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q &lt;&lt; <span class="string">" "</span> &lt;&lt; *q &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x61fe38 2</span></span><br><span class="line">p = q;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x61fe38 2</span></span><br><span class="line">*p = <span class="number">3</span>;  <span class="comment">// 错误，*p是一个不可修改的左值</span></span><br></pre></td></tr></table></figure>

<h3 id="【2】const指针-const-pointer"><a href="#【2】const指针-const-pointer" class="headerlink" title="【2】const指针(const pointer)"></a>【2】const指针(const pointer)</h3><p>把 <code>*</code> 放在 <code>const</code> 前说明指针是个常量，即指针本身的值不变，而非指向的值不变。<br>我们可以通过 <code>*p</code> 来改变指向的对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</span><br><span class="line">p = j;  <span class="comment">// 错误，p的值不能改变，p中存放着i的地址</span></span><br><span class="line">*p = <span class="number">10</span>;  <span class="comment">// 正确，i的值变为10</span></span><br></pre></td></tr></table></figure>

<p>性质和指向常量的指针相同。</p>
<h2 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h2><p>顶层const(top-level const)：指针本身是个常量。<br>底层const(low-level const)：指针所指的对象是个常量。</p>
<h3 id="【1】顶层-底层const的区别"><a href="#【1】顶层-底层const的区别" class="headerlink" title="【1】顶层/底层const的区别"></a>【1】顶层/底层const的区别</h3><ol>
<li>顶层const适用于算术类型、类、指针。</li>
<li>底层const适用于指针和引用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = i;  <span class="comment">// 顶层，j是int型的对象</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> q = &amp;i;  <span class="comment">// 顶层，表示指针本身是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;  <span class="comment">// 底层，表示指针所指对象是个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;  <span class="comment">// 底层，引用类型都是底层const</span></span><br></pre></td></tr></table></figure>

<p>顶层/底层 <code>const</code> 赋值规则，书上说的太过复杂，其实就是前面几节 const的引用，指向常量的指针，常量指针一些性质。</p>
<h2 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h2><p>常量表达式(const expression)：值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式。</p>
<p>一个对象或者表达式是不是常量表达式由数据类型和初始值共同决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>; <span class="comment">// no, 因为不是const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = get_size();  <span class="comment">//no, 我们到运行get_size()时才能确定d的值</span></span><br></pre></td></tr></table></figure>

<h3 id="【1】constexpr变量"><a href="#【1】constexpr变量" class="headerlink" title="【1】constexpr变量"></a>【1】constexpr变量</h3><!-- TODO: C++11: constexpr -->
<p>我们很难区分一个变量到底是不是常量表达式，或者我们变量的初始值根本不是常量表达式。于是，<strong>C++11</strong> 允许将变量声明为 <code>constexpr</code> 由编译器验证变量是否是常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = size();  <span class="comment">// 当size()是constexpr函数时正确。</span></span><br></pre></td></tr></table></figure>

<h3 id="【2】字面值类型"><a href="#【2】字面值类型" class="headerlink" title="【2】字面值类型"></a>【2】字面值类型</h3><p>算术类型、指针和引用都属于字面值类型，自定义类、IO库、string类都不属于。</p>
<p>指针能定义为 <code>constexpr</code>，但初始值必须为 <code>nullptr</code> 或 <code>0</code>，或者是某个固定地址的对象。函数体内的变量一般并非存在固定地址中，所以 <code>constexpr</code> 指针不能指向这样的对象，函数体之外的可以。当然函数体内的静态变量也可以。</p>
<h3 id="【3】指针和constexpr"><a href="#【3】指针和constexpr" class="headerlink" title="【3】指针和constexpr"></a>【3】指针和constexpr</h3><p><code>constexpr</code> 只对指针本身有效，与其所指对象无关。<br>例如：<code>constexpr int *q = nullptr</code>，q是一个常量指针。</p>
<p><code>constexpr</code> 指针既可以指向常量也可指向非常量。</p>
<!-- TODO: VS: 对常量的引用 VS 普通引用 -->
<h2 id="关于引用的一些补充知识"><a href="#关于引用的一些补充知识" class="headerlink" title="关于引用的一些补充知识"></a>关于引用的一些补充知识</h2><h3 id="【1】对常量的引用和普通引用的相同点-不同点"><a href="#【1】对常量的引用和普通引用的相同点-不同点" class="headerlink" title="【1】对常量的引用和普通引用的相同点/不同点"></a>【1】对常量的引用和普通引用的相同点/不同点</h3><p><strong>相同点</strong>：</p>
<ol>
<li>必须初始化。</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li>对常量的引用不能被修改它的值。</li>
<li>普通引用必须绑定到<strong>类型相同</strong>的对象上，对常量的引用可以绑定 常量/非常量对象、字面值、表达式，只要能够转化成对应的类型即可。</li>
</ol>
<h3 id="【2】有没有-int-amp-const-r-i"><a href="#【2】有没有-int-amp-const-r-i" class="headerlink" title="【2】有没有 int &amp;const r = i"></a>【2】有没有 <code>int &amp;const r = i</code></h3><p>指针有两种行为的 <code>const</code> ，引用有没有呢？  </p>
<p>首先，我们明确一些概念。</p>
<ol>
<li><code>const int i = 0; const int &amp;r1 = i;</code>，像这样，我们把引用绑定到 <code>const</code> 对象上，这叫<strong>对常量的引用</strong>。当然我们也能绑定到非常量对象上，这个暂时不考虑。</li>
<li><code>const int i = 0; int &amp;const r2 = i;</code>，这种情况的 <code>const</code> 限定的是我们不能更改 <code>r2</code> 的绑定对象。</li>
</ol>
<p>我们学习引用时就知道，<strong>不允许改变引用所绑定的对象</strong>。这其实就说明：引用本身就是 <code>const</code> 的。所以 <code>int &amp;const r2 = i;</code> 这条语句本质上就是 <code>int &amp;r2 = i;</code> ，是冗余的，所以C++没有这种语法。</p>
<blockquote>
<p><a href="https://www.embedded.com/references-and-const/" target="_blank" rel="noopener">References and const</a><br><a href="https://www.quora.com/What-are-the-differences-between-int-const-int-const-const-int-and-const-int-in-C" target="_blank" rel="noopener">Quora</a><br><a href="https://blog.csdn.net/xiaoyi39/article/details/51273795" target="_blank" rel="noopener">C++中的引用与const</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>2.3 复合类型</title>
    <url>/2020/01/04/CPP-Primer/Notes/2.3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li><a href="#2-3-复合类型">2.3 复合类型</a><ul>
<li><a href="#2-3-1-引用-reference">2.3.1 引用(reference)</a></li>
<li><a href="#2-3-2-指针-pointer">2.3.2 指针(pointer)</a><ul>
<li><a href="#【1】空指针">【1】空指针</a></li>
<li><a href="#【2】指针操作">【2】指针操作</a></li>
<li><a href="#【3】void-指针">【3】void* 指针</a></li>
</ul>
</li>
<li><a href="#2-3-复合类型的声明">2.3 复合类型的声明</a><ul>
<li><a href="#【1】定义多个变量">【1】定义多个变量</a></li>
<li><a href="#【2】指向指针的指针">【2】指向指针的指针</a></li>
<li><a href="#【3】指向指针的引用">【3】指向指针的引用</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-1-引用-reference"><a href="#2-3-1-引用-reference" class="headerlink" title="2.3.1 引用(reference)"></a>2.3.1 引用(reference)</h2><p><em>引用</em>为<em>对象</em>起了另外一个名字，引用类型 引用 另外一种类型。<br>形式为：<code>int &amp;refVal = ival;</code> ，<code>refVal</code> 是 <code>ival</code> 的引用。</p>
<p>引用必须遵守一下三个规定：</p>
<ol>
<li>引用必须被初始化</li>
<li>引用的初始值必须是一个对象</li>
<li>引用类型和所绑定对象的类型必须相同。</li>
</ol>
<p>引用和它的初始值对象将一直绑定到一起，无法绑定到另一个对象上。<br>引用并非<strong>对象</strong>，它只是为一个对象起了另一个名字。就像每个人都有学名和乳名。<br>所以我们对引用进行一系列操作的同时，也会对<em>与之绑定的对象</em>进行相同的操作。<br>由 引用并非<strong>对象</strong>，可知不存在 <strong>对引用的引用</strong>。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br><span class="line">refVal = <span class="number">2</span>;  <span class="comment">// 此时ival也变为了2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-2-指针-pointer"><a href="#2-3-2-指针-pointer" class="headerlink" title="2.3.2 指针(pointer)"></a>2.3.2 指针(pointer)</h2><p>指针和引用的两个不同点：</p>
<ol>
<li>指针是个对象。</li>
<li>指针无须在定义时赋值。</li>
</ol>
<p>指针的类型要和它所指的对象的类型严格匹配。</p>
<!-- TODO:指针类型匹配的两种例外：P47 -->

<h3 id="【1】空指针"><a href="#【1】空指针" class="headerlink" title="【1】空指针"></a>【1】空指针</h3><p>生成空指针的三种办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<!-- TODO: C++11: nullptr -->
<!-- TODO: 类型转换P143下 -->
<p><code>nullptr</code> 是指针字面值 (<strong>C++11</strong>)，它可以转换成任意其他指针类型。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>尽量使用 <code>nullptr</code></li>
<li><code>int</code> 变量不能赋给指针，即使该变量为0。<br>例如：<code>int i = 0; int *pi = i;</code> , 这是错误的。</li>
<li>建议初始化所有指针，暂不知道初始化对象是谁，可以先初始化为 <code>nullptr</code>。</li>
</ol>
<h3 id="【2】指针操作"><a href="#【2】指针操作" class="headerlink" title="【2】指针操作"></a>【2】指针操作</h3><ol>
<li><p>赋值永远改变的是等号左侧的对象。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;i1;  <span class="comment">// p1暂时指向i1</span></span><br><span class="line">p1 = &amp;i2;  <span class="comment">// 改变了p1的值，i2没有变，p1指向i2。</span></span><br><span class="line">*p1 = <span class="number">10</span>;  <span class="comment">// 改变了i2的值变为10，p1没有变。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>任何非 <code>nullptr, 0, NULL</code> 的指针的条件值都为 <code>true</code>。</p>
</li>
<li><p><strong>类型相同</strong> 的合法指针可以进行条件比较。</p>
<!-- TODO: 更多指针操作 P105-->

</li>
</ol>
<h3 id="【3】void-指针"><a href="#【3】void-指针" class="headerlink" title="【3】void* 指针"></a>【3】void* 指针</h3><p><code>void*</code> 指针可以存放任意类型对象的地址。但是我们不能直接操作 <code>void*</code> 指针所指的对象，因为我们不知道它到底是什么类型。</p>
<h2 id="2-3-复合类型的声明"><a href="#2-3-复合类型的声明" class="headerlink" title="2.3 复合类型的声明"></a>2.3 复合类型的声明</h2><h3 id="【1】定义多个变量"><a href="#【1】定义多个变量" class="headerlink" title="【1】定义多个变量"></a>【1】定义多个变量</h3><p><code>int* p1, p2</code> : p1是指针类型，p2是int</p>
<h3 id="【2】指向指针的指针"><a href="#【2】指向指针的指针" class="headerlink" title="【2】指向指针的指针"></a>【2】指向指针的指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;ival;  <span class="comment">// p1指向 int型的整数</span></span><br><span class="line"><span class="keyword">int</span> **P2 = &amp;p1;  <span class="comment">// p2指向 int型的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="【3】指向指针的引用"><a href="#【3】指向指针的引用" class="headerlink" title="【3】指向指针的引用"></a>【3】指向指针的引用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;  <span class="comment">// r是指针p的引用，r是p的别名</span></span><br><span class="line">r = &amp;i;  <span class="comment">// 令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;  <span class="comment">// 令i=0</span></span><br></pre></td></tr></table></figure>

<p>如何理解 <code>int *&amp;r</code> 中 <code>r</code> 是什么类型？  </p>
<ol>
<li>首先看离 <code>r</code> 最近的声明符，即 <code>&amp;r</code>， 说明 <code>r</code> 是一个引用类型。</li>
<li><code>r</code> 引用的什么类型，看剩余的。即 <code>int *</code>，说明 <code>r</code> 引用的是个<code>int</code> 型指针。</li>
</ol>
]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>2.2 变量(variable)</title>
    <url>/2020/01/03/CPP-Primer/Notes/2.2%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<ul>
<li><a href="#2-2-1-变量定义">2.2.1 变量定义</a><ul>
<li><a href="#【1】初始值">【1】初始值</a></li>
<li><a href="#【2】列表初始化">【2】列表初始化</a></li>
<li><a href="#【3】默认初始化">【3】默认初始化</a></li>
</ul>
</li>
<li><a href="#2-2-2-变量声明和定义的关系">2.2.2 变量声明和定义的关系</a></li>
<li><a href="#2-2-4-名字的作用域">2.2.4 名字的作用域</a><ul>
<li><a href="#【1】嵌套的作用域">【1】嵌套的作用域</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
<h2 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h2><h3 id="【1】初始值"><a href="#【1】初始值" class="headerlink" title="【1】初始值"></a>【1】初始值</h3><p>对象被创建时获得了一个特定的值，就称该对象被<strong>初始化</strong>了。</p>
<p>我们经常用 <code>=</code> 进行初始化，注意，初始化并不是赋值。<br>初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，用一个新值代替。</p>
<h3 id="【2】列表初始化"><a href="#【2】列表初始化" class="headerlink" title="【2】列表初始化"></a>【2】列表初始化</h3><p>4种初始化形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; # <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;; # <span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;; # <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>; # <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>用花括号初始化变量称为 <strong>列表初始化(list initialization)</strong> *[C++11]<em>。<br>其中 <code>#2</code> 称为 *</em>复制列表初始化** ， <code>#4</code> 称为 <strong>直接列表初始化</strong> 。</p>
<p><strong>注意</strong> ：<em>列表初始化存在丢失信息的风险</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;pi&#125;;     <span class="comment">// 错误，存在丢失信息的危险</span></span><br><span class="line"><span class="keyword">int</span> b = &#123;pi&#125;;  <span class="comment">// 错误，存在丢失信息的危险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(pi)</span></span>;     <span class="comment">// 正确，丢失了小数位的值。</span></span><br><span class="line"><span class="keyword">int</span> d = pi;    <span class="comment">// 错误，存在丢失信息的危险</span></span><br></pre></td></tr></table></figure>

<h3 id="【3】默认初始化"><a href="#【3】默认初始化" class="headerlink" title="【3】默认初始化"></a>【3】默认初始化</h3><ol>
<li>若为 <a href="https://www.faker.top/2019/12/30/CPP-Primer/Notes/2.1基本内置类型/" target="_blank" rel="noopener"><strong>内置类型</strong></a> 且没有被显示初始化，它的值由它的位置决定。<ol>
<li>定义于任何函数体之外的变量被初始化为0。(<strong>注意</strong>：<code>main</code> 也是个函数。)</li>
<li>任何函数体之内的将 <strong>不被初始化</strong> ，其变量的值时 <strong>未定义的</strong>。</li>
</ol>
</li>
<li>若为 <strong>类类型</strong> ，每个类都有自己初始化对象的方式。若类的对象没有被显式初始化，其值由类决定。例如 <code>string</code> 类会被默认初始化为空串。</li>
</ol>
<h2 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h2><ol>
<li><p><strong>变量声明</strong> 规定了变量的类型和名字，<strong>定义</strong> 也是。除此之外，<strong>定义</strong> 还申请存储空间，也可能会为变量赋一个初始值。</p>
</li>
<li><p><strong>声明而不定义</strong> 一个变量：在最前面加一个 <code>extern</code> 关键字，且不要显式初始化。</p>
</li>
<li><p>任何包含显式初始化的声明就成为 <strong>定义</strong>。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">// 声明i而不是定义i</span></span><br><span class="line"><span class="keyword">int</span> j;  <span class="comment">// 定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;  <span class="comment">// 定义pi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量只能 <strong>定义一次</strong>，但可以 <strong>多次声明</strong>。</p>
</li>
<li><p>若在多个文件里使用同一个变量，变量的定义只能出现在一个文件里，其他文件要使用该变量，必须对其声明，不能重复定义。</p>
</li>
</ol>
<h2 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h2><p>C++语言大部分作用域使用大括号 <code>{}</code> 分离，一个 <code>{}</code> 表示一个作用域。</p>
<p>简单地名词：<strong>全局作用域</strong> ， <strong>块作用域</strong> 。</p>
<h3 id="【1】嵌套的作用域"><a href="#【1】嵌套的作用域" class="headerlink" title="【1】嵌套的作用域"></a>【1】嵌套的作用域</h3><ol>
<li>允许在内层作用域，重新定义外层作用域已有的名字。在内层作用域里使用新定义的变量的值，出了内层作用域，使用外层作用域该变量的值。</li>
<li>可以使用作用域操作符 <code>::</code> 覆盖默认的作用域。<br><code>::a</code> 访问的是全局作用域的 <code>a</code> ，因为全局作用域没有名字，所以 <code>::</code> 左侧为空时，就代表全局作用域。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">// a有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面的&#123;&#125;是一个块作用域。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 10</span></span><br><span class="line">        a ++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 11</span></span><br><span class="line">        <span class="comment">// 使用作用域操作符显式访问全局变量a</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 0</span></span><br><span class="line">    &#125; <span class="comment">// 内层作用域结束，其中的局部变量a被销毁。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 0，此时回到了全局变量的作用域。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 若变量是全局变量，不要在局部作用域里，定义一个同名的变量。</p>
]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客新建菜单，并在该菜单内添加单篇/多篇文章</title>
    <url>/2020/01/01/Hexo/h3-hexo%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ul>
<li><a href="#1-如何添加新的菜单">1 如何添加新的菜单</a></li>
<li><a href="#2-更改菜单名">2 更改菜单名</a><ul>
<li><a href="#2-1-更改左侧菜单名-schedule">2.1 更改左侧菜单名 schedule</a></li>
<li><a href="#2-1-更改-schedule-页面内上方的文字">2.1 更改 schedule 页面内上方的文字</a></li>
</ul>
</li>
<li><a href="#3-使菜单-schedule-里面只包含一篇文章">3 使菜单 schedule 里面只包含一篇文章。</a></li>
<li><a href="#4-使菜单-schedule-里面包含多篇文章">4 使菜单 schedule 里面包含多篇文章。</a></li>
</ul>
<a id="more"></a>

<h2 id="1-如何添加新的菜单"><a href="#1-如何添加新的菜单" class="headerlink" title="1 如何添加新的菜单"></a>1 如何添加新的菜单</h2><p>执行命令：<code>hexo new page schedule</code>, 这里的菜单名就是 <code>schedule</code>。</p>
<p>这时候我们就会发现，网站上多了一个菜单。但是点击这个菜单，页面里只有 <strong>schedule</strong> 这几个大字。</p>
<h2 id="2-更改菜单名"><a href="#2-更改菜单名" class="headerlink" title="2 更改菜单名"></a>2 更改菜单名</h2><h3 id="2-1-更改左侧菜单名-schedule"><a href="#2-1-更改左侧菜单名-schedule" class="headerlink" title="2.1 更改左侧菜单名 schedule"></a>2.1 更改左侧菜单名 schedule</h3><ol>
<li>打开 <code>hexo/_config.yml</code> 文件，找到 <code>language:</code>，这行代码。例如我的语言是 <code>language: zh-CN</code> 。</li>
<li>打开文件 <code>hexo/themes/next/language</code>（next是我的主题，打开你当前主题里的 <code>language</code> 文件夹）。那么我就打开 <code>language/zh-CN.yml</code>，与你的语言对应的文件。</li>
<li>在 <code>Menu:</code> 下方添加一行 <code>schedule: 札记</code>，就修改成 <strong>札记</strong> 了。</li>
</ol>
<h3 id="2-1-更改-schedule-页面内上方的文字"><a href="#2-1-更改-schedule-页面内上方的文字" class="headerlink" title="2.1 更改 schedule 页面内上方的文字"></a>2.1 更改 schedule 页面内上方的文字</h3><ol>
<li>打开 <code>hexo/source/schedule/index.md</code> ，修改成 <code>title: 札记</code>，写成你想要的名字即可。</li>
</ol>
<h2 id="3-使菜单-schedule-里面只包含一篇文章"><a href="#3-使菜单-schedule-里面只包含一篇文章" class="headerlink" title="3 使菜单 schedule 里面只包含一篇文章"></a>3 使菜单 schedule 里面只包含一篇文章</h2><p>具体效果就是，我们点击这个 <code>schedule</code> 就相当于打开了一篇文章，适合用来写日记。</p>
<p><img src="/2020/01/01/Hexo/h3-hexo%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0/hexo-3_1.png" alt="1"></p>
<ol>
<li><p>打开 <code>hexo/source/schedule</code> 文件夹，里面只有一个 <code>index.md</code> 文件。我们在这个文件夹里新建文件 <code>notes.md</code> 。该文件，就是你想要展示的那篇文章。</p>
</li>
<li><p>打开 <code>hexo/themes/next/_config.yml</code> 文件，找到 <code>menu:</code>，添加一行 <code>schedule: /schedule/notes.html || calendar</code> 即可。<code>||</code> 前面的是文章的路径，后面是菜单的图标。图标可以更改，请百度 <code>Font Awesome</code> 。</p>
</li>
<li><p><code>notes.md</code> 开头的格式和以前一样，只是没有 <code>categories</code> 和 <code>tags</code> 选项。例如：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 札记</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">51</span></span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-使菜单-schedule-里面包含多篇文章"><a href="#4-使菜单-schedule-里面包含多篇文章" class="headerlink" title="4 使菜单 schedule 里面包含多篇文章"></a>4 使菜单 schedule 里面包含多篇文章</h2><p>这里用到的办法借用了 <code>categories</code> 的分类功能，其实就是将某个分类移到了左侧菜单上。</p>
<ol>
<li>我们在 <code>_post</code> 目录下有几篇文章想放到该菜单下，我们给这些文章分类为 <code>categories: -schedule</code> 。</li>
<li>打开 <code>hexo/themes/next/_config.yml</code> 文件，找到 <code>menu:</code>，添加一行 <code>schedule: //categories/schedule/ || calendar</code> 即可。</li>
<li>这时我们点击，该菜单，就会发现里面可以显示这几篇文章。但是点开目录菜单，发现多了一个分类 <code>schedule</code>，因为实际上这俩是一样的。</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-icarus主题下, 文章内部的目录问题</title>
    <url>/2019/12/31/Hexo/h4-hexo-icarus%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%96%87%E7%AB%A0%E7%9A%84%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>首先icarus主题，本身就支持目录功能，只要在md文件首部加上 <code>toc: true</code> ，就可以在文章左侧生成目录，且可以正常跳转。</li>
<li>在我们浏览网站首页时，每一个文章只会显示一部分的内容，并且有一个 <strong>read more</strong> 按钮，供我们阅读全文。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>2.1 基本内置类型</title>
    <url>/2019/12/30/CPP-Primer/Notes/2.1%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li><a href="#2-1-1-算术类型-arithmetic-type">2.1.1 算术类型(arithmetic type)</a><ul>
<li><a href="#【1】算术类型的分类">【1】算术类型的分类</a></li>
<li><a href="#【2】算术类型的尺寸">【2】算术类型的尺寸</a></li>
<li><a href="#【3】带无符号类型">【3】带/无符号类型</a></li>
<li><a href="#【4】如何选择类型">【4】如何选择类型</a></li>
</ul>
</li>
<li><a href="#2-1-2-类型转换">2.1.2 类型转换</a><ul>
<li><a href="#【1】六种类型转换的情况">【1】六种类型转换的情况</a></li>
<li><a href="#【2】含有无符号类型的表达式">【2】含有无符号类型的表达式</a></li>
</ul>
</li>
<li><a href="#2-1-3-字面值常量-literal">2.1.3 字面值常量(literal)</a><ul>
<li><a href="#【1】整型浮点型字符字符串布尔指针字面值">【1】整型、浮点型、字符、字符串、布尔、指针字面值</a></li>
<li><a href="#【2】转义序列">【2】转义序列</a></li>
<li><a href="#【3】指定字面值的类型">【3】指定字面值的类型</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="2-1-1-算术类型-arithmetic-type"><a href="#2-1-1-算术类型-arithmetic-type" class="headerlink" title="2-1-1 算术类型(arithmetic type)"></a>2-1-1 算术类型(arithmetic type)</h2><p>基本内置类型包括 <strong>算术类型</strong> 和 <strong>空类型</strong> 。</p>
<h3 id="【1】算术类型的分类"><a href="#【1】算术类型的分类" class="headerlink" title="【1】算术类型的分类"></a>【1】算术类型的分类</h3>
$$
\text{内置类型} \begin{cases}
    \text{算术类型} \begin{cases}
    \text{整型} \begin{cases}
    \text{布尔值}: bool\\
    \text{字符型}: char,\ wchar\_t,\ char16\_t,\ char32\_t\\
    \text{整型数}: short,\ int,\ long,\ long\ long\\
\end{cases}\\
    \text{浮点型}: float,\ double,\ long\ double\\
\end{cases}\\
    \text{空类型}:void\\
\end{cases}
$$


<h3 id="【2】算术类型的尺寸"><a href="#【2】算术类型的尺寸" class="headerlink" title="【2】算术类型的尺寸"></a>【2】算术类型的尺寸</h3><p>算术类型的尺寸在不同机器上有所差距，下表列出 C++ 标准规定的尺寸的最小值。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16位</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode字符</td>
<td>16位</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode字符</td>
<td>32位</td>
</tr>
<tr>
<td>short</td>
<td>短整形</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>整形</td>
<td>16位</td>
</tr>
<tr>
<td>long</td>
<td>长整形</td>
<td>32位</td>
</tr>
<tr>
<td>long long(C++11)</td>
<td>长整形</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ol>
<li>一个 <code>char</code> 大小和一个机器字节一样。</li>
<li>C++规定，一个 <code>int</code> 至少和一个 <code>short</code> 一样大，一个 <code>long</code> 至少和一个 <code>int</code> 一样大，一个 <code>long long</code> 至少和一个 <code>long</code> 一样大。</li>
<li>通常，<code>float</code> 为32位， <code>double</code> 为64位， <code>long double</code> 为96位或128位。类型 <code>float</code> 和 <code>double</code> 分别有7和16个有效位。</li>
</ol>
<h3 id="【3】带-无符号类型"><a href="#【3】带-无符号类型" class="headerlink" title="【3】带/无符号类型"></a>【3】带/无符号类型</h3><ol>
<li><code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code> 都是带符号的，在他们前面加上 <code>unsigned</code> 就可以得到无符号类型。<br><strong>注意</strong>：类型 <code>unsigned int</code> 可以缩写为 <code>unsigned</code> 。</li>
<li>字符型分为三种：<code>char</code>, <code>signed char</code>, <code>unsigned char</code>。因为类型 <code>char</code> 是无符号还是带符号的，对于不同编译器来说，是不同的。<br><strong>注意</strong>：如果你需要一个不大的整数进行运算（算术表达式），明确指定它是 <code>signed char</code> 或者 <code>unsigned char</code> 。</li>
</ol>
<h3 id="【4】如何选择类型"><a href="#【4】如何选择类型" class="headerlink" title="【4】如何选择类型"></a>【4】如何选择类型</h3><ol>
<li>明确知道数值不可能为负时，选无符号类型。</li>
<li>使用 <code>int</code> 进行整数运算。</li>
<li>在算术表达式中，不要使用 <code>char</code> 或 <code>bool</code> 。如果你需要一个不大的整数进行运算（算术表达式），明确指定它是 <code>signed char</code> 或者 <code>unsigned char</code> 。</li>
<li>执行浮点数运算选用 <code>double</code> 。因为 <code>float</code> 精度不够且两者计算代价相差无几。</li>
</ol>
<hr>
<h2 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h2><h3 id="【1】六种类型转换的情况"><a href="#【1】六种类型转换的情况" class="headerlink" title="【1】六种类型转换的情况"></a>【1】六种类型转换的情况</h3><ol>
<li><strong>非布尔-&gt;布尔</strong>：值为 0 则转换为 <code>false</code> ，否则为 <code>true</code> 。</li>
<li><strong>布尔-&gt;非布尔</strong>：值为 <code>flase</code> 则转换为 0 ，值为 <code>true</code> 则为 1 。</li>
<li><strong>浮点数-&gt;整数</strong>：去掉小数，只取整数部分。</li>
<li><strong>整数-&gt;浮点数</strong>：小数部分记为 0 。若整数超过了浮点数的容量，精度可能会损失。</li>
<li><strong>当赋给 <em>无符号类型</em> 一个超出它范围的数</strong>，结果是该数对 <em>无符号类型表示数值总数</em> 取模后的余数。例如：<code>unsigned char c = -1</code> ，实际结果是对256取模后的余数，即255。</li>
<li><strong>当赋给 <em>带符号类型</em> 一个超出它范围的数</strong>，结果是<strong>未定义的</strong>。程序可能继续工作、可能崩溃，也可能产生垃圾数据。<br><strong>例如</strong>：用 <code>g++</code> 运行 <code>int b = INT_MAX + 1;</code> , 输出 <code>b = INT_MIN = -2147483648</code>。这意味着在某些编译器下，含有无法预知的行为的程序也能正确执行。</li>
</ol>
<h3 id="【2】含有无符号类型的表达式"><a href="#【2】含有无符号类型的表达式" class="headerlink" title="【2】含有无符号类型的表达式"></a>【2】含有无符号类型的表达式</h3><p>当一个表达式既有无符号数，又有 <code>int</code> 值时，那个 <code>int</code> 值就会转换成无符号数。<br>把负值转化成无符号数，相当于给一个无符号数赋一个负值，参考上述 <strong>5</strong>。</p>
<p><strong>例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u + i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>假设 <code>int</code> 为32位，输出 $2^{32}-42+10=4294967264$ 。</p>
<p><strong>例2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u * i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>假设 <code>int</code> 为32位，输出 $(2^{32}-1) \times 1=4294967295$ 。</p>
<hr>
<h2 id="2-1-3-字面值常量-literal"><a href="#2-1-3-字面值常量-literal" class="headerlink" title="2.1.3 字面值常量(literal)"></a>2.1.3 字面值常量(literal)</h2><p>形如 -42 的值被称作 <strong>字面值常量</strong> 。</p>
<h3 id="【1】整型、浮点型、字符、字符串、布尔、指针字面值"><a href="#【1】整型、浮点型、字符、字符串、布尔、指针字面值" class="headerlink" title="【1】整型、浮点型、字符、字符串、布尔、指针字面值"></a>【1】整型、浮点型、字符、字符串、布尔、指针字面值</h3><p>整型字面值可以写作十进制数、八进制数、十六进制数。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号，也可能是无符号的。</p>
<p>十进制字面值是 <code>int</code>, <code>long</code>, <code>long long</code> 中，最小的那个，前提是能容纳下当前的值。<br>八进制和十六进制字面值是 <code>int</code>, <code>long</code>, <code>long long</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code> 中，最小的那个，前提是能容纳下当前的值。<br>若最大的数据类型都放不下，将产生错误。</p>
<p><strong>注意：</strong> 类型 <code>short</code> 没有对应的字面值。</p>
<p>默认的，浮点数字面值是一个 <code>double</code> 类型。浮点数字面值表现为一个小数或者科学计数法。<br><code>3.14159 ; 2.14159E0 ; 0. ; 0e0 ; .001</code> 。</p>
<p>由单引号括起来的一个字符成为 <code>char</code> 型字面值，双引号括起来的零个或多个字符则是字符串字面值。</p>
<p><code>true</code> 和 <code>false</code> 是布尔类型的字面值。</p>
<p><code>nullptr</code> 是指针字面值。</p>
<h3 id="【2】转义序列"><a href="#【2】转义序列" class="headerlink" title="【2】转义序列"></a>【2】转义序列</h3><ul>
<li>不可打印字符：退格等控制字符</li>
<li>特殊含义的字符：单双引号、问号、反斜线等</li>
</ul>
<p>C++规定的转义序列：<br><code>\n \t\a \v \b \&quot; \\ \? \&#39; \r \f</code></p>
<p><strong>泛化的转义序列</strong>，形式是 <code>\x</code> 后跟1个或多个十六进制数，或者 <code>\</code> 后跟着1个、2个、3个八进制数。<br>例如：<code>\7(响铃) \12(换行) \40(空格) \x4d(字符M)</code></p>
<ol>
<li>若反斜线 <code>\</code> 后跟的八进制数超过三个，只有前3个构成转义序列。<br>例如：<code>\1234</code>，表示八进制数 123 对应的字符和数字 4 。  </li>
<li><code>\x</code> 则会用到后面跟的所有十六进制数，不过大多数机器 <code>char</code> 只有8位，<code>\x</code> 也不会跟着很多数，超过可能会报错。</li>
</ol>
<h3 id="【3】指定字面值的类型"><a href="#【3】指定字面值的类型" class="headerlink" title="【3】指定字面值的类型"></a>【3】指定字面值的类型</h3><p>字符和字符串字面值：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>Unicode 16字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode 32字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8(仅用于字符串字面常量)</td>
<td>char</td>
</tr>
</tbody></table>
<p>整型字面值：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td>u 或 U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long</td>
</tr>
<tr>
<td>ll 或 LL</td>
<td>long long</td>
</tr>
</tbody></table>
<p>浮点型字面值：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>f 或 F</td>
<td>float</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long double</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：</p>
<ol>
<li>对于一个整型字面值来说，我们指定的是最小匹配类型，依据当前值选择最小的尺寸。</li>
<li>我们还能组合后缀使用，例如 <code>UL</code> 为后缀，将根据具体数值选取 <code>unsigned long</code> 还是 <code>unsigned long long</code>。</li>
</ol>
]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>习题13.13：理解各种操作中的拷贝、构造、析构函数，特别是容器操作中的调用。</title>
    <url>/2019/12/18/CPP-Primer/Exercise/vector%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p><strong>练习13.13</strong>：理解拷贝控制成员和构造函数的一个好方法是定义一个简单的类，为该类定义这些成员，每个成员都打印出自己的名字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X(const X&amp;)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给 X 添加拷贝赋值运算符和析构函数，并编写一个程序以不同方式使用 X 的对象：将它们作为非引用和引用参数传递；动态分配它们；将它们存放于容器中；诸如此类。观察程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。<br>当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。</p>
<a id="more"></a>
<h2 id="2-C-Primer自带答案解析"><a href="#2-C-Primer自带答案解析" class="headerlink" title="2. C++ Primer自带答案解析"></a>2. C++ Primer自带答案解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -默认构造函数Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Test(<span class="keyword">const</span> Test&amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -拷贝构造函数Test(const Test&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; rhs) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -拷贝赋值运算符="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -析构函数~Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Test x)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Test&amp; x)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1.局部变量:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2.非引用传递参数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f1(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3.引用传递参数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f2(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3.1 定义一个引用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Test &amp;x1 = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4.动态分配对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test* px = <span class="keyword">new</span> Test;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"5.添加到容器中"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Test&gt; Vx;</span><br><span class="line">        Vx.push_back(x);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6.释放动态分配对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7.间接初始化y,z、赋值操作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test y = x;</span><br><span class="line">    <span class="function">Test <span class="title">z</span><span class="params">(x)</span></span>;</span><br><span class="line">    y = z;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8.程序结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>局部变量:</span><br><span class="line">  -默认构造函数Test()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>非引用传递参数</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>引用传递参数</span><br><span class="line"></span><br><span class="line"><span class="number">3.1</span> 定义一个引用</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>动态分配对象</span><br><span class="line">  -默认构造函数Test()</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加到容器中</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>释放动态分配对象</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>拷贝初始化y、直接初始化z、赋值操作</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝赋值运算符=</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>程序结束</span><br><span class="line"></span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>不用多说，默认构造函数。</p>
</li>
<li><p>非引用传递参数，我们传给函数 <code>f1()</code> 的是 对象 <code>x</code> 的拷贝。<br>也就是在 <code>f1()</code> 内出现了局部临时对象 <code>xTemp = x</code>，当函数完成时，<code>xTemp</code> 作用域结束，被销毁（调用析构函数）。</p>
</li>
<li><p>引用传递参数。就和 <strong>结果3.1</strong> 所示一样，我们将 局部临时对象  <code>xTemp</code> 绑定到 <code>x</code> 上，即： <code>Test &amp;xTemp = x</code>。<br>既没有拷贝构造也没有析构函数，因为它是一个引用。</p>
<blockquote>
<p>可参考P187， 6.2节-参数传递</p>
</blockquote>
</li>
<li><p>动态分配对象。<code>new</code> 表达式在自由空间构造一个Test型对象，返回指向该对象的指针。所以是默认构造函数。</p>
<blockquote>
<p>可参考P407，12.1.2节-直接管理内存</p>
</blockquote>
</li>
<li><p>添加到容器里。当调用push_back函数时，我们将元素类型的对象传递给他们，这些对象 <strong>拷贝</strong> 到容器里。所以是拷贝构造函数。<br>大括号是个作用域，作用域结束，<code>vector</code> 被销毁，其中的元素也被销毁。  </p>
<blockquote>
<p>可参考P308，使用emplace操作</p>
</blockquote>
</li>
<li><p>对于动态分配的对象，当对指向它的指针执行 <code>delete</code> 操作时被销毁。</p>
<blockquote>
<p>P445，什么时候会调用析构函数</p>
</blockquote>
</li>
<li><p>使用另一个对象初始化一个新对象，都是拷贝构造函数。<br>一个对象赋值给另一个对象，是调用了拷贝赋值运算符。</p>
</li>
<li><p>程序结束，释放 <code>x, y, z</code> 。</p>
</li>
</ol>
<h2 id="2-容器push-back操作中，调用拷贝构造函数的次数"><a href="#2-容器push-back操作中，调用拷贝构造函数的次数" class="headerlink" title="2.容器push_back操作中，调用拷贝构造函数的次数"></a>2.容器push_back操作中，调用拷贝构造函数的次数</h2><p>上面我们只是简单地给 <code>vector</code> 添加了一个元素，但是我发现，当我们添加多个元素时，调用拷贝构造函数的次数与我预期的结果大相径庭。</p>
<p>我们通过几个不同的例子，来搜索一下其中的规律。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(<span class="built_in">vector</span>&lt;Test&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="string">"  "</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt;  v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. 定义4个对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test x1, x2, x3, x4;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2. 逐一push_back四个对象:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Test&gt; q;</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x1);</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x2);</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x3);</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x4);</span><br><span class="line">        printInfo(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义几个对象</span><br><span class="line">  -构造函数Test()</span><br><span class="line">  -构造函数Test()</span><br><span class="line">  -构造函数Test()</span><br><span class="line">  -构造函数Test()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 逐一push_back四个对象:</span><br><span class="line">size:<span class="number">0</span>  capacity:<span class="number">0</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">4</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br></pre></td></tr></table></figure>

<ol>
<li>由此我们发现，当 <code>size == capacity</code> 时，我们再添加一个元素，那么拷贝构造函数的调用次数为：再添加一个元素后的 <code>size</code> 值。</li>
<li>这表明，当容量不足时，<code>vector</code> 会扩充容量，然后将元素重新拷贝一遍。容量足时（例如 <code>q.push_back(x4);</code>），此时只需调用一次拷贝构造函数。</li>
<li>并且，<code>vector</code> 的容量是翻倍增长的：<code>0-&gt;1-&gt;2-&gt;4-&gt;8....</code> 。<blockquote>
<p>翻倍增长可参考P320最上面一段话。</p>
</blockquote>
</li>
</ol>
<p>再深入的讲，就要涉及源码问题了，可参考《STL源码剖析》。</p>
]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
      </categories>
      <tags>
        <tag>Chapter13</tag>
      </tags>
  </entry>
  <entry>
    <title>27-移除元素</title>
    <url>/2019/12/15/LeetCode/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">56.32%</td>
<td align="center">array / two-pointers</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地</strong> 修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“<strong>引用</strong>”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li><code>index</code> 记录我们不和 <code>val</code> 相等的个数。</li>
<li>若不相等，就从开头逐一放在数组中。</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了89.70%的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了93.39%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> elem : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elem != val)</span><br><span class="line">                nums[index ++] = elem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>26-删除排序数组中的重复项</title>
    <url>/2019/12/15/LeetCode/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">46.91%</td>
<td align="center">array / two-pointers</td>
<td align="center">bloomberg / facebook / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地</strong>修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“<strong>引用</strong>”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li><code>index</code> 记录我们不重复的数字的个数。</li>
<li>如果 <code>nums[i] != nums[i - 1]</code> ，则就出现了新的不重复的值，令 <code>nums[index] = nums[i]</code> 即可。</li>
</ol>
<p><strong>注意以下几个细节：</strong></p>
<ol>
<li>第一个数字（<code>nums[0]</code>）肯定是要记录下来的，也就是不变的，所以我们判断条件是 <code>nums[i] != nums[i - 1]</code> ，而不是 <code>nums[i] != nums[i + 1]</code> 。</li>
<li><code>index</code> 实际是从下标1，开始赋值的。</li>
</ol>
<blockquote>
<p>执行用时: 24 ms, 在所有 cpp 提交中击败了91.69%的用户<br>内存消耗: 9.8 MB, 在所有 cpp 提交中击败了86.78%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// nums[0]不变，index从1开始赋值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><ol>
<li>在 <strong>解法一</strong> 中，我们是判断相邻两个数不相等时，则出现了新的不重复数。实际上数组是递增的，当后一个数大于前一个数时，也是出现了新的不重复数。</li>
<li>该程序巧妙的解决了当数组为空时的特殊情况。<br> 当数组为空时，<code>i = 0</code>；非空时，<code>i = 1</code>。</li>
</ol>
<blockquote>
<p>执行用时: 20 ms, 在所有 cpp 提交中击败了98.93%的用户<br>内存消耗: 9.8 MB, 在所有 cpp 提交中击败了87.97%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = !nums.empty();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (n &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[i ++] = n;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>25-K个一组翻转链表</title>
    <url>/2019/12/12/LeetCode/25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">linked-list</td>
<td align="center">facebook / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个链表，每 $k$ 个节点一组进行翻转，请你返回翻转后的链表。<br>$k$ 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 $k$ 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定这个链表：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">当 k = <span class="number">2</span> 时，应当返回: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line">当 k = <span class="number">3</span> 时，应当返回: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="2-1-解法一：递归解法"><a href="#2-1-解法一：递归解法" class="headerlink" title="2.1 解法一：递归解法"></a>2.1 解法一：递归解法</h3><p>总的来说，这道题就是多次反转链表。</p>
<p><strong>1. 如何反转链表？</strong></p>
<ol>
<li>我们需要三个指针 <code>pre, cur, next</code> ，分别指向前一个结点、当前结点、后一个结点。</li>
<li>注意：当 <code>cur</code> 指向第一个结点时，我们要令 <code>pre = nullptr</code> 。</li>
<li>我们先保存好下一个节点：<code>next = cur-&gt;next</code> 。再反转当前结点和前一个结点： <code>cur-&gt;next = pre</code> 。然后 <code>pre, h</code> 都向后移一次：<code>pre = h; h = next</code>。</li>
<li>需要反转几个结点即循环几次。</li>
</ol>
<p><strong>2. 递归返回值和如何使用返回值？</strong></p>
<ol>
<li>应该返回反转之后的头结点（也就是反转之前的尾结点），这里就是 <code>pre</code> 。</li>
<li>令反转之后的尾结点（也就是反转之前的头结点）指向下一次递归的返回值（也就是下一次递归的反转后的头结点）。</li>
</ol>
<p><strong>3. 递归什么时候结束？</strong></p>
<p>当剩余结点数不足 $k$ 个时，我们的递归函数要先检查结点数有没有 $k$ 个。</p>
<blockquote>
<p>执行用时: 20 ms, 在所有 cpp 提交中击败了97.34%的用户<br>内存消耗: 9.5 MB, 在所有 cpp 提交中击败了98.88%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">            ListNode* next = h-&gt;next;</span><br><span class="line">            h-&gt;next = pre;</span><br><span class="line">            pre = h;</span><br><span class="line">            h = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = reverseKGroup(h, k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客内图片不能正常显示，但本地文件可以显示</title>
    <url>/2019/12/11/Hexo/h2-hexo%E5%8D%9A%E5%AE%A2%E5%86%85%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%EF%BC%8C%E4%BD%86%E6%9C%AC%E5%9C%B0%E5%8F%AF%E4%BB%A5/</url>
    <content><![CDATA[<h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>markdown文件中，插入图片的方式为 <code>![](文件路径)</code> ，此时markdown文件可以正常显示图片。<br>但是一上传到博客上，便不能正常显示。</p>
<a id="more"></a>
<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h2><ol>
<li><p>修改 <strong>hexo 目录下</strong>的 .config.yml 文件，<br>将 <code>post_asset_folder: false</code> 修改为 <code>post_asset_folder: true</code>。</p>
</li>
<li><p>安装一个图片路径转换的插件。<br>在hexo文件夹下打开 Git bush。输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install https:<span class="comment">//github.com/7ym0n/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 这使经过修改的插件代码，网上流传的另一份代码 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code> 并不能使用。  </p>
<p>如果你之前安装了这个错误的插件，请将 <strong>/node_modules/hexo-asset-image/index.js</strong><br>这个文件替换成下面的代码：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.config;</span><br><span class="line"><span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">    ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">    xmlMode: <span class="literal">false</span>,</span><br><span class="line">    lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">    decodeEntities: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">            <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.html();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完上述插件后，当我们创建新文章时 <code>hexo new post &quot;new article&quot;</code> ，就自动在 <code>new article.md</code> 文件的同目录下创建一个同名的文件夹，这里就是文件夹 <code>new article</code> 。我们把在 <code>new article.md</code> 使用的图片放入该文件夹中。  </p>
</li>
</ol>
<p><strong>我们的文件目录如下所示：</strong>  </p>
<pre><code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|- _post  </span><br><span class="line">|    |- pictures</span><br><span class="line">|    |    |- hexo.png</span><br><span class="line">|    |- <span class="keyword">new</span> article  </span><br><span class="line">|    |    |- hexo.png  </span><br><span class="line">|    |- <span class="keyword">new</span> article.md</span><br></pre></td></tr></table></figure></code></pre><ol start="4">
<li><p>这里我们给出两种办法来引用图片。</p>
<ol>
<li><p>直接使用代码 <code>![](hexo.png)</code> （虽然没有写文件夹的名字，但是可以的），<code>hexo.png</code> 是我们存在 <code>new article</code> 文件夹内的图片。这时你会发现markdown预览中无法显示这张图片，但是当你将博客上传到网站时，网站上是可以正常显示的。</p>
</li>
<li><p>使用代码 <code>![](new article/hexo.png)</code>不仅可以本地预览，上传到网站也可以正常显示。</p>
</li>
<li><p>本地无法预览也是件很不舒服的事情，其实我们还可以另外创建一个文件夹 <code>pictures</code> ，里面专门存放所有文章的图片，代码 <code>![](pictures/hexo.png)</code> 不仅可以本地预览，上传到网站也可以正常显示。</p>
<p><strong>注意：</strong> 不管采取哪种办法，都要创建一个和md文件同名的文件夹，里面放上需要的图片。<br>如果 <strong>2和3</strong> 中代码无法实现网站上的正常显示，那就使用 <strong>1</strong> 中的代码。<br>因为 <strong>2和3</strong> 中代码我无法保证每个人都成功。</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>参考：<br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">Ericam_：hexo引用本地图片无法显示</a><br><a href="https://www.cnblogs.com/Jesee/p/11234387.html" target="_blank" rel="noopener">Jesse-jia：解决Hexo图片无法显示问题</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>24-两两交换链表中的节点</title>
    <url>/2019/12/11/LeetCode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">linked-list</td>
<td align="center">bloomberg / microsoft / uber</td>
</tr>
</tbody></table>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, 你应该返回 <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：递归解法"><a href="#2-1-解法一：递归解法" class="headerlink" title="2.1 解法一：递归解法"></a>2.1 解法一：递归解法</h3><p>我们以 <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</code> 为例。  </p>
<ol>
<li>我们拿出中间两个节点进行分析，例如 <code>3 -&gt; 4</code> 。</li>
<li>我们最终要使 <code>4</code> 指向 <code>3</code> ，上一个节点指向 <code>4</code>，<code>3</code> 指向下一个节点。<br>即 <code>上一节点 -&gt; 4 -&gt; 3 -&gt; 下一节点</code>。</li>
<li>我们对每一对节点都是 <strong>步骤2</strong> 中这样操作的。</li>
</ol>
<p><strong>现在有两个问题，递归函数返回什么？怎么使用递归函数的返回值？</strong></p>
<ol>
<li>假设我们在某次调用递归时完成了前两个节点的交换，得到了 <code>4 -&gt; 3</code> ，这时 结点 <code>4</code> 应该返回给上一次递归函数的结果，结点 <code>3</code> 应该指向下一次的递归函数的返回值。</li>
<li>然后，传递给递归函数的结点应该向后移动两位。</li>
</ol>
<p><strong>递归结束的条件？</strong><br>当我们的结点数不足两个时，递归结束。</p>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了49.37%的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了73.37%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *next = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：非递归解法"><a href="#2-2-解法二：非递归解法" class="headerlink" title="2.2 解法二：非递归解法"></a>2.2 解法二：非递归解法</h3><p>我们用两个图来描述这个算法的过程。  </p>
<ul>
<li>实线箭头是原来的链表结构，虚线是我们改变之后的。</li>
<li>①②③④是我们交换链表的过程顺序。</li>
<li>注意，<code>p</code> 指针最后会更新（如④所示）。</li>
<li>当 <code>p</code> 之后的结点数不足两个时，循环结束。</li>
</ul>
<p><img src="/2019/12/11/LeetCode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/24_solution_1.png" alt="1"></p>
<p><img src="/2019/12/11/LeetCode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/24_solution_2.png" alt="2"></p>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了49.37%的用户<br>内存消耗: 8.6 MB, 在所有 cpp 提交中击败了79.04%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode *h = p;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">            ListNode *c = p-&gt;next;</span><br><span class="line">            ListNode *n = p-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next = c-&gt;next;</span><br><span class="line">            c-&gt;next = n-&gt;next;</span><br><span class="line">            n-&gt;next = c;</span><br><span class="line">            p = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>23-合并K个排序链表</title>
    <url>/2019/12/08/LeetCode/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">linked-list / divide-and-conquer / heap</td>
<td align="center">airbnb / amazon / facebook / google / linkedin / microsoft / twitter / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>合并 $k$ 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：全部合并再排序"><a href="#2-1-解法一：全部合并再排序" class="headerlink" title="2.1 解法一：全部合并再排序"></a>2.1 解法一：全部合并再排序</h3><p>暴力而有效的解法：<br>我们将 $k$ 个链表全部放入向量中，然后进行排序，最后再放回到一个链表中。</p>
<p>当然我们也可以使用优先队列，那么在放入元素时自动进行了排序。</p>
<p>两者的性能是几乎没有任何差别的。</p>
<h4 id="2-1-1-向量-vector"><a href="#2-1-1-向量-vector" class="headerlink" title="2.1.1 向量 vector"></a>2.1.1 向量 vector</h4><blockquote>
<p>执行用时: 32 ms, 在所有 cpp 提交中击败了89.24%的用户<br>内存消耗: 11.7 MB, 在所有 cpp 提交中击败了63.01%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elem;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *h = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;vec : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span>(vec) &#123;</span><br><span class="line">                elem.push_back(vec-&gt;val);</span><br><span class="line">                vec = vec-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(elem.begin(), elem.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : elem) &#123;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *ptrDelete = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-优先队列-priority-queue"><a href="#2-1-2-优先队列-priority-queue" class="headerlink" title="2.1.2 优先队列 priority_queue"></a>2.1.2 优先队列 priority_queue</h4><blockquote>
<p>执行用时: 36 ms, 在所有 cpp 提交中击败了78.17%的用户<br>内存消耗: 11.6 MB, 在所有 cpp 提交中击败了66.99%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *h = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;vec : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span>(vec) &#123;</span><br><span class="line">                q.push(vec-&gt;val);</span><br><span class="line">                vec = vec-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *ptrDelete = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：两两合并链表"><a href="#2-2-解法二：两两合并链表" class="headerlink" title="2.2 解法二：两两合并链表"></a>2.2 解法二：两两合并链表</h3><p>利用 <a href="https://www.faker.top/2019/11/19/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener">LeetCode-21题：合并两个有序链表</a> ，将合并 $k$ 个链表转化为合并 $k-1$ 次两个链表。  </p>
<p>也就是将前两个链表合并成新的链表，新链表再和第三个链表合并，合并出的新链表再和第四个链表合并……<br>不过这个方法的复杂度很高。</p>
<blockquote>
<p>执行用时: 1428 ms, 在所有 cpp 提交中击败了5.02%的用户<br>内存消耗: 13.9 MB, 在所有 cpp 提交中击败了17.09%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vec : lists) &#123;</span><br><span class="line">            res = mergeTwoLists(res, vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-解法三：分治"><a href="#2-3-解法三：分治" class="headerlink" title="2.3 解法三：分治"></a>2.3 解法三：分治</h3><blockquote>
<p>参考 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/23-he-bing-kge-pai-xu-lian-biao-yi-bu-bu-you-hua-d/" target="_blank" rel="noopener">Sun</a></p>
</blockquote>
<ol>
<li>两两合并链表，最后变成了 $\frac{k}{2}$ 个链表，继续合并，链表数目 $\frac{k}{2}$ -&gt; $\frac{k}{4}$ -&gt; $\frac{k}{8}$… ，直至最后变为一个链表。</li>
<li>我们使用队列实现该操作，将队列前两个链表合并后并弹出，合并后的链表添加到队列尾部，如此循环，直至队列中只有一个链表。</li>
</ol>
<blockquote>
<p>执行用时: 28 ms, 在所有 cpp 提交中击败了96.42%的用户<br>内存消耗: 14.2 MB, 在所有 cpp 提交中击败了17.09%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;ListNode*&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vec : lists)</span><br><span class="line">            q.push(vec);</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* l1 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ListNode* l2 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            q.push(mergeTwoLists(l1, l2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>divide-and-conquer</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>执行 hexo d 时，提示连接Github的22端口超时</title>
    <url>/2019/12/06/Hexo/h1-hexo%20d%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA%E8%BF%9E%E6%8E%A5Github%E7%9A%8422%E7%AB%AF%E5%8F%A3%E8%B6%85%E6%97%B6/</url>
    <content><![CDATA[<p><strong>问题预览：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port <span class="number">22</span>: Connection timed out</span><br><span class="line">fatal: Could <span class="keyword">not</span> read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line"><span class="keyword">and</span> the repository exists.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>具体错误信息如下：</p>
<p><img src="/2019/12/06/Hexo/h1-hexo%20d%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA%E8%BF%9E%E6%8E%A5Github%E7%9A%8422%E7%AB%AF%E5%8F%A3%E8%B6%85%E6%97%B6/hexo-1_1.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port <span class="number">22</span>: Connection timed out</span><br><span class="line">fatal: Could <span class="keyword">not</span> read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line"><span class="keyword">and</span> the repository exists.</span><br><span class="line">FATAL Something<span class="number">'</span>s wrong. Maybe you can find the solution here: https:<span class="comment">//hexo.io/docs/troubleshooting.html</span></span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (F:\Program Files\hexo\node_modules\hexo-util\lib\spawn.js:<span class="number">51</span>:<span class="number">21</span>)</span><br><span class="line">    at ChildProcess.emit (events.js:<span class="number">210</span>:<span class="number">5</span>)</span><br><span class="line">    at ChildProcess.cp.emit (F:\Program Files\hexo\node_modules\cross-spawn\lib\enoent.js:<span class="number">34</span>:<span class="number">29</span>)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:<span class="number">272</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>一开始我把目光聚焦在后面的 <code>Error: Spawn failed</code> 上，但是没有学过前端的我并看不懂。<br>但是，真正的错误是在上面一部分信息里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port <span class="number">22</span>: Connection timed out</span><br><span class="line">fatal: Could <span class="keyword">not</span> read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line"><span class="keyword">and</span> the repository exists.</span><br><span class="line"></span><br><span class="line">ssh：连接到主机github.com端口<span class="number">22</span>：连接超时</span><br><span class="line">致命：无法从远程存储库读取。</span><br><span class="line">请确保您具有正确的访问权限，并且存储库存在。</span><br></pre></td></tr></table></figure>

<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h2><p>直接暴力解决：<strong>重新配置密钥</strong></p>
<ol>
<li><p><code>git bash</code> 窗口依次输入:（注意：双引号里改为你的Github的名字和邮箱）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"MagicConchCpp"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">"csuzhangyang@gmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成新秘钥：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"csuzhangyang@gmail.com"</span></span><br></pre></td></tr></table></figure>

<p>选择文件路径，然后遇到下面这个直接回车。</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"csuzhangyang@gmail.com"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/lenovo/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p> 文件已经存在，是否重写？输入 <code>y</code> ，回车。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/c/Users/lenovo/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br></pre></td></tr></table></figure>

<p> 然后设置密码什么的，不用管，直接两下回车。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/lenovo/.ssh/id_rsa.</span><br><span class="line">Your <span class="keyword">public</span> key has been saved in /c/Users/lenovo/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br></pre></td></tr></table></figure>
</li>
<li><p>新秘钥保存在 <code>/c/Users/lenovo/.ssh/id_rsa.pub</code> 。<br>打开这个文件，复制其中的的内容。<br>在 <code>github</code> 中，打开 <code>setting -&gt; SSH and GPG keys</code> 。删除原来的，把新的复制进去，即解决。重新执行 <code>hexo d</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>22-括号生成</title>
    <url>/2019/11/21/LeetCode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">string / backtracking</td>
<td align="center">google / uber / zenefits</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出 $n$ 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如，给出 n = <span class="number">3</span>，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：回溯"><a href="#2-1-解法一：回溯" class="headerlink" title="2.1 解法一：回溯"></a>2.1 解法一：回溯</h3><p>以 <code>n = 3</code> 为例：我们的字符串 <code>s</code> 一共有 <code>6</code> 个位置来放置 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code>。</p>
<ol>
<li>首先我们知道：第一个位置一定是 <code>&#39;(&#39;</code>，此时 <code>s = ( _ _ _ _ _</code>。</li>
<li>此时我们考虑第二个位置，我们选择可以放置<code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code>。<br><strong>那么什么情况下，我们可以有两个选择呢？</strong><br>很容易想到，应该是当 <code>&#39;(&#39;</code> 的数量大于 <code>&#39;)&#39;</code> 的数量 <strong>并且</strong> <code>&#39;(&#39;</code> 的数量小于 <code>n</code> 时，即 <code>if (left &lt; N &amp;&amp; left &gt; right)</code>。<br>可以思考 <code>s = ( ( ) _ _ _</code> 和 <code>s = ( ( ( ) _ _</code>这两种情况下，下一个位置应该放哪种括号。</li>
<li>步骤2中，我们可以有两个选择。那么我们接下来就应该考虑什么情况下只有一种选择。</li>
<li><strong>只能放置 <code>&#39;(&#39;</code></strong>。<br>易知，当 <code>&#39;(&#39;</code> 的数量等于 <code>&#39;)&#39;</code> 的数量时，我们只能向后添加 <code>&#39;(&#39;</code> 。<br>可以思考 <code>s = ( ( ) ) _ _</code> 和 <code>s = ( ) ( ) _ _</code>这两种情况下，下一个位置应该放哪种括号。</li>
<li><strong>只能放置 <code>&#39;)&#39;</code></strong>。<br>易知，当 <code>&#39;(&#39;</code> 的数量等于 <code>n</code> 时，我们只能向后添加 <code>&#39;)&#39;</code> 。<br>可以思考 <code>s = ( ( ( _ _ _</code> 和 <code>s = ( ) ( ( _ _</code>这两种情况下，下一个位置应该放哪种括号。</li>
</ol>
<p>我们的回溯函数 <code>void backtrack(int left, int right, const string &amp;s)</code> 中，<code>left</code> 和 <code>right</code> 代表的是 <code>s</code> 中左右括号的数量。<br>当 <code>left + right == 2 * N</code> 时，回溯结束。</p>
<p><strong>注意：</strong><br>初始情况下，我们必须要先添加一个 <code>&#39;(&#39;</code>，此时 <code>s =  ( _ _ _ _ _</code>，所以参数 <code>left = 1, right = 0</code>。</p>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了96.60%的用户<br>内存消耗: 17.4 MB, 在所有 cpp 提交中击败了36.95%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        backtrack(<span class="number">1</span>, <span class="number">0</span>, s + <span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left + right == <span class="number">2</span> * N) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; N &amp;&amp; left &gt; right) &#123;</span><br><span class="line">            backtrack(left + <span class="number">1</span>, right, s + <span class="string">"("</span>);</span><br><span class="line">            backtrack(left, right + <span class="number">1</span>, s + <span class="string">")"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == N) &#123;</span><br><span class="line">            backtrack(left, right + <span class="number">1</span>, s + <span class="string">")"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            backtrack(left + <span class="number">1</span>, right, s + <span class="string">"("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：动态规划"><a href="#2-2-解法二：动态规划" class="headerlink" title="2.2 解法二：动态规划"></a>2.2 解法二：动态规划</h3><blockquote>
<p>参考 <a href="https://leetcode.com/rockrock2/" target="_blank" rel="noopener">rockrock2</a>，<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/" target="_blank" rel="noopener">Yuyu</a></p>
</blockquote>
<p>首先看 <code>n</code> 较小时的结果。</p>
<ol>
<li><code>n = 0</code> 是，<code>res = { &quot;&quot; }</code>，为空。</li>
<li><code>n = 1</code> 是，<code>res = { &quot;()&quot; }</code>。</li>
<li><code>n = 2</code> 是，<code>res = { &quot;(())&quot;, &quot;()()&quot; }</code>。</li>
<li><code>n = 3</code> 是，<code>res = { &quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot; }</code>。</li>
</ol>
<p>问题来了，你没有考虑过每一个 <code>n</code> 的结果，都和比它小的 <code>n</code> 的结果，有点关联？</p>
<p>我们可以这么看待这个问题：</p>
<ol>
<li><code>n = i</code> 的结果其实就是比 <code>n = i - 1</code> 多了一对括号。我们可能会想，那么这对括号应该如何放置呢？而事实上，我们应该这样想，那么 <code>n = 1..i-1</code> 的结果，应该如何放到这对括号里呢？也就是这对括号，是不动的。</li>
<li>我们只有两个地方可以放，一是这一对括号内部，二是括号外部。<br><strong>外部：</strong> 其实放在括号左侧或者右侧都行。但是放在右侧，结果会按照字典序排列，因此我们选择放在右侧。但是要知道，放在左侧也是可以的。</li>
<li>我们要对所有 <code>n &lt; i</code> 的情况遍历，要保证最后括号一共 <code>i</code> 对。<ol>
<li>所以如果内部放 <code>n = 0</code> 的结果，右侧就要放 <code>n = i - 1</code> 的结果，排列所有情况。</li>
<li>如果内部放 <code>n = 1</code> 的结果，右侧就要放 <code>n = i - 2</code> 的结果，排列所有情况。</li>
<li>以此类推。。。<br>最后，内部放 <code>n = i - 1</code> 的结果，右侧就要放 <code>n = 0</code> 的结果，排列所有情况。</li>
</ol>
</li>
<li>我们可以得出状态方程：<code>dp[i] = &#39;(&#39; + dp[k] + &#39;)&#39; + dp[i-1-k], k = 0..i-1</code></li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了82.13%的用户<br>内存消耗: 9.9 MB, 在所有 cpp 提交中击败了97.08%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dp[0] = ""</span></span><br><span class="line"><span class="comment">// dp[i] = '(' + dp[k] + ')' + dp[i-1-k], k = 0..i-1 (按字典序)</span></span><br><span class="line"><span class="comment">// 或者dp[i] = dp[k] + '(' + dp[i-1-k] + ')', k = 0..i-1 (非字典序)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">        dp[<span class="number">0</span>] = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; i; ++ k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s1 : dp[k]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> s2 : dp[i - <span class="number">1</span> - k]) &#123;</span><br><span class="line">                        dp[i].push_back(<span class="string">"("</span> + s1 + <span class="string">")"</span> + s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>21-合并两个有序链表</title>
    <url>/2019/11/19/LeetCode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">57.92%</td>
<td align="center">linked-list</td>
<td align="center">amazon / apple / linkedin / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：归并排序"><a href="#2-1-解法一：归并排序" class="headerlink" title="2.1 解法一：归并排序"></a>2.1 解法一：归并排序</h3><ol>
<li>创建一个新的链表 <code>h</code> ，用于存储合并后的链表。</li>
<li>遍历两个链表。比较两者当前的 <code>val</code> 大小，小的则加入到 <code>h</code> 中，并向后移，另外一个链表不用移动。直至某一个链表遍历到尾部，结束。</li>
<li>此时肯定有一个链表没有遍历到尾部，将这个链表剩余的元素依次加入到 <code>h</code> 后面即可。</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了96.15%的用户<br>内存消耗: 9.1 MB, 在所有 cpp 提交中击败了73.70%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* head = h;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l1) &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l2) &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ptrDelete = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：递归（两种）"><a href="#2-2-解法二：递归（两种）" class="headerlink" title="2.2 解法二：递归（两种）"></a>2.2 解法二：递归（两种）</h3><h4 id="2-2-1-简单递归"><a href="#2-2-1-简单递归" class="headerlink" title="2.2.1 简单递归"></a>2.2.1 简单递归</h4><blockquote>
<p>参考<a href="https://leetcode.com/zxyperfect/" target="_blank" rel="noopener">zxyperfect</a></p>
</blockquote>
<ol>
<li><strong>递归思路：</strong><br> 我们每次从两个链表的头结点选出一个较小的放在结果中，并在原链表中删除该结点，然后继续比较两个链表。直至一个链表为空。</li>
<li><strong>递归结束条件：</strong><br>当某个链表为空时，递归结束，但我们返回的是另一个链表。因为另一个链表剩下的肯定是值最大的那部分。例如：<code>if(l1 == nullptr) { return l2; }</code>。</li>
</ol>
<blockquote>
<p>执行用时: 12 ms, 在所有 cpp 提交中击败了69.38%的用户<br>内存消耗: 9 MB, 在所有 cpp 提交中击败了74.60%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-利用swap函数递归"><a href="#2-2-2-利用swap函数递归" class="headerlink" title="2.2.2 利用swap函数递归"></a>2.2.2 利用swap函数递归</h4><blockquote>
<p>参考 <a href="https://leetcode.com/StefanPochmann/" target="_blank" rel="noopener">StefanPochmann</a></p>
</blockquote>
<p><strong>swap函数介绍：</strong><br><code>swap(a, b)</code> ：交换a和b。在此结构体中的意思就是 <code>a-&gt;next</code> 和 <code>b-&gt;next</code> 交换，<code>a-&gt;val</code> 和 <code>b-&gt;val</code> 也交换。</p>
<ol>
<li>首先注意，我们的合并后的链表是 <code>a</code> 头结点所指向的链表，也就是 <code>a</code> 所走过的位置, 都被按顺序加了进来。</li>
<li>总的思想就是：若 <code>a-&gt;val &gt; b-&gt;val</code> ，就 <code>swap(a, b)</code> ，把 <code>a</code> 放到小的那个节点。<br>反之，<code>a</code> 继续向所在节点后面移动，继续比较，<code>a</code> 会始终保持在较小的那个节点上。</li>
<li>若 <code>a</code> 所在链表到达尾部时（<code>a = nullptr</code>），说明另外一个链表剩余的都是最大的几个值，我们这时仍需要 <code>swap(a, b)</code> ，将 <code>a</code> 放到另一个链表剩余的值上。</li>
<li>后续我会画个图例出来。</li>
</ol>
<blockquote>
<p>执行用时 :8 ms, 在所有 cpp 提交中击败了95.91%的用户<br>内存消耗 :8.7 MB, 在所有 cpp 提交中击败了97.11%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>20-有效的括号</title>
    <url>/2019/11/15/LeetCode/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">39.88%</td>
<td align="center">string / stack</td>
<td align="center">airbnb / amazon / bloomberg / facebook / google / microsoft / twitter / zenefits</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><ol>
<li>通过栈来解决。</li>
<li>遇见左括号就压入栈中，遇见右括号，则判断当前栈顶元素是否是对应的左括号。若是，则将该左括号出栈；若不是，则返回 <code>false</code>。</li>
<li>最后根据栈是否为空来判断括号是否有效，栈为空则有效。</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了75.87%的用户<br>内存消耗: 8.6 MB, 在所有 cpp 提交中击败了71.46%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; m = &#123; &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;, &#123;<span class="string">'['</span>, <span class="string">']'</span>&#125;, &#123;<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.empty() &amp;&amp; m[st.top()] == c) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m[c] == <span class="number">0</span>) &#123; <span class="comment">// m[c] == 0即：是右括号的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>19-删除链表的倒数第N个节点</title>
    <url>/2019/11/14/LeetCode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">36.08%</td>
<td align="center">linked-list / two-pointers</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<h2 id="2-解法：双指针法"><a href="#2-解法：双指针法" class="headerlink" title="2. 解法：双指针法"></a>2. 解法：双指针法</h2><p><strong>如何找到链表的倒数第 $n$ 个节点？</strong></p>
<ol>
<li>定义两个指针 <code>l1</code>，<code>l2</code>，均指向头结点。</li>
<li>先让 <code>l1</code> 向右移动 <code>n - 1</code> 次。</li>
<li>然后再同时向右移动 <code>l1</code> 和 <code>l2</code>，等到 <code>l1</code> 移动到尾节点时， <code>l2</code> 此时指向倒数第 <code>n</code> 个节点。</li>
</ol>
<p>需要注意的是，我们目的是要 <strong>删除</strong> 倒数第 <code>n</code> 个节点，所以我们要找到倒数第 <code>n + 1</code> 个节点。也就是步骤 <strong>2</strong> 中，<code>l1</code> 总共应该向右移动 <code>n</code> 次。</p>
<p><strong>接下来，思考这么一个问题。</strong> 假如我们的链表长度为 $n$，而我们要删除倒数第 $n$ 个元素（也就是第一个元素），这时会有什么问题呢？</p>
<p>答案很明显，我们无法找到倒数第 $n+1$ 个元素，也就是第0个元素，但是我们没有第0个元素，这时就无法删除第一个元素了。</p>
<p>有的人可能会说，那我们直接对这种情况特殊处理就好啦。<br>但是，需要注意的是，我们的复杂度要求是 <strong>只遍历一遍链表</strong> ，也就是我们先前并不知道链表的长度，也就无法判断是否是这种情况。</p>
<p>在这里，我们给出<strong>两种</strong>解决办法。  </p>
<h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>向头结点前增加一个结点，也就是添加了第0个元素。</p>
<p><strong>注意一个问题。</strong> 最后返回的是 <code>h-&gt;next</code>，开头我们定义了 <code>l1 = l2 = h, l1-&gt;next = head</code>，即：<code>h-&gt;next = head</code>，那么能不能返回 <code>head</code> 呢？<br>答案是<strong>不能</strong>。<br>在删除的是第一个元素的情况下结果会出错，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">预期结果：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>因为我们的目的是删除该头结点，我们并没有对 <code>head</code> 这个头结点有任何操作，那么最后返回 <code>head</code> 的话就必定会有头结点存在。</p>
<p>我们会在<strong>解法二</strong>中看到，处理删除第一个元素的情况是返回 <code>head-&gt;next</code>。</p>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了72.41%的用户<br>内存消耗: 8.6 MB, 在所有 cpp 提交中击败了76.23%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 头结点前增加一个结点</span></span><br><span class="line">        ListNode* l1 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        l1-&gt;next = head;</span><br><span class="line">        ListNode* l2 = l1;</span><br><span class="line">        ListNode* h = l2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1-&gt;next) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next = l2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-解法二"><a href="#2-1-解法二" class="headerlink" title="2.1 解法二"></a>2.1 解法二</h3><blockquote>
<p>参考<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/java-shuang-zhi-zhen-jie-fa-zhi-xing-shi-jian-chao/" target="_blank" rel="noopener">【微笑永恒】</a></p>
</blockquote>
<ol>
<li>先让 <code>l1</code> 向右移动 <code>n - 1</code> 次，若此时 <code>l1-&gt;next</code> 为空，说明我们要删除第一个元素。直接返回 <code>head-&gt;next</code> 即可。</li>
<li>若 <code>l1-&gt;next</code> 不为空，<code>l1</code> 再向右移动一次，即共移动 <code>n</code> 次。</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了96.70%的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了90.51%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = l1;</span><br><span class="line">        <span class="comment">// 右移n-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要删除的元素是不是第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (!l1-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="comment">// 应该右移n次，补上一次</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        <span class="comment">// 两个指针同时移动，直到l1到末尾</span></span><br><span class="line">        <span class="keyword">while</span> (l1-&gt;next) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除该元素</span></span><br><span class="line">        l2-&gt;next = l2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>18-四数之和</title>
    <url>/2019/11/14/LeetCode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">36.01%</td>
<td align="center">array / hash-table / two-pointers</td>
<td align="center">linkedin</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包含 $n$ 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 $a$，$b$，$c$ 和 $d$ ，使得 $a + b + c + d$ 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>]，和 target = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><p>与前面三数之和类似，还是采用双指针法，双指针是用来选择后两个数的，因此前面还需要两个循环，来选择前两个数。</p>
<p>需要注意的是这四个数，都需要进行去重处理。双指针的去重我不再赘述，详情参考 <a href="https://blog.csdn.net/qq_36408085/article/details/102907454" target="_blank" rel="noopener">LeetCode(C++)刷题计划：15-三数之和</a>。</p>
<p>下面我们讲一下，前两个数的去重代码，以 <code>nums = [0, 0, 1, 1, 1, 2]</code> 为例。</p>
<ol>
<li>首先第一个数的去重代码 <code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code><ol>
<li><code>nums[i] == nums[i - 1]</code> 的作用就是判断当前数是否和前一个数相等。</li>
<li><code>i &gt; 0</code>，是为了防止第一个数的 <code>nums[0] == nums[-1]</code>，这样数组就越界了。</li>
</ol>
</li>
<li>第二个数的去重代码 <code>if (k &gt; i + 1 &amp;&amp; nums[k] == nums[k - 1]) continue;</code><ol>
<li><code>nums[k] == nums[k - 1]</code> 的作用和前面一样。</li>
<li><code>k &gt; i + 1</code> 的目的倒不是防止越界，因为不可能越界。它主要为了防止过度去重。<br>举个例子：<code>nums = [0, 0, 1, 1, 1, 2]</code>。<br>当 <code>i = 2</code> 时, <code>nums[i] = 1</code>。此时 <code>k = i + 1 = 3</code>, <code>nums[k] = 1</code>。<br>如果我们没有 <code>k &gt; i + 1</code> 这句，他会认为 <code>nums[k]</code> 是重复数据(因为 <code>nums[k] == nums[k - 1]</code>)。但是实际上是<code>nums[k]</code> 和 <code>nums[i]</code> (k = i + 1)在比较是否相等，然而这两个数是可以相等的。<br><strong>我们需要避免的是</strong>，在同一个 <code>nums[i]</code> 下，连续的 <code>nums[k]</code> 不能相等， <code>nums[i]</code> 不在我们的比较范围内。</li>
</ol>
</li>
</ol>
<blockquote>
<p>执行用时: 76 ms, 在所有 cpp 提交中击败了42.69%的用户<br>内存消耗: 8.9 MB, 在所有 cpp 提交中击败了96.88%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k = i + <span class="number">1</span>; k &lt; n - <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; i + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[k] + nums[l] + nums[r];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[k], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++ l]) &#123; &#125;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r ]) &#123; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        ++ l;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        -- r;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>17-电话号码的字母组合</title>
    <url>/2019/11/10/LeetCode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">51.27%</td>
<td align="center">string / backtracking</td>
<td align="center">amazon / dropbox / facebook / google / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 <code>1</code> 不对应任何字母。</p>
<img src="/2019/11/10/LeetCode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/17.png" width="300" height="300" alt="图片名称">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入：<span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：递归法"><a href="#2-1-解法一：递归法" class="headerlink" title="2.1 解法一：递归法"></a>2.1 解法一：递归法</h3><p>以 <code>digits = &quot;23&quot;</code>为例：</p>
<ol>
<li><p>我们递归函数只接受两个参数：上一次的结果 <code>res</code> ，这一次要结合的数字 <code>digits[i]</code>。</p>
</li>
<li><p>首先用第一个数字初始化我们的 <code>res</code>，例如第一个数字是 <code>2</code> ，那么 <code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}</code> 。</p>
</li>
<li><p>第二个数字是 <code>3</code>，<code>m[3] = &quot;def&quot;</code>。那么 <code>m[3]</code> 和 <code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}</code>怎么组合呢？</p>
</li>
<li><p>首先 <code>res</code> 暂时只有3个元素，和 <code>m[3]</code> 组合后应该有 $3 \times 3 = 9$ 个元素。</p>
</li>
<li><p>总的来说，元素的添加顺序是，</p>
<ol>
<li><p><code>res.push_back(res[0] + &#39;e&#39;); res.push_back(res[0] + &#39;f&#39;);</code><br>结果：<code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;}</code></p>
</li>
<li><p><code>res.push_back(res[1] + &#39;e&#39;); res.push_back(res[1] + &#39;f&#39;);</code><br>结果：<code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;}</code></p>
</li>
<li><p><code>res[0] += &#39;d&#39;; res[1] += &#39;d&#39;; res[2] += &#39;d&#39;;</code><br>结果：<code>res = {&quot;ad&quot;, &quot;bd&quot;, &quot;cd&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;}</code></p>
</li>
</ol>
</li>
<li><p>我们得出一个规律，假设当前数字中所含字母长度为 <code>l</code>（n=3或4）。我们可以将前 <code>l-1</code> 个字母和 <code>res</code> 进行排列组合加入到 <code>res</code>中。为什么要剩下一个字母呢，因为我们 <code>res</code> 中还有一些元素仍然是上次的结果，我们把最后一个字母直接加入到上次的结果的元素后。</p>
</li>
<li><p>当然你也可以选择将所以字母和 <code>res</code> 进行排列组合，然后删除前面的无效的元素。</p>
</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了 77.47% 的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了 90.68% 的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; digits.size(); ++ i) &#123;</span><br><span class="line">            combine(res, digits[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = res.size();</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">int</span> l = m[digit].size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; l; ++ j) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">1</span>, m[digit][j])</span></span>;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; l - <span class="number">1</span>; ++ j)</span><br><span class="line">                res.push_back(res[i] + m[digit][j]);</span><br><span class="line">            res[i] += m[digit][l - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：使用队列"><a href="#2-2-解法二：使用队列" class="headerlink" title="2.2 解法二：使用队列"></a>2.2 解法二：使用队列</h3><ol>
<li>每次从队头取出一个元素，与m[]中字符串中的每个字符分别组合，然后放入队尾。</li>
</ol>
<blockquote>
<p>执行用时: 0 ms, 在所有 cpp 提交中击败了 100.00% 的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了 48.35% 的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m = &#123; &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;, &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125; &#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="comment">// 先处理第一个数字。是为了使q不为空。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m[digits[<span class="number">0</span>]]) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">1</span>, i)</span></span>;</span><br><span class="line">            q.push(s);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; digits.size(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; len; ++ j) &#123;</span><br><span class="line">                <span class="built_in">string</span> s = q.front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; m[digits[i]].size(); ++ k) &#123;</span><br><span class="line">                    q.push(s + m[digits[i]][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-深度优先遍历"><a href="#2-3-深度优先遍历" class="headerlink" title="2.3 深度优先遍历"></a>2.3 深度优先遍历</h3><blockquote>
<p>第一段代码来自 <a href="https://leetcode.com/zefengsong/" target="_blank" rel="noopener">zefengsong</a>。<br>第二份代码是参考 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/yan-du-you-xian-bian-li-by-gqxing/" target="_blank" rel="noopener">GQXING</a> 修改了的第一份代码。<br>图来自 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<p>如图所示。<br><img src="/2019/11/10/LeetCode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/17_solution.png" alt="2"></p>
<blockquote>
<p>执行用时: 0 ms, 在所有 cpp 提交中击败了 100.00% 的用户<br>内存消耗: 8.5 MB, 在所有 cpp 提交中击败了 79.75% 的用户</p>
</blockquote>
<p><strong>代码一：</strong> <code>path</code> 引用传值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;letter(&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;);</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">""</span>;</span><br><span class="line">        DFS(digits, <span class="number">0</span>, path, res, letter);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> pos, <span class="built_in">string</span>&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; letter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.size())&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: letter[digits[pos] - <span class="string">'0'</span>])&#123;</span><br><span class="line">            path.push_back(c);</span><br><span class="line">            DFS(digits, pos + <span class="number">1</span>, path, res, letter);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>代码二：</strong> <code>path</code> 非引用传值。</p>
<p>虽然我们知道，在传递字符串时，最好使用引用传值。但是我们的目的是在一次递归里不修改 <code>path</code> 的值(否则我们就要像代码1一样，还要删除 <code>path</code> 的尾元素)，所以我们不使用引用传值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;letter(&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;);</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">""</span>;</span><br><span class="line">        DFS(digits, <span class="number">0</span>, path, res, letter);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> pos, <span class="built_in">string</span> path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; letter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.size())&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: letter[digits[pos] - <span class="string">'0'</span>])&#123;</span><br><span class="line">            DFS(digits, pos + <span class="number">1</span>, path + c, res, letter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>16-最接近的三数之和</title>
    <url>/2019/11/07/LeetCode/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">41.91%</td>
<td align="center">array / two-pointers</td>
<td align="center">bloomberg</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [<span class="number">-1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">-4</span>], 和 target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><ol>
<li>与第15题三数之和类似。三数之和是当和为 <code>target</code> 是我们需要的值，此题则是$|sum - target|$最小时，是我们需要的值。</li>
<li>其余部分和三数之和相同。参考链接：<a href="https://blog.csdn.net/qq_36408085/article/details/102907454" target="_blank" rel="noopener">15 - 三数之和</a></li>
</ol>
<blockquote>
<p>执行用时: 12 ms, 在所有 cpp 提交中击败了 72.29% 的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了 87.01% 的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">long</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; nums.size() - <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                sum = nums[k] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - target) &lt; <span class="built_in">abs</span>(res - target))</span><br><span class="line">                        res = sum;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++ l]) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[-- r]) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>15-三数之和</title>
    <url>/2019/11/04/LeetCode/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">24.31%</td>
<td align="center">array / two-pointers</td>
<td align="center">adobe / amazon / bloomberg / facebook / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包含 <em>n</em> 个整数的数组 nums，判断 nums 中是否存在三个元素 $a，b，c ，$使得 $a + b + c = 0$ ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><ol>
<li>首先对数组从大到小排序，数组的大小为 <code>n</code> 。</li>
<li>固定一个数，从其右侧的数中寻找另外两个数。<br>假设我们固定的数为 <code>nums[k], k = 0 to n-1</code> , 另外两个数初始时分别为 <code>nums[l], nums[r]</code> , 其中 <code>l = k + 1, r = n - 1</code> 。</li>
<li>令 <code>sum = nums[k] + nums[l] + nums[r]</code> 。<ol>
<li>若 <code>sum &lt; 0</code> ，则我们要增大 <code>sum</code> ，此时只能对 <code>l</code> 向右挪一格，即：<code>l ++</code> 。</li>
<li>若 <code>sum &gt; 0</code> ，则我们要减小 <code>sum</code> ，此时只能对 <code>r</code> 向左挪一格，即：<code>r --</code> 。</li>
<li>若 <code>sum == 0</code> ，此时这三个数就我们需要的数，将他们加入结果里。此时，<code>l</code> 和 <code>r</code> 之间的数还可能有我们需要的数，我们此时需要左右都向内移动，即：<code>l ++, r --</code> 。。  </li>
</ol>
</li>
<li><strong>避免重复的数据。</strong><ol>
<li>当 <code>sum == 0</code> 时，我们需要 <code>l</code> 和 <code>r</code> 都向内移动。此时需要过滤掉和当前 <code>nums[l], nums[r]</code> 重复的数据，我们巧妙的使用了两个while循环，同时需注意 <code>l 要一直小于 r</code>。<br><code>while (l &lt; r &amp;&amp; nums[l] == nums[++ l]) { }</code><br><code>while (l &lt; r &amp;&amp; nums[r] == nums[-- r]) { }</code></li>
<li>同时，我们也要在 <code>k</code> 的循环中过滤掉和当前 <code>nums[k]</code> 重复的数字。这里的 <code>k &lt; len - 2</code>主要是防止数组越界。<br><code>while (k &lt; len - 2 &amp;&amp; nums[k] == nums[++ k]) { }</code></li>
</ol>
</li>
<li>当 <code>l &gt;= r</code> 时，说明与当前固定的 <code>nums[k]</code> 相组合的两个数已经找完，所以要进入下一个 <code>nums[k]</code>。</li>
</ol>
<blockquote>
<p>执行用时: 112 ms, 在所有 cpp 提交中击败了98.73%的用户<br>内存消耗: 14.6 MB, 在所有 cpp 提交中击败了86.17%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; len - <span class="number">2</span> &amp;&amp; nums[k] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[k] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[k], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++ l]) &#123; &#125;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[-- r]) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++ l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    -- r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; len - <span class="number">2</span> &amp;&amp; nums[k] == nums[++ k]) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>14-最长公共前缀</title>
    <url>/2019/11/02/LeetCode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">35.13%</td>
<td align="center">string</td>
<td align="center">yelp</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 所有输入只包含小写字母 <code>a-z</code> 。</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li>从第一个位置开始，判断每个字符串该位置是否全部相等。</li>
<li>即：若 <code>vector&lt;string&gt;</code> 字符串为 <code>str1, str2, str3</code>。<ul>
<li>我们比较 <code>str1[0], str2[0], str3[0]</code> 是否全部相等。</li>
<li>若相等，比较 <code>str1[1], str2[1], str3[1]</code> 是否全部相等。</li>
<li>依次下去比较，直至第一次不全部相等时结束。</li>
</ul>
</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了71.92%的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了92.56%的用户</p>
</blockquote>
<p><strong>1. 将 <code>vector&lt;string&gt;</code> 视为二维数组：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> m = strs.size();</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].size() &gt; maxSize)</span><br><span class="line">                maxSize = strs[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; maxSize; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j][i] != strs[j + <span class="number">1</span>][i])</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res += strs[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 利用迭代器：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = strs.begin();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; strs.size(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*(iter + i)).size() &gt; maxSize)</span><br><span class="line">                maxSize = (*(iter + i)).size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; maxSize; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; strs.size() - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*(iter + j))[i] != (*(iter + j + <span class="number">1</span>))[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (*iter)[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>13-罗马数字转整数</title>
    <url>/2019/11/01/LeetCode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">59.40%</td>
<td align="center">math / string</td>
<td align="center">bloomberg / facebook / microsoft / uber / yahoo</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>罗马数字包含以下七种字符： <code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"III"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"IV"</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"IX"</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li>我们可以发现，如果前一个字母小于后一个字母（例如：<code>CM</code>），那么它俩肯定是组合数（即<code>CM = M-C = 900</code>）。</li>
<li>所以我们只要发现 <code>s[i] &lt; s[i + 1]</code> 那么我们就加上它俩之差。</li>
<li>其余的都是单个字母，加上单个字母的值。</li>
</ol>
<p>我们给出两种代码，一种是正序遍历，一种是逆序遍历，显然逆序遍历更加简洁。</p>
<blockquote>
<p>执行用时: 24 ms, 在所有 cpp 提交中击败了62.53%的用户<br>内存消耗: 10.7 MB, 在所有 cpp 提交中击败了84.86%的用户</p>
</blockquote>
<p><strong>正序遍历：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; romanMap= &#123; &#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;, &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;, &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;, &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> num[n];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            num[i] = romanMap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> romanMap[s[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &lt; num[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                sum = sum + num[i + <span class="number">1</span>] - num[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[n - <span class="number">2</span>] &gt;= num[n - <span class="number">1</span>])</span><br><span class="line">            sum += num[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>逆序遍历：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; romanMap= &#123; &#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;, &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;, &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;, &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = romanMap[s.back()];</span><br><span class="line">        <span class="comment">// auto i = s.size() - 2 报错</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            sum += romanMap[s[i]] &gt;= romanMap[s[i + <span class="number">1</span>]] ? romanMap[s[i]] : -romanMap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>12-整数转罗马数字</title>
    <url>/2019/10/31/LeetCode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">61.47%</td>
<td align="center">math / string</td>
<td align="center">twitter</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>罗马数字包含以下七种字符： <code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="number">9</span></span><br><span class="line">输出: <span class="string">"IX"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: L = <span class="number">50</span>, V = <span class="number">5</span>, III = <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：字典寻找法"><a href="#2-1-解法一：字典寻找法" class="headerlink" title="2.1 解法一：字典寻找法"></a>2.1 解法一：字典寻找法</h3><ol>
<li>我们将个、十、百、千位所有可能出现的数字的罗马字母都罗列出来，然后求出所求数字的个、十、百、千位的值，找出对应的罗马字母即可。</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了91.78%的用户<br>内存消耗: 8.3 MB, 在所有 cpp 提交中击败了90.53%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ge[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> shi[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> bai[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> qian[<span class="number">4</span>] = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> qian[num / <span class="number">1000</span>] + bai[(num % <span class="number">1000</span>) / <span class="number">100</span>] + shi[(num % <span class="number">100</span>) / <span class="number">10</span>] + ge[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：贪心算法"><a href="#2-2-解法二：贪心算法" class="headerlink" title="2.2 解法二：贪心算法"></a>2.2 解法二：贪心算法</h3><ol>
<li>我们列出所有最小单位的罗马字母组合，假设输入整数为 <code>num</code>。</li>
<li>从最大的数开始匹配，看 <code>num</code> 能匹配几次，每次匹配 <code>num</code> 都要减去这个数。</li>
<li>若 <code>num</code> 开始小于最大的数，则从第二大的数再次开始匹配，直至 <code>num</code> 变为 <code>0</code>。</li>
</ol>
<p>我给出两种代码，一种是利用反向迭代器，一种利用普通迭代器，主要是为了熟悉迭代器操作。</p>
<blockquote>
<p>执行用时 :28 ms, 在所有 cpp 提交中击败了22.65%的用户<br>内存消耗 :15.3 MB, 在所有 cpp 提交中击败了70.87%的用户</p>
</blockquote>
<p><strong>1 反向迭代器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; romanMap= &#123; &#123;<span class="number">1</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"IV"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"V"</span>&#125;, &#123;<span class="number">9</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">10</span>, <span class="string">"X"</span>&#125;, &#123;<span class="number">40</span>, <span class="string">"XL"</span>&#125;, &#123;<span class="number">50</span>, <span class="string">"L"</span>&#125;, &#123;<span class="number">90</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">100</span>, <span class="string">"C"</span>&#125;, &#123;<span class="number">400</span>, <span class="string">"CD"</span>&#125;, &#123;<span class="number">500</span>, <span class="string">"D"</span>&#125;, &#123;<span class="number">900</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">1000</span>, <span class="string">"M"</span>&#125; &#125;;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::reverse_iterator r_iter = romanMap.rbegin();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (r_iter != romanMap.rend()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= r_iter-&gt;first) &#123;</span><br><span class="line">                res += r_iter-&gt;second;</span><br><span class="line">                num -= r_iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r_iter ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2 普通迭代器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; romanMap= &#123; &#123;<span class="number">1</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"IV"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"V"</span>&#125;, &#123;<span class="number">9</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">10</span>, <span class="string">"X"</span>&#125;, &#123;<span class="number">40</span>, <span class="string">"XL"</span>&#125;, &#123;<span class="number">50</span>, <span class="string">"L"</span>&#125;, &#123;<span class="number">90</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">100</span>, <span class="string">"C"</span>&#125;, &#123;<span class="number">400</span>, <span class="string">"CD"</span>&#125;, &#123;<span class="number">500</span>, <span class="string">"D"</span>&#125;, &#123;<span class="number">900</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">1000</span>, <span class="string">"M"</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">auto</span> iter = -- romanMap.end();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter != -- romanMap.begin()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= iter-&gt;first) &#123;</span><br><span class="line">                res += iter-&gt;second;</span><br><span class="line">                num -= iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                -- iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>11-盛最多水的容器</title>
    <url>/2019/10/28/LeetCode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">58.84%</td>
<td align="center">array / two-pointers</td>
<td align="center">bloomberg</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定 $n$ 个非负整数 $a1，a2，…，an$，每个数代表坐标中的一个点 $(i, ai)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, ai)$ 和 $(i, 0)$。找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明</strong>：你不能倾斜容器，且 $n$ 的值至少为 2。</p>
<p><img src="/2019/10/28/LeetCode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/11.jpg" alt="1"></p>
<p>图中垂直线代表输入数组 <code>[1,8,6,2,5,4,8,3,7]</code>。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <strong>49</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/" target="_blank" rel="noopener">Krahets</a></p>
</blockquote>
<ol>
<li>指针 $l$，$r$ 分别指向最左边和最右边的木板，根据规则移动两个指针。获取每次移动之后的容器的大小，最后得到一个最大值。</li>
<li>由题意可知，$S = 底\times高 = (r - l) \times min(h[l], h[r])$，面积是由两个木板中的短板决定的。</li>
<li>无论我们移动哪一侧的木板，底 $(r - l)$ 都会减1。<ol>
<li>如果我们选择<strong>短板</strong>一侧的指针向内移一格，那么容器的宽 $min(h[l], h[r])$ <strong>可能变小也可能变大</strong>。</li>
<li>如果我们选择<strong>长板</strong>一侧的指针向内移一格，那么容器的宽 $min(h[l], h[r])$ <strong>可能不变也可能变小</strong>。</li>
</ol>
</li>
<li>所以，我们可以推断出，只有向内移动<strong>短板</strong>一侧的指针， $S$ <strong>才可能会变大</strong>（虽然也可能变小）。但是向内移动<strong>长板</strong>一侧的指针，$S$ <strong>一定不会变大</strong>。</li>
</ol>
<blockquote>
<p>执行用时: 16 ms, 在所有 cpp 提交中击败了95.90%的用户<br>内存消耗: 9.8 MB, 在所有 cpp 提交中击败了75.70%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                maxS = max(maxS, (right - left) * height[left ++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxS = max(maxS, (right - left) * height[right --]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>10-正则表达式匹配</title>
    <url>/2019/10/27/LeetCode/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Hard</td>
<td align="center">25.22%</td>
<td align="center">string / dynamic-programming / backtracking</td>
<td align="center">airbnb / facebook / google / twitter / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">'.'</span> 匹配任意单个字符</span><br><span class="line"><span class="string">'*'</span> 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>

<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 s的，而不是部分字符串。</p>
<p><strong>说明:</strong></p>
<ul>
<li>s 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li>p 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="string">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">".*"</span> 表示可匹配零个或多个（<span class="string">'*'</span>）任意字符（<span class="string">'.'</span>）。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"c*a*b"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 表示零个或多个，这里 <span class="string">'c'</span> 为 <span class="number">0</span> 个, <span class="string">'a'</span> 被重复一次。因此可以匹配字符串 <span class="string">"aab"</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"mississippi"</span></span><br><span class="line">p = <span class="string">"mis*is*p*."</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：递归法"><a href="#2-1-解法一：递归法" class="headerlink" title="2.1 解法一：递归法"></a>2.1 解法一：递归法</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/di-gui-dong-tai-gui-hua-by-joy-teng/" target="_blank" rel="noopener">Joy</a></p>
</blockquote>
<ol>
<li><p>p为空。s为空，则返回true；s不为空，则返回false。</p>
</li>
<li><p>当p的第二个元素是 <code>*</code> 时，<strong>有两种情况，满足一种就可以（即 <code>||</code> ）</strong>：</p>
<ol>
<li><strong>剔除p中前两个元素，再来判断是否匹配。</strong><br> 例如：<code>s = &quot;aab&quot;</code>, <code>p = &quot;c*a*b&quot;</code>。其中 <code>c*</code> 可以是0个c，所以可以无视掉。<br> 直接判断<code>s = &quot;aab&quot;</code> 和 <code>p = &quot;a*b&quot;</code>是否匹配。  </li>
<li><strong>当 <code>s[0] == p[0] || p[0] == &#39;.&#39;</code> 时，剔除s中第一个元素，再来判断是否匹配。</strong><br> 例如：<code>s = &quot;aab&quot;</code>, <code>p = &quot;a*b&quot;</code>。<code>a*</code>可以匹配0~多个，<code>s[0] = &#39;a&#39;</code>被匹配，可以删除。接下来比较<code>s = &quot;ab&quot;</code> 和 <code>p = &quot;a*b&quot;</code>是否匹配。</li>
</ol>
</li>
<li><p><strong>如果第二个元素不是 <code>*</code>，那就只能是 <code>a-z</code> 或者 <code>&#39;.&#39;</code> 了。</strong><br>当第一个元素两两匹配时，我们就可以删除掉这俩元素了，因为没有 <code>*</code>的情况下，<code>a-z</code> 和 <code>&#39;.&#39;</code>只能匹配一次。<br>例如：<code>s = &quot;aab&quot;</code>, <code>p = &quot;.a*b&quot;</code>。因为 <code>p[1] = &#39;a&#39;</code>, <code>p[0] = &#39;.&#39;, s[0] = &#39;a&#39;</code>，两者匹配。所以剔除掉首元素，接下来判断<code>s = &quot;ab&quot;</code>, <code>p = &quot;a*b&quot;</code>是否匹配。</p>
</li>
</ol>
<blockquote>
<p>执行用时: 300 ms, 在所有 cpp 提交中击败了29.78%的用户<br>内存消耗: 15.5 MB, 在所有 cpp 提交中击败了14.56%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.empty())</span><br><span class="line">            <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span> (p.size() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：动态规划"><a href="#2-2-解法二：动态规划" class="headerlink" title="2.2 解法二：动态规划"></a>2.2 解法二：动态规划</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/" target="_blank" rel="noopener">乔碧萝殿下❤</a>，<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-dong-tai-gui-hua-by-jy/" target="_blank" rel="noopener">Krahets</a></p>
</blockquote>
<p><strong>dp数组的样子:</strong> <code>s=&quot;abb&quot;,p=&quot;ab*c*&quot;</code>，方便大家理解。<br>为什么加 <code>&#39;#&#39;</code> 见步骤5。<br><code>1</code> 表示 <code>true</code>，<code>0</code> 表示 <code>false</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta"># a b * c *</span></span><br><span class="line"># <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">a <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>建立二维数组 <code>dp</code>，<code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个元素和 <code>p</code> 的前 <code>j</code> 个元素是否匹配。</p>
</li>
<li><p>首先分析最简单的情况：<code>s[i] == p[j]</code>。此时若s的前<code>i-1</code>个元素和p的前<code>j-1</code>个元素相匹配，那么s的前<code>i</code>个元素和p的前<code>j</code>个元素也必相匹配。即此时的状态转移方程为: <code>dp[i][j] = dp[i - 1][j - 1]</code>。</p>
</li>
<li><p>第二种情况，当 <code>p[j] == &#39;.&#39;</code> 时，和2中情况相同，状态转移方程仍为：<code>dp[i][j] = dp[i - 1][j - 1]</code>。</p>
</li>
<li><p>第三种比较复杂的情况，当 <code>p[j] == &#39;*&#39;</code>时。此时我们必须要考虑 <code>&#39;*&#39;</code> 之前的元素，分为以下两种情况：  </p>
<ol>
<li><strong><code>s[i] != p[j - 1]</code>：<code>dp[i][j] = dp[i][j - 2]</code></strong>，此时表示 <code>*</code> 前面的字母根本和 <code>s[i]</code> 中字母不相同。<br>例如： <code>s = &quot;abb&quot;, p = &quot;ab*c*&quot;</code>，对于p中第二个 <code>*</code> 来说，其前面的字母<code>c</code>满足这种情况，<code>c*</code>相当于匹配了0次c，相当于直接剔除 <code>c*</code>，是否匹配取决于<code>s = &quot;abb&quot;, p = &quot;ab*&quot;</code>。</li>
<li><strong><code>s[i] == p[j - 1] || p[j] == &#39;.&#39;</code></strong>，此时表示匹配上了，但是不知道匹配了几次。<ul>
<li><strong>匹配多次： <code>dp[i][j] = dp[i-1][j]</code></strong><br>例如：<code>s = &quot;abbb&quot;, p = &quot;ab*&quot;</code>，此时代表匹配了<code>3</code>次<code>b</code>。<br>和<code>s = &quot;abb&quot;, p = &quot;ab*</code>的匹配状态相同，继而又和<code>s = &quot;ab&quot;, p = &quot;ab*</code>的匹配状态相同。</li>
<li><strong>匹配一次：<code>dp[i][j] = dp[i][j - 1]</code></strong><br>例如：<code>s = &quot;ab&quot;, p = &quot;ab*&quot;</code>。若<code>s = &quot;ab&quot;, p = &quot;ab</code>匹配，那么它肯定也匹配。</li>
<li><strong>匹配零次：<code>dp[i][j] = dp[i][j - 2]</code></strong><br>例如：<code>s = &quot;ab&quot;, p = &quot;abc*&quot;</code>，对于<code>c</code>来说匹配了0次，那么<code>c*</code>就没有什么意义，也就可以剔除掉<code>c*</code>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>考虑边界值的问题。</strong><br>因为如果当 <code>i=0</code> 时，<code>dp[i][j] = dp[i - 1][j - 1]</code>就会数组越界。这里我们的处理办法是行和列各增加一个维度，即: <code>dp[m + 1][n + 1]</code>。<br>这时读者可能会有疑问，还有 <code>dp[j - 2]</code> 的情况呢，你这里只增加了 <code>1</code> ，<code>j = 0</code> 时仍然会数组越界啊？实际上我们观察步骤4，<code>dp[j - 2]</code>只出现在 <code>p[j] == &#39;*&#39;</code> 的情况下，而 <code>*</code> 不可能是 <code>p</code> 的首元素的。</p>
</li>
<li><p><strong>数组 <code>dp</code> 的初始化。</strong><br>我们只需要对<strong>第一列</strong>和<strong>第一行</strong>进行初始化即可，其他地方均赋值为 <code>false</code>。我们的行和列都比原来增加了1，我们可以假设在 <code>s</code> 和 <code>p</code> 前面都加了一个字符<code>&#39;#&#39;</code>。<br>例如 <code>s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;</code>，那么dp的第一行就是代表 <code>s[0]</code> 和 <code>p</code> 的前 <code>j</code> 个元素是否匹配。此时 <code>dp[0][0] = true</code>，因为 <code>s[0] = p[0] = &#39;#&#39;</code>。  </p>
<ol>
<li><p><strong>第一行的初始化：</strong><br>因为我们的 <code>p</code> 始终和 <code>&#39;#&#39;</code>进行匹配判断，并且 <code>p[0] = &#39;#&#39;</code> ，那么后面只要出现了 <code>&#39;*&#39;</code>，那它肯定匹配了0次；单独出现 <code>a-z</code> 或者 <code>&#39;.&#39;</code> 肯定无法与 <code>s[0] = &#39;#&#39;</code> 匹配，因为 <code>p</code> 首元素就是 <code>#</code>。</p>
</li>
<li><p><strong>第一列的初始化：</strong><br>例如 <code>s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;</code>，那么dp的第一行就是 <code>p[0]</code> 和 <code>s</code> 的前 <code>i</code> 个元素是否匹配。我们可以看出，只有 <code>p[0] = s[0] = &#39;#&#39;</code> 是匹配的，其他地方都不匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#&#39;</code> 匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#a&#39;</code> 不匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#ab&#39;</code> 也不匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#abb&#39;</code> 也不匹配。</p>
<p>下面举两个例子方便大家理解初始化规则，只需看第一列和第一行即可。<br><strong>初始化例子1：</strong><code>s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;</code>时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta"># a b * c *</span></span><br><span class="line"># <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">a <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化例子2：</strong><code>s = &quot;#abb&quot;, p = &quot;#a*b*c*&quot;</code>时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta"># a * b * c *</span></span><br><span class="line"># <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">a <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了98.13%的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了91.48%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line">        <span class="keyword">bool</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : dp)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : i)</span><br><span class="line">                j = <span class="literal">false</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>)</span><br><span class="line">                dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] != p[j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">'.'</span>)</span><br><span class="line">                        dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                         dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-解法三：有限状态自动机"><a href="#2-3-解法三：有限状态自动机" class="headerlink" title="2.3 解法三：有限状态自动机"></a>2.3 解法三：有限状态自动机</h3><p>没学过，日后再更。</p>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>dynamic-programming</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>9-回文数</title>
    <url>/2019/10/26/LeetCode/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">56.68%</td>
<td align="center">math</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 从左向右读, 为 <span class="number">-121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 从右向左读, 为 <span class="number">01</span> 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong><br>你能不将整数转为字符串来解决这个问题吗？</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li><p>我们将该数字翻转得到的数字和原数字相等，此时它就是回文数。</p>
</li>
<li><p>考虑翻转后会溢出的问题，我们设置翻转后的数字设置为long类型即可。</p>
</li>
<li><p>当然2中方法并不适用所有情况，我们可以使用以下方法判断.</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (reverse &gt; INT_MAX / <span class="number">10</span> || (reverse &gt;= INT_MAX &amp;&amp; (temp % <span class="number">10</span>) &gt; <span class="number">7</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了99.52%的用户<br>内存消耗: 7.9 MB, 在所有 cpp 提交中击败了95.45%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">long</span> reverse = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            reverse = reverse * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (reverse == x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><ol>
<li>我们没有必要将整个数字翻转，只需要将后一半数字反转，再与前一半的数字相比较即可。</li>
<li>例如1234321，后一半的数是321，翻转得到123，前一半的数是123，两者相等，则是回文数。  </li>
</ol>
<p><strong>需要注意奇回文数和偶回文数的处理。</strong></p>
<blockquote>
<p>执行用时: 16 ms, 在所有 cpp 提交中击败了75.83%的用户<br>内存消耗: 8.1 MB, 在所有 cpp 提交中击败了82.64%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            temp = temp /<span class="number">10</span>;</span><br><span class="line">            digit ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        left = x / <span class="built_in">pow</span>(<span class="number">10</span>, (digit + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; digit / <span class="number">2</span>; ++ i) &#123;</span><br><span class="line">            right = right * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left == right ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>8-字符串转换整数 (atoi)</title>
    <url>/2019/10/24/LeetCode/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">18.57%</td>
<td align="center">math / string</td>
<td align="center">amazon / bloomberg / microsoft / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>请你来实现一个<code>atoi</code>函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"42"</span></span><br><span class="line">输出: <span class="number">42</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"   -42"</span></span><br><span class="line">输出: <span class="number">-42</span></span><br><span class="line">解释: 第一个非空白字符为 <span class="string">'-'</span>, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 <span class="number">-42</span> 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"4193 with words"</span></span><br><span class="line">输出: <span class="number">4193</span></span><br><span class="line">解释: 转换截止于数字 <span class="string">'3'</span> ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="string">"words and 987"</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 第一个非空字符是 <span class="string">'w'</span>, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="string">"-91283472332"</span></span><br><span class="line">输出: <span class="number">-2147483648</span></span><br><span class="line">解释: 数字 <span class="string">"-91283472332"</span> 超过 <span class="number">32</span> 位有符号整数范围。</span><br><span class="line">     因此返回 INT_MIN (−<span class="number">231</span>) 。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li>先找出第一个非空字符的下标 <code>noSpaceIndex</code></li>
<li>判断正负性 <code>negative</code>，找出数字开始的下标 <code>startIndex</code></li>
<li>计算出当前下标的数字 <code>curDigit</code>，判断是否溢出</li>
<li>horner法则求出和。</li>
</ol>
<p><strong>需要注意的是溢出的处理办法：</strong><br><code>if (res &gt; INT_MAX/10 || (res &gt;= INT_MAX/10 &amp;&amp; curDigit &gt; 7))</code></p>
<ol>
<li>首先我们知道 <code>INT_MAX = 2^31 - 1 = 2147483647，INT_MIN = -2^31 = -2147483648;</code>，<code>res</code>是结果的绝对值。  </li>
<li>我们要理解为什么正负溢出对的处理方式相同。<br>举四个例子即可：2147483647，2147483648，-2147483647，-2147483648。<br>其中只有 <code>2147483648</code> 和 <code>-2147483648</code> 会判断成溢出，实际上 <code>-2147483648</code> 是没有溢出的，但是我们最终得到的结果都是<code>INT_MIN = -2147483648</code>，所以并无大碍。</li>
</ol>
<blockquote>
<p>执行用时 :4 ms, 在所有 cpp 提交中击败了93.61%的用户<br>内存消耗 :8.3 MB, 在所有 cpp 提交中击败了93.80%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curDigit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[startIndex] == <span class="string">' '</span>)</span><br><span class="line">            startIndex ++;</span><br><span class="line">        <span class="keyword">if</span> (str[startIndex] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            negative = <span class="literal">true</span>;</span><br><span class="line">            startIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[startIndex] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            startIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = startIndex;i &lt; str.size() &amp;&amp; <span class="built_in">isdigit</span>(str[i]); ++ i) &#123;</span><br><span class="line">            curDigit = str[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX/<span class="number">10</span> || (res &gt;= INT_MAX/<span class="number">10</span> &amp;&amp; curDigit &gt; <span class="number">7</span>))</span><br><span class="line">                <span class="keyword">return</span> (negative ? INT_MIN : INT_MAX);</span><br><span class="line">            res = res * <span class="number">10</span> + curDigit;</span><br><span class="line">            <span class="comment">// res = res * 10 - 48 + static_cast&lt;int&gt;(str[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (negative ? -res : res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>7-整数反转</title>
    <url>/2019/10/22/LeetCode/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">33.23%</td>
<td align="center">math</td>
<td align="center">apple / bloomberg</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">-123</span></span><br><span class="line">输出: <span class="number">-321</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong><br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>利用求余，求出<em>从后往前</em>每一位的值。<br>再利用horner法则(多项式求值)，令X=10求出翻转后的值。</p>
<blockquote>
<p>执行用时: 0 ms, 在所有 cpp 提交中击败了100%的用户<br>内存消耗: 8 MB, 在所有 cpp 提交中击败了93.37%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remainder;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            remainder = x % <span class="number">10</span>;</span><br><span class="line">            x = (x - remainder) / <span class="number">10</span>;</span><br><span class="line">            res = <span class="number">10</span> * res + remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN || res &gt; INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>6-Z字形变换</title>
    <url>/2019/10/21/LeetCode/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">45.35%</td>
<td align="center">string</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行<strong>Z</strong>字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：<br>string convert(string s, int numRows);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: s = <span class="string">"LEETCODEISHIRING"</span>, numRows = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"LCIRETOESIIGEDHN"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: s = <span class="string">"LEETCODEISHIRING"</span>, numRows = <span class="number">4</span></span><br><span class="line">输出: <span class="string">"LDREOEIIECIHNTSG"</span></span><br><span class="line">解释:</span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zigzag-conversion</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>按每行从左到右依次输出。<br>以示例2为例，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L     D      R</span><br><span class="line">E   O E    I I</span><br><span class="line">E C   I  H   N</span><br><span class="line">T     S      G</span><br><span class="line">对应的下标如下：</span><br><span class="line"><span class="number">0</span>     <span class="number">6</span>      <span class="number">12</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span> <span class="number">7</span>   <span class="number">11</span> <span class="number">13</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span>   <span class="number">8</span> <span class="number">10</span>   <span class="number">14</span></span><br><span class="line"><span class="number">3</span>     <span class="number">9</span>      <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>我们的任务是找出每一行的下标。  </p>
<ol>
<li>对于第一行和最后一行来说，它只有3个数，而其他行是它的二倍，有6个数。</li>
<li>我们以下标0-5为第一组，6-11为第二组，以此类推，每6个数一组，不足6个数的也算作一组。</li>
<li>6是怎么求的呢？<code>k = 2 * (numRows - 1) = 2*(4-1) = 6</code></li>
<li>一共有多少组呢？<code>loopNum = (n + k - 1) / k;(n为s的长度)</code>，注意：不足k个的也算作一组。</li>
<li>对于第一行和最后一行来说，初值为i（<code>start1 = i</code>），我们只需要每次循环加上k即可。</li>
<li>对于其他行，我们每组有两个数。前一个数和步骤5中一样，初值为i（<code>start1 = i</code>）；第二个数的初值是关键，<code>start2 = start1 + (numRows-(i+1))*2</code>；每次循环都加上k即可，循环总次数为numRows。</li>
</ol>
<blockquote>
<p>执行用时 :8 ms, 在所有 cpp 提交中击败了97.82%的用户<br>内存消耗 :10.3 MB, 在所有 cpp 提交中击败了88.53%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span> * (numRows - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> loopNum = (n + k - <span class="number">1</span>) / k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numRows; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> start1 = i;</span><br><span class="line">            <span class="keyword">int</span> start2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != (numRows <span class="number">-1</span>))</span><br><span class="line">                start2 = start1 + (numRows-(i+<span class="number">1</span>))*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; loopNum; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start1 &lt; n) &#123;</span><br><span class="line">                    str += s[start1];</span><br><span class="line">                    start1 += k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != (numRows <span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (start2 &lt; n) &#123;</span><br><span class="line">                        str += s[start2];</span><br><span class="line">                        start2 += k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (start1 &gt;= n &amp;&amp; start2 &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/zigzag-conversion/comments/44833/" target="_blank" rel="noopener">麓山南路飞行员</a>  </p>
</blockquote>
<p>主要思想就是：一共有numRows行，找出每个字符所在的行数，依次添加到该行。<br>关键代码<code>int row = i % k &lt; numRows ? i % k : k - i % k;</code></p>
<p>以示例2为例，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L     D      R</span><br><span class="line">E   O E    I I</span><br><span class="line">E C   I  H   N</span><br><span class="line">T     S      G</span><br><span class="line">对应的下标如下：    行数：</span><br><span class="line"><span class="number">0</span>     <span class="number">6</span>      <span class="number">12</span>     <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span> <span class="number">7</span>   <span class="number">11</span> <span class="number">13</span>     <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span>   <span class="number">8</span> <span class="number">10</span>   <span class="number">14</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">9</span>      <span class="number">15</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>易知<code>k = 6, numsRows = 4</code>，我们以下标0-5为例。第一种情况是下标0-3，第二种情况是下标4-5，这两种情况区分的标志是<code>i % k &lt; numRows</code>。</p>
<p>很容易知道第一种情况的行数为<code>i % k</code>；第二种情况，对于5来说，<code>row = 1 = 6 - 5</code>；对于11来说，<code>row = 1 = 6 - 11...</code>，11怎么才能变成5呢，当然是对6取余啦。所以第二种情况行数为<code>k - i % k</code>。</p>
<blockquote>
<p>执行用时 :20 ms, 在所有 cpp 提交中击败了58.47%的用户<br>内存消耗 :12.7 MB, 在所有 cpp 提交中击败了78.71%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span> * (numRows - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = i % k &lt; numRows ? i % k : k - i % k;</span><br><span class="line">            res[row] += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : res)</span><br><span class="line">            str += i;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>5-最长回文子串</title>
    <url>/2019/10/21/LeetCode/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Hard</td>
<td align="center">36.29%</td>
<td align="center">string / dynamic-programming</td>
<td align="center">amazon / bloomberg / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。你可以假设<code>s</code>的最大长度为 1000。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">windliang</a></p>
</blockquote>
<h3 id="2-1-解法一：最长共同子串-动态规划法"><a href="#2-1-解法一：最长共同子串-动态规划法" class="headerlink" title="2.1 解法一：最长共同子串(动态规划法)"></a>2.1 解法一：最长共同子串(动态规划法)</h3><h4 id="2-1-1-为什么用可以最长共同子串？"><a href="#2-1-1-为什么用可以最长共同子串？" class="headerlink" title="2.1.1 为什么用可以最长共同子串？"></a>2.1.1 为什么用可以最长共同子串？</h4><ol>
<li>假设s2是s1的逆序字符串。  </li>
<li>若s1中有回文子串，则s1和s2中一定有相同的该子串。<br>例如：<code>s1 = &quot;afbcbfae&quot;</code>, 则<code>s2 = &quot;eafbcbfa&quot;</code>,那么<code>fbcbf</code>就是它俩的共同最长子串，也是s1的最长回文子串。  </li>
<li>不过需要注意一些特例：<code>s1 = &quot;abc123cba&quot;</code>, 则<code>s2 = &quot;abc321cba&quot;</code>;我们发现它俩有两个共同子串<code>abc</code>和<code>bca</code>，但是这两个都不是回文子串。</li>
<li>对于3中的情况，我们需要加一步判断来解决该问题。即s1中<code>abc</code>和s2中<code>abc</code>他们的下标是否对应。对于s2中子串<code>abc</code>来讲，其中<code>a</code>在s1逆置之前的下标应该是8(即:<code>s1.size() - 1</code>)。通用的说法就是，当<code>s2[j] == s[i]</code>时，设s2中的该字符c在s2中的下标为j，它在逆置之前，在s1中的下标为jBefore，那么<code>jBefore = s1.size() - 1 - j</code>，此时s1中下标为i，d[i][j]是该回文串的长度，那么就必须满足<code>i = jBefore + d[i][j] - 1</code>。那么我们可以推断出，当<code>s1[i] == s[j]</code>时，只要满足该条件，那么就是回文子串。</li>
</ol>
<h4 id="2-1-2-动态规划法"><a href="#2-1-2-动态规划法" class="headerlink" title="2.1.2 动态规划法"></a>2.1.2 动态规划法</h4><ol>
<li><p>我们设置一个二维<code>n*n</code>数组<code>d</code>表示两个字符串每个字符相等的关系。（字符串长度为n）</p>
</li>
<li><p>若<code>s1[i] == s[j]</code>，则<code>d[i][j] = d[i-1][j-1] + 1</code>。当<code>i=0</code>或者<code>j=0</code>时，上述公式会越界。所以我们直接令<code>d[i][j] = 1</code>。</p>
</li>
<li><p>例如<code>s1 = &quot;afbcbfae&quot;</code>，那么d为</p>
<table>
<thead>
<tr>
<th align="center">s1\s2</th>
<th align="center">e</th>
<th align="center">a</th>
<th align="center">f</th>
<th align="center">b</th>
<th align="center">c</th>
<th align="center">b</th>
<th align="center">f</th>
<th align="center">a</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>a</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>f</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>c</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>f</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>a</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center"><strong>e</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p> 我们只需记录下d中最大数对应的下标即可。<br> 我们观察到<code>d[2][3]=3</code>(行为i，列为j)，此时<code>j = 3, jBefroe = 8-1-3 = 4; i = 2而jBefore + d[i][j] - 1 = 4+3-1 = 6</code>,所以此时不是回文子串。<br> 再看<code>d[6][7]=7</code>，此时<code>j = 7, jBefroe = 8-1-7 = 0; i = 6而jBefore + d[i][j] - 1 = 0+7-1 = 6</code>,所以此时是回文子串。  </p>
</li>
<li><p>对于<code>s1 = &quot;abc123cba&quot;</code>来说，d为</p>
<table>
<thead>
<tr>
<th align="center">s1\s2</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">c</th>
<th align="center">b</th>
<th align="center">a</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>a</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>c</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>c</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>a</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p> 我们观察到<code>d[2][2]=3</code>(行为i，列为j)，此时<code>j = 2, jBefroe = 9-1-2 = 6; i=2而jBefore + d[i][j] - 1 = 6+3-1 = 7</code>,所以此时不是回文子串。<br> 再看<code>d[8][8]=3</code>，此时<code>j = 8, jBefroe = 9-1-8 = 0; i = 8而jBefore + d[i][j] - 1 = 0+3-1 = 2</code>,所以此时也不是回文子串。</p>
</li>
</ol>
<blockquote>
<p>执行用时 :320 ms, 在所有 cpp 提交中击败了22.88%的用户<br>内存消耗 :13.3 MB, 在所有 cpp 提交中击败了47.92%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n^2),空间复杂度O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> s1 = s;</span><br><span class="line">        reverse(s1.begin(), s1.end());</span><br><span class="line">        <span class="keyword">int</span> d[n][n];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s1[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                        d[i][j] = d[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        d[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; maxLen) &#123;</span><br><span class="line">                    <span class="keyword">int</span> jBeforeReverse = n - <span class="number">1</span> - j;</span><br><span class="line">                    <span class="keyword">if</span> (jBeforeReverse + d[i][j] - <span class="number">1</span> == i) &#123;</span><br><span class="line">                        maxLen = d[i][j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxEnd - maxLen + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2解法二：最长共同子串-改进"><a href="#2-2解法二：最长共同子串-改进" class="headerlink" title="2.2解法二：最长共同子串(改进)"></a>2.2解法二：最长共同子串(改进)</h3><p>在解法一中我们使用了二维数组，实际上使用一维数组也可以解决。<br>解法一中，当i=0时，我们计算出j=1…n的值，i=1时，我们又根据前一列计算出这一列的j=1…n的值。实际上，我们计算某一列的值时，只需要使用它的左上角的元素（<code>d[i][j] = d[i-1][j-1] + 1</code>），即前一列的信息。  </p>
<p>我们规定若<code>s1[i] == s[j]</code>，则<code>d[j] = d[j-1] + 1</code>。当<code>j=0</code>时，上述公式会越界。所以我们直接令<code>d[j] = 1</code>。  </p>
<p><strong>但是我们必须要注意到如下的问题：</strong><br>假设<code>i=0</code>时，我们已经求出一组d的值，当<code>i=1</code>时，如果我们j从0——n来循环，那么<br>比如求出<code>d[1] = d[0] + 1</code>（此时<code>d[0]</code>还是上一次的信息）。我们再求<code>d[2] = d[1] + 1</code>，但这时<code>d[1]</code>的值已经被修改了，不是<code>i=0</code>时的值了。<br>所以我们的j必须从n——0来循环。</p>
<blockquote>
<p>执行用时 :268 ms, 在所有 cpp 提交中击败了28.68%的用户<br>内存消耗 :8.7 MB, 在所有 cpp 提交中击败了96.28%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> s1 = s;</span><br><span class="line">        reverse(s1.begin(), s1.end());</span><br><span class="line">        <span class="keyword">int</span> d[n];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; -- j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s1[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                        d[j] = d[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        d[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    d[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d[j] &gt; maxLen) &#123;</span><br><span class="line">                    <span class="keyword">int</span> jBeforeReverse = n - <span class="number">1</span> - j;</span><br><span class="line">                    <span class="keyword">if</span> (jBeforeReverse + d[j] - <span class="number">1</span> == i) &#123;</span><br><span class="line">                        maxLen = d[j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxEnd - maxLen + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-解法三：中心拓展法"><a href="#2-3-解法三：中心拓展法" class="headerlink" title="2.3 解法三：中心拓展法"></a>2.3 解法三：中心拓展法</h3><p>核心思想就是指定一个中心元素，分别比较两侧的元素是否相等。<br>当然我们会遇到奇数个或偶数个的回文子串。<br>对于奇数个的，我们指定一个中心元素；对于偶数个的，我们指定两个中心元素；然后向两侧拓展比较。</p>
<blockquote>
<p>执行用时 :20 ms, 在所有 cpp 提交中击败了90.24%的用户<br>内存消耗 :8.7 MB, 在所有 cpp 提交中击败了96.28%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n^2),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandFromCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandFromCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">                maxLen = len;</span><br><span class="line">                start = i - (len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandFromCenter</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left --;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次到循环最后，left多减了1，right多加了1</span></span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-解法四：Manacher’s-Algorithm-马拉车算法"><a href="#2-4-解法四：Manacher’s-Algorithm-马拉车算法" class="headerlink" title="2.4 解法四：Manacher’s Algorithm 马拉车算法"></a>2.4 解法四：Manacher’s Algorithm 马拉车算法</h3><p>好复杂，日后再更。</p>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>4-寻找两个有序数组的中位数</title>
    <url>/2019/10/19/LeetCode/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Hard</td>
<td align="center">36.29%</td>
<td align="center">array / binary-search / divide-and-conquer</td>
<td align="center">adobe / apple / dropbox / google / microsoft / yahoo / zenefits</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 <strong>O(log(m + n))</strong>。<br>你可以假设 nums1 和 nums2 不会同时为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:  </span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]  </span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:  </span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">则中位数是 (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：归并排序"><a href="#2-1-解法一：归并排序" class="headerlink" title="2.1 解法一：归并排序"></a>2.1 解法一：归并排序</h3><p>将两个数组进行归并排序，从小到大依次存入vector中。取中位数即可。</p>
<blockquote>
<p>执行用时: 24 ms, 在所有 cpp 提交中击败了76.59%的用户<br>内存消耗: 11.3 MB, 在所有 cpp 提交中击败了72.07%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i1 != nums1.size() &amp;&amp; i2 != nums2.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i1] &lt;= nums2[i2]) &#123;</span><br><span class="line">                v.push_back(nums1[i1]);</span><br><span class="line">                ++ i1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v.push_back(nums2[i2]);</span><br><span class="line">                ++ i2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i1 != nums1.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i1; i1 &lt; nums1.size(); ++ i1)</span><br><span class="line">                v.push_back(nums1[i1]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i2; i2 &lt; nums2.size(); ++ i2)</span><br><span class="line">                v.push_back(nums2[i2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((nums1.size() + nums2.size())%<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> v[(nums1.size() + nums2.size())/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (v[(nums1.size() + nums2.size())/<span class="number">2</span>] + v[(nums1.size() + nums2.size())/<span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：递归二分法"><a href="#2-2-解法二：递归二分法" class="headerlink" title="2.2 解法二：递归二分法"></a>2.2 解法二：递归二分法</h3><ol>
<li>题目要求复杂度为O(log(m+n))，所以肯定要使用二分法。</li>
<li>同时我们可以将题目转化为求第k个最小数，即<code>k=(m+n)/2</code>；</li>
<li>对两个序列的第<code>k/2</code>个值进行比较，若<code>nums1[k] &gt; nums2[k]</code>，则nums2的前<code>k/2</code>个数中肯定没有我们要求的第k个最小数。我们将前nums2中前k/2个数剔除。</li>
<li>对新序列的nums1和nums2继续进行求第<code>k1(此时k1=k-k/2)</code>个最小数。</li>
<li>当然我们会遇到一些特殊情况，比如某序列太短，例如<code>(nums1.size() &lt; nums2.size())</code>，此时肯定是nums1可能会出现没有第k/2个数（nums2不会出现这种情况），此时替换为该序列的最后一个值即可。为了简化代码，如果<code>(nums1.size() &gt; nums2.size())</code>，我们就递归函数getKthElem重新传参，将参数调换（即nums1 &lt;-&gt; nums2等）。</li>
<li>由此产生的另外一种需要考虑的问题是，<strong>步骤4中的<code>k1=k-k/2</code>是否完全正确？我们每次剔除的元素该不该是k/2个？</strong> 当然不一定，因为有的序列可能没有那么多元素，这时我们需要令<code>k=k-我们剔除的数</code>，即：<code>k=k-min(k/2,len)</code>。在代码中我们不能将 <strong>min函数</strong> 作为一个参数，因为我们定义了<code>int i = start1 + min(k / 2, len1) - 1</code>, 在实际代码中我们使用<code>(j - start2 + 1)</code>来替代它。</li>
<li>那么问题来了，<strong>6中这种替换是正确的吗？</strong> 其实这种替换是无妨的，因为们剔除的元素始终小于k/2个，当<code>len &lt; k/2</code>时，剔除了len个元素，我们此时只是不是严格的二分了。我们每次少剔除几个元素在逻辑上是没有问题的（当然多的话就会有问题），<strong>因为在k/2前的这几个元素肯定不是我们要找的第k个最小数</strong>。</li>
<li><strong>递归函数什么时候结束呢？</strong> 两种情况：一是某个序列的长度变为了0，那么我们只需在另一个序列中找第k个最小数即可；二是<code>k=1</code>时，此时找的是两个序列的第1个最小值，那么就是两个序列第一个元素较小的那个。</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了99.98%的用户<br>内存消耗: 9.7 MB, 在所有 cpp 提交中击败了86.47%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> k = (m + n) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (getKthElem(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, k) + getKthElem(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, k + <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElem</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line">        <span class="keyword">int</span> i = start1 + min(k / <span class="number">2</span>, len1) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + min(k / <span class="number">2</span>, len2) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j])</span><br><span class="line">            <span class="comment">// 注意：(j - start2 + 1) = min(k / 2, len1)</span></span><br><span class="line">            <span class="comment">// 但是我们不能将min函数作为参数。</span></span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>divide-and-conquer</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>3-无重复字符的最长子串</title>
    <url>/2019/10/17/LeetCode/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">36.10%</td>
<td align="center">hash-table / two-pointers / string / sliding-window</td>
<td align="center">adobe / amazon / bloomberg / yelp</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是**子串**的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><h4 id="2-1-1-滑动窗口法："><a href="#2-1-1-滑动窗口法：" class="headerlink" title="2.1.1 滑动窗口法："></a>2.1.1 <strong>滑动窗口法：</strong></h4><p>我们依次将每个字符及其下标（从1开始，最后会解释为什么从1）存进map中。当遇到某个重复的字符 <code>ch</code> 时<strong>并且</strong> <code>m[s[i]] &gt;= left</code>，就把 <code>left</code> 设置为前一个与他重复的 <code>ch</code> 的value值加1，此时 <code>(i-left+1)</code>（i从0开始）就是上一个无重复子串的长度。<br>例如：<strong>jbpnbwwe</strong></p>
<ol>
<li><code>i=0, s[i]=&#39;j&#39;, left=1, m[&#39;j&#39;]=0</code> (因为m中没有‘j’),所以将 <code>m[&#39;j&#39;] = i+1 = 1</code>存入map。</li>
<li>同理 <code>&#39;b&#39;, &#39;p&#39;, &#39;n&#39;</code> 都是插入map中。</li>
<li>此时 <code>i=4, s[i]=&#39;b&#39;, left=1, m[&#39;b&#39;]=2 &gt; left</code> ; 此时无重复子串长度为4 <code>(&quot;jbpn&quot;)</code>, <code>left</code> 值变为 <code>&#39;b&#39;</code> 的下一位的下标值即5; 同时更新 <code>m[&#39;b&#39;]</code> 的值为5。</li>
<li>往后同理。</li>
</ol>
<h4 id="2-2-2-为什么-m-s-i-gt-left，而不是-m-s-i-gt-left"><a href="#2-2-2-为什么-m-s-i-gt-left，而不是-m-s-i-gt-left" class="headerlink" title="2.2.2 为什么 m[s[i]] &gt;= left，而不是 m[s[i]] &gt; left"></a>2.2.2 为什么 <code>m[s[i]] &gt;= left</code>，而不是 <code>m[s[i]] &gt; left</code></h4><p>考虑如果当前 <code>left</code> 所对应的字符就是下一次重复的字符。<br>极端情况例如 <code>&quot;abbbbb&quot;</code>。</p>
<h4 id="2-2-3-为什么-m-s-i-i-1-，而不直接等于-i？left为什么初值为1"><a href="#2-2-3-为什么-m-s-i-i-1-，而不直接等于-i？left为什么初值为1" class="headerlink" title="2.2.3 为什么 m[s[i]] = i + 1 ，而不直接等于 i？left为什么初值为1"></a>2.2.3 为什么 <code>m[s[i]] = i + 1</code> ，而不直接等于 <code>i</code>？<code>left</code>为什么初值为1</h4><p>考虑极端情况。<br>例如：只有一个字母 <code>a</code>（或者是无重复字符串 <code>&quot;abcd&quot;</code>）<br>假如 <code>left=0</code>，那么就会进入if语句中，<code>left</code> 会加1，而我们并没有重复的字符，<code>left</code> 不应该加1。<br>主要就是因为map中，如果没有元素c，那么 <code>m[c]</code> 会返回0。</p>
<blockquote>
<p>执行用时 :16 ms, 在所有 cpp 提交中击败了75.44%的用户<br>内存消耗 :10.8 MB, 在所有 cpp 提交中击败了79.63%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在不需要排序功能的情况下，建议使用unordered_map，它比map快。</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; s.size(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[s[i]] &gt;= left) &#123;</span><br><span class="line">                max = (max &gt; (i-left+<span class="number">1</span>) ? max : (i-left+<span class="number">1</span>));</span><br><span class="line">                left = m[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符s[i]对应的位置为i+1,因为map不存在该元素时会返回0；</span></span><br><span class="line">            m[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可能出现一种情况：整个字符串没有重复的，就需要如下代码。</span></span><br><span class="line">        max = (max &gt; (s.size()-left+<span class="number">1</span>) ? max : (s.size()-left+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>hash-table</tag>
        <tag>string</tag>
        <tag>two-pointers</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>2-两数相加</title>
    <url>/2019/10/16/LeetCode/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">46.90%</td>
<td align="center">linked-list / math</td>
<td align="center">adobe / airbnb / amazon / bloomberg / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>例如<br>(2 -&gt; 4 -&gt; 3) +<br>(5 -&gt; 6 -&gt; 4 -&gt; 2)<br>新建一个链表h，用于存储每一步相加的结果。<br>首先循环内的条件为l1 || l2，即l1或l2有一个不为空时。<br>对于l1和l2，如果没有到达尾部，则链表指向下一个（next），并且sum加上其值；如果某链表到达尾部之后（即为NULL时），链表则不动，也不再加上该链表的值。<br>将对应位置两个数相加，如果&gt;=10，进位标志(carry)为true。此时下一次循环的sum要额外加1。<br>循环结束后，如果最后两个数字相加&gt;=10（即carry==true），则还要增加一个节点，值为1。<br><strong>注意</strong>：我们并没有使用h的头结点，我们先是令其指向next，再赋值。主要是考虑最后一次循环，不这样的话会创建一个新的无用的节点。<br>最后我们释放掉无用的头结点，因为如果调用次数多会溢出。</p>
<blockquote>
<p>执行用时：28 ms, 在所有 cpp 提交中击败了91.26%的用户<br>内存消耗：10.3 MB, 在所有 cpp 提交中击败了84.73%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">//头结点，不保存任何信息</span></span><br><span class="line">        ListNode *h = head;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (carry)</span><br><span class="line">                sum ++;</span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放头结点（初始创建的val = -1 的节点），c++要手动释放，否则调用次数多会溢出</span></span><br><span class="line">        ListNode *ptrDelete = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">        <span class="comment">// 参考https://leetcode-cn.com/u/chenlele/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>1-两数之和</title>
    <url>/2019/10/15/LeetCode/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">46.90%</td>
<td align="center">array / hash-table</td>
<td align="center">adobe / airbnb / amazon / apple / bloomberg / dropbox / facebook /  linkedin / microsoft / uber / yahoo / yelp</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找 出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>  </span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>  </span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>例如：nums = [1, 2, 3, 7, 11, 15], target = 9。<br>2和7是答案，对于7或者2(此例7在后面，所以是对于7)来说，在它前面的元素中必定有另一个答案。<br>所以我们将每个元素及其前面的元素都加入map中，遍历到下一个元素时就可以判断另一个答案在不在map中。</p>
<blockquote>
<p>执行用时: 12 ms, 在所有 cpp 提交中击败了92.01%的用户<br>内存消耗: 10.5 MB, 在所有 cpp 提交中击败了13.80%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复杂度为O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> another;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nums.size(); ++ i) &#123;</span><br><span class="line">            another = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.find(another) != m.end()) &#123;</span><br><span class="line">                res.push_back(m[another]);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>记录LaTeX遇到的问题(持续更新...)</title>
    <url>/2019/01/21/other/%E8%AE%B0%E5%BD%95LaTeX%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...)/</url>
    <content><![CDATA[<p>用于记录使用 $\LaTeX$ 过程中遇到的问题，有以下几大方面：</p>
<ol>
<li>脚注</li>
<li>段落缩进</li>
<li>数学公式</li>
<li>图表</li>
<li>页面总体设计</li>
<li>插入代码</li>
<li>正文</li>
<li>列表</li>
<li>表格</li>
<li>参考文献<a id="more"></a>
<blockquote>
<p>@Author：CSU张扬<br>@Email：<a href="mailto:csuzhangyang@gmail.com" target="_blank" rel="noopener">csuzhangyang@gmail.com</a> or <a href="mailto:csuzhangyang@qq.com" target="_blank" rel="noopener">csuzhangyang@qq.com</a></p>
</blockquote>
</li>
</ol>
<h2 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h2><ol>
<li><p>对于在标题(section)中加脚注，要在\footnote前加上\protect。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\section&#123;语音信号的数字水印技术（LSB算法\protect\footnote&#123;即LeastSignificant Bits（最低有效位）算法。&#125;）&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果出现脚注计数不从1开始，可以在代码前加上命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\setcounter&#123;footnote&#125;&#123;0&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除目录中出现的脚注：中括号内放入目录（即标题）显示的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\section[语音信号的数字水印技术（LSB算法）]&#123;语音信号的数字水印技术（LSB算法\protect\footnote&#123;即LeastSignificant Bits（最低有效位）算法&#125;）&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="段落缩进"><a href="#段落缩进" class="headerlink" title="段落缩进"></a>段落缩进</h2><ol>
<li><p>强制缩进，在开头加上以下命令：（em是当前文字的宽度）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\hspace*&#123;2em&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ol>
<li><p>阴影盒子不加gather环境如何居中。前后加上$$即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\shadowbox&#123;$Y(k)=\frac&#123;1&#125;&#123;2&#125;\left(X(k+\omega\pi)+X(k-\omega\pi)\right)$&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行公式显示(加*表示不编号，不加则编号)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation*&#125;</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line">f&apos;(n) &amp;= f(n)+\sum_&#123;n=0&#125;^&#123;N－1&#125;g(k)W(k)cos[\frac &#123;(2n + 1)k\pi &#125;&#123;2N&#125;]\\</span><br><span class="line">      &amp;= f(n)+w(n,k)</span><br><span class="line"> \end&#123;split&#125;</span><br><span class="line"> \end&#123;equation*&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><ol>
<li><p>修改图表的图1，图2，变成按章节的图1.1，图2.2等。. 改成 - 可以显示成 图1-1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\renewcommand &#123;\thetable&#125; &#123;\thesection&#123;&#125;.\arabic&#123;table&#125;&#125;</span><br><span class="line">\renewcommand &#123;\thefigure&#125; &#123;\thesection&#123;&#125;.\arabic&#123;figure&#125;&#125;</span><br><span class="line">% 每一章都要手动清零</span><br><span class="line">\setcounter&#123;table&#125;&#123;0&#125;</span><br><span class="line">\setcounter&#123;figure&#125;&#123;0&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="页面总体设计"><a href="#页面总体设计" class="headerlink" title="页面总体设计"></a>页面总体设计</h2><ol>
<li><p>调节页边距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;geometry&#125;</span><br><span class="line">%\geometry&#123;a4paper,left=2.54cm,right=2.54cm,top=3.18cm,bottom=3.18cm&#125;</span><br><span class="line">% 中等</span><br><span class="line">\geometry&#123;a4paper,left=2.54cm,right=2.54cm,top=1.91cm,bottom=1.91cm&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页眉和页脚（加在导言区）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;fancyhdr&#125;</span><br><span class="line">\usepackage&#123;lastpage&#125;</span><br><span class="line">\pagestyle&#123;fancy&#125;</span><br><span class="line">\fancyhf&#123;&#125;</span><br><span class="line">\fancyhead[C]&#123;\leftmark&#125;</span><br><span class="line">\fancyfoot[C]&#123;Page \thepage\ of \pageref&#123;LastPage&#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><ol>
<li><p>代码字体、大小控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage&#123;fontspec&#125;</span><br><span class="line">\newfontfamily\consolas&#123;Consolas&#125;</span><br><span class="line">\lstset&#123;numbers=left,language=Matlab,basicstyle=\footnotesize\consolas,numberstyle=\footnotesize,tabsize=2, keywordstyle= \color&#123;blue!70&#125;,frame=shadowbox, rulesepcolor= \color&#123;red!20!green!20!blue!20&#125; &#125; 	%插入代码的格式（序号位置，语言，代码字体大小、字体名称，序号字体大小，缩进，关键词颜色，阴影）</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol>
<li><p>局部文字 使用某种字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage&#123;fontspec&#125;</span><br><span class="line">\newfontfamily\consolas&#123;Consolas&#125;</span><br><span class="line">\newfontfamily\monaco&#123;Monaco&#125;</span><br><span class="line"></span><br><span class="line">%正文区</span><br><span class="line">&#123;\consolas def choosesave()&#125;</span><br><span class="line">&#123;\monaco def choosesave()&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制空行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 强制空行1cm</span><br><span class="line">\vspace&#123;1cm&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li><p>列表带圈数字可以增加到二位数<a href="https://liam0205.me/2014/05/08/latex-circled-numbers/" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;enumitem&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;etoolbox&#125;</span><br><span class="line">% line width可以调整圈的粗细，inner sep调节圈的大小(可以为负数)。</span><br><span class="line">\newcommand&#123;\circled&#125;[2][]&#123;\tikz[baseline=(char.base),line width = 0.7pt]</span><br><span class="line">    &#123;\node[shape = circle, draw, inner sep = 1pt]</span><br><span class="line">    (char) &#123;\phantom&#123;\ifblank&#123;#1&#125;&#123;#2&#125;&#123;#1&#125;&#125;&#125;;%</span><br><span class="line">    \node at (char.center) &#123;\makebox[0pt][c]&#123;#2&#125;&#125;;&#125;&#125;</span><br><span class="line">\robustify&#123;\circled&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\newcommand&#123;\dcircled&#125;[1]&#123;\circled[00]&#123;#1&#125;&#125;</span><br><span class="line">\begin&#123;enumerate&#125;[label=\dcircled&#123;\arabic*&#125;, noitemsep]</span><br><span class="line">\item I</span><br><span class="line">\item am</span><br><span class="line">\item happy</span><br><span class="line">\item to</span><br><span class="line">\item join</span><br><span class="line">\item with</span><br><span class="line">\item you</span><br><span class="line">\item today</span><br><span class="line">\item in</span><br><span class="line">\item what</span><br><span class="line">\item will</span><br><span class="line">\item go</span><br><span class="line">\item down</span><br><span class="line">\item in</span><br><span class="line">\item history</span><br><span class="line">\item as</span><br><span class="line">\item the</span><br><span class="line">\item greatest</span><br><span class="line">\item demonstration</span><br><span class="line">\item for</span><br><span class="line">\item freedom</span><br><span class="line">\item in</span><br><span class="line">\item the</span><br><span class="line">\item history</span><br><span class="line">\item of</span><br><span class="line">\item our</span><br><span class="line">\item nation.</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表编号加上颜色（创建一个新环境即可）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newenvironment&#123;colorlist&#125;[1]&#123;\begin&#123;list&#125;&#123;\textcolor&#123;blue&#125;&#123;\ding&#123;#1&#125;&#125;&#125;&#123;&#125;&#125;</span><br><span class="line">&#123;\end&#123;list&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;colorlist&#125;&#123;42&#125;</span><br><span class="line">\item</span><br><span class="line">\item</span><br><span class="line">\end&#123;colorlist&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表变为数字或字母</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;enumerate&#125;</span><br><span class="line">\begin&#123;enumerate&#125;[(i)]</span><br><span class="line">\item Xidian</span><br><span class="line">\item Computer</span><br><span class="line">\item Application</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line">% 可以使用 A，a，I，i，1 作为可选项产生 \Alph，\alph，\Roman，\roman，\arabic 的效果。</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表编号开始值，设置为任意数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">    % 对于数字编号</span><br><span class="line">    \begin&#123;enumerate&#125;</span><br><span class="line">    \addtocounter&#123;enumi&#125;&#123;41&#125;</span><br><span class="line">        \item This item is numbered `42.&apos;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">    % 对于字母编号</span><br><span class="line">    \begin&#123;enumerate&#125;[(a)]</span><br><span class="line">    \addtocounter&#123;enumi&#125;&#123;5&#125;% This cannot be more than 25</span><br><span class="line">        \item This one is ``numbered&apos;&apos; `(f)&apos;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">\end&#123;document&#125;</span><br><span class="line"></span><br><span class="line">% （如果您有更深层次的嵌套列表，相关的计数器是enumii，enumiii和enumiv。）</span><br><span class="line">% 双层嵌套</span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">    % 对于数字编号</span><br><span class="line">    \begin&#123;enumerate&#125;</span><br><span class="line">    \addtocounter&#123;enumi&#125;&#123;41&#125;</span><br><span class="line">        \item This item is numbered `42.&apos;</span><br><span class="line">    % 对于字母编号</span><br><span class="line">    \begin&#123;enumerate&#125;[(a)]</span><br><span class="line">    \addtocounter&#123;enumii&#125;&#123;5&#125;% This cannot be more than 25</span><br><span class="line">        \item This one is ``numbered&apos;&apos; `(f)&apos;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表之间的行距缩小：导言区加入如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;enumitem&#125;</span><br><span class="line">\setenumerate[1]&#123;itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt&#125;</span><br><span class="line">\setitemize[1]&#123;itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt&#125;</span><br><span class="line">\setdescription&#123;itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol>
<li><p>表格不同的列使用不同的字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;&gt;&#123;\heiti&#125;r &gt;&#123;\kaishu&#125;l&#125;</span><br><span class="line">黑体 &amp; 楷体</span><br><span class="line">还是黑体 &amp; 还是楷体</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格不同的列使用不同的字号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;&gt;&#123;\small&#125;r &gt;&#123;\Huge&#125;l&#125;</span><br><span class="line">小 &amp; 大</span><br><span class="line">小小 &amp; 大大</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格设置文字两端对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;&gt;&#123;\heiti&#125;r &gt;&#123;\kaishu&#125;l&#125;</span><br><span class="line">% 两端对齐，用4em是因为有最多四个字，根据实际情况修改该值。</span><br><span class="line">  \makebox[4em][s]&#123;课\hspace&#123;\fill&#125;程&#125;：&amp; 微机原理与接口技术\\</span><br><span class="line">  \makebox[4em][s]&#123;学生姓名&#125;：          &amp; 神奇海螺\\</span><br><span class="line">  \makebox[4em][s]&#123;三\hspace&#123;\fill&#125;个\hspace&#123;\fill&#125;字&#125;：          &amp; 杨老师\\</span><br><span class="line">  \makebox[4em][s]&#123;学\hspace&#123;\fill&#125;院&#125;：&amp; 信息科学与工程学院\\</span><br><span class="line">  \end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨页表格（使用longtable环境）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;longtable&#125;</span><br><span class="line">\newcommand\meta[1]&#123;\emph&#123;$\langle$#1$\rangle$&#125;&#125;</span><br><span class="line">\begin&#123;longtable&#125;&#123;|l|l|&#125;</span><br><span class="line">\hline</span><br><span class="line">\endfirsthead</span><br><span class="line">\multicolumn&#123;2&#125;&#123;l&#125;&#123;（续表）&#125;\\</span><br><span class="line">\hline</span><br><span class="line">\endhead</span><br><span class="line">\multicolumn&#123;2&#125;&#123;c&#125;&#123;\itshape 接下一页表格......&#125;\\[2ex]</span><br><span class="line">\endfoot</span><br><span class="line">\hline</span><br><span class="line">\endlastfoot</span><br><span class="line">% 下面是你的表格内容</span><br><span class="line">% =================================================== %</span><br><span class="line">\hline</span><br><span class="line">D0～D7 &amp; 双向数据总线，以便和 CPU 之间传递命令、数据和状态。\\</span><br><span class="line">\hline</span><br><span class="line">CLK    &amp; 时钟输入线，以产生内部时钟 \\</span><br><span class="line">\hline</span><br><span class="line">% ==================================================== %</span><br><span class="line">\end&#123;longtable&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://blog.sina.com.cn/s/blog_6cb9ecd10100lpln.html" target="_blank" rel="noopener">表格内的内容添加脚注</a></p>
<p>在tabular环境中添加脚注，不能简单地使用\footnote{……}。应该在要添加脚注的地方使用\footnotemark[n]标记，其中n表示脚注的编号；在<strong>tabular或table环境外</strong>则用\footnotetext[n]{……}填入脚注内容，注意这里的[n]应该与表格中的\footnotemark中的[n]一一对应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;[htbp]</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tabular&#125;&#123;ll&#125;</span><br><span class="line">  \toprule</span><br><span class="line">  % after \\: \hline or \cline&#123;col1-col2&#125; \cline&#123;col3-col4&#125; ...</span><br><span class="line">  $D_4 D_3$ &amp; 功能 \\</span><br><span class="line">  \midrule</span><br><span class="line">  00 &amp; 8字符显示，左端输入\footnotemark[1] \\</span><br><span class="line">  01 &amp; 16字符显示，左端输入 \\</span><br><span class="line">  10 &amp; 8字符显示，左端输入 \\</span><br><span class="line">  11 &amp; 16字符显示，右端输入 \\</span><br><span class="line">  \bottomrule</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br><span class="line">\footnotetext[1]&#123;RESET后，设定该种方式&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格中添加列表环境(1)</p>
<p>缺点：表格中每一个格子内，必须有列表的序号（·或者123…）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;array&#125;</span><br><span class="line">\makeatletter</span><br><span class="line">\newcolumntype&#123;e&#125;[1]&#123;%--- Enumerated cells ---</span><br><span class="line">   &gt;&#123;\minipage[t]&#123;\linewidth&#125;%</span><br><span class="line">     \NoHyper%                Hyperref adds a vertical space</span><br><span class="line">     \let\\\tabularnewline</span><br><span class="line">     \enumerate</span><br><span class="line">        \addtolength&#123;\rightskip&#125;&#123;0pt plus 50pt&#125;% for raggedright</span><br><span class="line">        \setlength&#123;\itemsep&#125;&#123;-\parsep&#125;&#125;%</span><br><span class="line">   p&#123;#1&#125;%</span><br><span class="line">   &lt;&#123;\@finalstrut\@arstrutbox\endenumerate</span><br><span class="line">     \endNoHyper</span><br><span class="line">     \endminipage&#125;&#125;</span><br><span class="line"></span><br><span class="line">\newcolumntype&#123;i&#125;[1]&#123;%--- Itemized cells ---</span><br><span class="line">   &gt;&#123;\minipage[t]&#123;\linewidth&#125;%</span><br><span class="line">        \let\\\tabularnewline</span><br><span class="line">        \itemize</span><br><span class="line">           \addtolength&#123;\rightskip&#125;&#123;0pt plus 50pt&#125;%</span><br><span class="line">           \setlength&#123;\itemsep&#125;&#123;-\parsep&#125;&#125;%</span><br><span class="line">   p&#123;#1&#125;%</span><br><span class="line">   &lt;&#123;\@finalstrut\@arstrutbox\enditemize\endminipage&#125;&#125;</span><br><span class="line"></span><br><span class="line">\AtBeginDocument&#123;%</span><br><span class="line">    \@ifpackageloaded&#123;hyperref&#125;&#123;&#125;%</span><br><span class="line">        &#123;\let\NoHyper\relax\let\endNoHyper\relax&#125;&#125;</span><br><span class="line">\makeatother</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;tabular&#125;[t]&#123;|i&#123;2.5cm&#125;|e&#123;3cm&#125;|&#125;</span><br><span class="line">\hline</span><br><span class="line">  \item Item A</span><br><span class="line">  \item Item B   &amp;</span><br><span class="line">  \item Item 1</span><br><span class="line">  \item Item 2   \\</span><br><span class="line">\hline  </span><br><span class="line">  \item Item C   &amp;</span><br><span class="line">  \item Item 3</span><br><span class="line">  \item Item 4   \\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格中添加列表环境(2)</p>
<p>特点：克服了(1)的缺点，但是每一个列表之间距离很大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">  \centering</span><br><span class="line">  \begin&#123;tabular&#125;&#123;|p&#123;2cm&#125;|p&#123;6cm&#125;|p&#123;6cm&#125;|&#125;</span><br><span class="line"> \hline</span><br><span class="line"> 结构 &amp; 背景 &amp; 重点/贡献\\</span><br><span class="line"> \hline</span><br><span class="line"> 三层结构 &amp;</span><br><span class="line"> \begin&#123;itemize&#125;</span><br><span class="line">   \item 雾计算基本结构</span><br><span class="line"> \end&#123;itemize&#125;</span><br><span class="line">    &amp;</span><br><span class="line">   \begin&#123;itemize&#125;</span><br><span class="line">   \item 将计算和存储设施扩展到网络边缘并减轻云数据中心的负担。</span><br><span class="line">  \end&#123;itemize&#125; \\</span><br><span class="line"> \hline</span><br><span class="line"> 基于SDN的雾计算 &amp;</span><br><span class="line"> \begin&#123;itemize&#125;</span><br><span class="line">   \item 数据和控制平面的分离。</span><br><span class="line">   \item 在边缘元素中集成控制器功能，即边缘切换。</span><br><span class="line">   \item 与雾和云管理软件进行通信。</span><br><span class="line">   \end&#123;itemize&#125; &amp;	</span><br><span class="line"> \begin&#123;itemize&#125;</span><br><span class="line">   \item 改进控制器开关延迟性能。</span><br><span class="line">   \item 有效地管理边缘切换的搜索，编译和网络资源。</span><br><span class="line">   \item 处理与雾相关的流量，旨在减少延迟和碳足迹。</span><br><span class="line"> \end&#123;itemize&#125; \\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">  \caption&#123;三层结构和 SDN 结构的区别&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><p>添加参考文献到目录中，加入第二行的代码，<strong>编译两次</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">\addcontentsline&#123;toc&#125;&#123;section&#125;&#123;参考文献&#125; % 加入这一行，编译两次</span><br><span class="line">\bibitem&#123;1&#125; 梁建武,杨迎泽. 微机原理与接口技术. 北京: 中国铁道出版社. 2016, 02.</span><br><span class="line">\bibitem&#123;2&#125; 王爽. 汇编语言(第三版). 北京:清华大学出版社. 2014, 04.</span><br><span class="line">\bibitem&#123;3&#125; Star ES8086使用说明.</span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>《UNIX网络编程》第一步：编写自己的daytime客户端，并从daytime服务器获取时间</title>
    <url>/2018/11/12/other/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="1-首先下载《UNIX网络编程》配套源代码"><a href="#1-首先下载《UNIX网络编程》配套源代码" class="headerlink" title="1. 首先下载《UNIX网络编程》配套源代码"></a>1. 首先下载《UNIX网络编程》配套源代码</h2><p><a href="http://www.unpbook.com/" target="_blank" rel="noopener">源代码地址</a></p>
<hr>
<a id="more"></a>
<h2 id="2-复制到虚拟机内-以Ubuntu系统为例-并解压。"><a href="#2-复制到虚拟机内-以Ubuntu系统为例-并解压。" class="headerlink" title="2. 复制到虚拟机内(以Ubuntu系统为例),并解压。"></a>2. 复制到虚拟机内(以Ubuntu系统为例),并解压。</h2><p>解压命令：<strong><code>tar zxvf unpv13e.tar.gz</code></strong></p>
<hr>
<p><strong>以下加粗部分的代码块，均为要在终端执行的命令。</strong></p>
<h2 id="3-在终端进入unpv13e目录。"><a href="#3-在终端进入unpv13e目录。" class="headerlink" title="3. 在终端进入unpv13e目录。"></a>3. 在终端进入unpv13e目录。</h2><ul>
<li><p>终端执行 <strong><code>./configure</code></strong></p>
<p>如果出错，先执行命令 <strong><code>chmod +x configure</code></strong>  ，再执行   <strong><code>./configure</code></strong></p>
</li>
<li><p>进入lib目录  <strong><code>cd lib</code></strong>  ，并执行命令  <strong><code>make</code></strong></p>
</li>
<li><p>返回上一级目录 <strong><code>cd ..</code></strong> ，并进入libfree目录 <strong><code>cd libfree</code></strong> ，再执行 <strong><code>make</code></strong>（这一步可能会有error，没关系，只要在unpv13e文件夹中生成了libunp.a文件就可以）<br><strong><em>最终会在unpv13e文件夹中生成libunp.a文件</em></strong></p>
</li>
</ul>
<hr>
<h2 id="4-将libunp-a文件复制到-usr-lib"><a href="#4-将libunp-a文件复制到-usr-lib" class="headerlink" title="4. 将libunp.a文件复制到/usr/lib/"></a>4. 将libunp.a文件复制到/usr/lib/</h2><ul>
<li>返回到unpv13e目录， <strong><code>cd ..</code></strong></li>
<li>执行复制命令，<strong><code>sudo cp libunp.a /usr/lib</code></strong></li>
</ul>
<hr>
<h2 id="5-修改unpv13e-lib-unp-h，并将它和unpv13e-config-h拷贝到-usr-include中"><a href="#5-修改unpv13e-lib-unp-h，并将它和unpv13e-config-h拷贝到-usr-include中" class="headerlink" title="5. 修改unpv13e/lib/unp.h，并将它和unpv13e/config.h拷贝到/usr/include中"></a>5. 修改unpv13e/lib/unp.h，并将它和unpv13e/config.h拷贝到/usr/include中</h2><ul>
<li>用vim编辑unp.h, <strong><code>vim lib/unp.h</code></strong>, 将<em>#include “../config.h”*修改为</em>#include “config.h”*</li>
<li>拷贝unp.h,  <strong><code>sudo cp lib/unp.h /usr/include</code></strong></li>
<li>拷贝configure.h,  <strong><code>sudo cp config.h /usr/include</code></strong></li>
</ul>
<hr>
<h2 id="6-安装xinetd服务"><a href="#6-安装xinetd服务" class="headerlink" title="6.安装xinetd服务"></a>6.安装xinetd服务</h2><ul>
<li>Ubuntu系统中：执行命令， <strong><code>apt install xinetd</code></strong></li>
<li>Centos系统中：执行命令， <strong><code>yum  -y  install  xinetd*</code></strong></li>
</ul>
<hr>
<h2 id="7-执行daytime客户端"><a href="#7-执行daytime客户端" class="headerlink" title="7. 执行daytime客户端"></a>7. 执行daytime客户端</h2><ul>
<li><p>找到文件daytimetcpcli.c，在unpv13e/intro目录中，利用cd命令进入该目录。</p>
</li>
<li><p>编译该文件， <strong><code>gcc daytimetcpcli.c -lunp</code></strong></p>
</li>
<li><p>会生成a.out文件，再执行 <strong><code>./a.out 127.0.0.1</code></strong>，获取本机时间。</p>
</li>
</ul>
<p><strong>如果出现错误：</strong> connect error:Connection refused,表示daytime服务器程序没设置好。</p>
<p><strong>Ubuntu系统的解决办法：</strong></p>
<ul>
<li><p>找到/etc/xinetd.d目录，<strong><code>cd /etc/xinetd.d</code></strong></p>
</li>
<li><p>用vim编辑daytime文件，<strong><code>sudo vim daytime</code></strong>（要用超级用户权限才可以修改，因此要加上sudo）</p>
</li>
<li><p>daytime文件中的两个<em>disable = yes</em> 改为 <em>disable = no</em>，保存退出vim。</p>
</li>
<li><p>重启xinetd服务，执行命令，<strong><code>service xinetd restart</code></strong></p>
</li>
<li><p>此时再次执行步骤7。</p>
</li>
</ul>
<p><strong>Centos系统的解决办法：</strong></p>
<ul>
<li><p>找到/etc/xinetd.d目录，<strong><code>cd /etc/xinetd.d</code></strong></p>
</li>
<li><p>将daytime-stream和daytime-dgram两个文件中的<em>disable = yes</em> 均改为 <em>disable = no</em>。用vim编辑这两个文件，<strong><code>sudo vim daytime-stream</code></strong>和<strong><code>sudo vim daytime-dgram</code></strong>（要用超级用户权限才可以修改，因此要加上sudo）。</p>
</li>
<li><p>回到主目录，<strong><code>cd ~</code></strong>。重启xinetd服务，执行命令，<strong><code>/etc/init.d/xinetd restart</code></strong></p>
</li>
<li><p>此时再次执行步骤7。</p>
</li>
</ul>
<hr>
<h2 id="8-注"><a href="#8-注" class="headerlink" title="8. 注"></a>8. 注</h2><ul>
<li>daytime服务器有许多种，127.0.0.1只是本机地址时间，可以更换别的服务器。</li>
<li>目前手头只有Ubuntu 18系统和Centos6.8系统，因此只有这两个系统的教程。</li>
</ul>
<hr>
<h2 id="9-结果"><a href="#9-结果" class="headerlink" title="9. 结果"></a>9. 结果</h2><ol>
<li><p>Ubuntu下</p>
<p> <img src="/2018/11/12/other/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/ubuntu.jpg" alt="1"></p>
</li>
<li><p>Centos下</p>
<p> <img src="/2018/11/12/other/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/centos.png" alt="2"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>UNIX</category>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>利用graphviz软件和pycallgraph库自动生成Python代码函数调用关系图</title>
    <url>/2018/10/11/other/%E5%88%A9%E7%94%A8graphviz%E8%BD%AF%E4%BB%B6%E5%92%8Cpycallgraph%E5%BA%93%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Python%E4%BB%A3%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://pycallgraph.readthedocs.io/en/master/guide/index.html" target="_blank" rel="noopener">参考 https://pycallgraph.readthedocs.io/en/master/guide/index.html</a></p>
</blockquote>
<h2 id="1-下载并安装graphviz"><a href="#1-下载并安装graphviz" class="headerlink" title="1.下载并安装graphviz"></a>1.下载并安装graphviz</h2><ol>
<li><a href="https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi" target="_blank" rel="noopener">下载地址: https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi</a></li>
<li>安装（路径可任意选择）</li>
<li>配置环境变量，在Path中添加：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例如我安装在F:\Program Files (x86)，那么就添加环境变量F:\Program Files (x86)\Graphviz2.38\bin</span><br></pre></td></tr></table></figure>

<h2 id="2-安装pycallgraph库"><a href="#2-安装pycallgraph库" class="headerlink" title="2.安装pycallgraph库"></a>2.安装pycallgraph库</h2><ul>
<li>cmd窗口命令行输入：<code>pip install pycallgraph</code></li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><p><strong>注意：你的程序, 只有你运行中使用了某个函数，才能显示在流图中。用户没有使用的功能则不会出现在流图中。</strong></p>
<p>在代码开头调用该库，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> PyCallGraph</span><br><span class="line"><span class="keyword">from</span> pycallgraph.output <span class="keyword">import</span> GraphvizOutput</span><br><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> GlobbingFilter</span><br></pre></td></tr></table></figure>

<p>主函数操作：</p>
<p>（最终会保存在你的.py文件相同的文件夹里，名字为graph.png）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 你的主函数代码。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    config = Config()</span><br><span class="line">    <span class="comment"># 关系图中包括(include)哪些函数名。</span></span><br><span class="line">    <span class="comment">#如果是某一类的函数，例如类gobang，则可以直接写'gobang.*'，表示以gobang.开头的所有函数。（利用正则表达式）。</span></span><br><span class="line">    config.trace_filter = GlobbingFilter(include=[</span><br><span class="line">        <span class="string">'main'</span>,</span><br><span class="line">        <span class="string">'draw_chessboard'</span>,</span><br><span class="line">        <span class="string">'draw_chessman'</span>,</span><br><span class="line">        <span class="string">'draw_chessboard_with_chessman'</span>,</span><br><span class="line">        <span class="string">'choose_save'</span>,</span><br><span class="line">        <span class="string">'choose_turn'</span>,</span><br><span class="line">        <span class="string">'choose_mode'</span>,</span><br><span class="line">        <span class="string">'choose_button'</span>,</span><br><span class="line">        <span class="string">'save_chess'</span>,</span><br><span class="line">        <span class="string">'load_chess'</span>,</span><br><span class="line">        <span class="string">'play_chess'</span>,</span><br><span class="line">        <span class="string">'pop_window'</span>,</span><br><span class="line">        <span class="string">'tip'</span>,</span><br><span class="line">        <span class="string">'get_score'</span>,</span><br><span class="line">        <span class="string">'max_score'</span>,</span><br><span class="line">        <span class="string">'win'</span>,</span><br><span class="line">        <span class="string">'key_control'</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="comment"># 该段作用是关系图中不包括(exclude)哪些函数。(正则表达式规则)</span></span><br><span class="line">    <span class="comment"># config.trace_filter = GlobbingFilter(exclude=[</span></span><br><span class="line">    <span class="comment">#     'pycallgraph.*',</span></span><br><span class="line">    <span class="comment">#     '*.secret_function',</span></span><br><span class="line">    <span class="comment">#     'FileFinder.*',</span></span><br><span class="line">    <span class="comment">#     'ModuleLockManager.*',</span></span><br><span class="line">    <span class="comment">#     'SourceFilLoader.*'</span></span><br><span class="line">    <span class="comment"># ])</span></span><br><span class="line">    graphviz = GraphvizOutput()</span><br><span class="line">    graphviz.output_file = <span class="string">'graph.png'</span></span><br><span class="line">    <span class="keyword">with</span> PyCallGraph(output=graphviz, config=config):</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure>

<p>产生的图片效果如下所示：</p>
<p><img src="/2018/10/11/other/%E5%88%A9%E7%94%A8graphviz%E8%BD%AF%E4%BB%B6%E5%92%8Cpycallgraph%E5%BA%93%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Python%E4%BB%A3%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE/pycallgraph.png" alt="basic"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>graphviz</tag>
        <tag>pycallgraph</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保存MATLAB GUI界面中的图片</title>
    <url>/2018/09/16/other/%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98MATLAB%20GUI%E7%95%8C%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>代码来源自网络，作者未知，侵删。<br>原生支持png，bmp，jpg格式。另外自行添加了清晰度比较高的eps格式（荐）。</p>
</blockquote>
<a id="more"></a>

<p>新建一个按钮，按钮的代码如下。</p>
<p>其中第二行的 <code>new_axes=copyobj(handles.axes1,new_f_handle)</code> 的 <code>handles.axes1</code> 意思是保存的是axes1中的图，以此类推。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushbutton19_Callback</span><span class="params">(hObject, eventdata, handles)</span></span></span><br><span class="line"><span class="comment">% hObject    handle to pushbutton19 (see GCBO)</span></span><br><span class="line"><span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span></span><br><span class="line"><span class="comment">% handles    structure with handles and user data (see GUIDATA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 以下内容拷贝到按钮函数下。</span></span><br><span class="line">    new_f_handle=<span class="built_in">figure</span>(<span class="string">'visible'</span>,<span class="string">'off'</span>); <span class="comment">%新建一个不可见的figure</span></span><br><span class="line">    new_axes=copyobj(handles.axes1,new_f_handle); <span class="comment">%axes1是GUI界面内要保存图线的Tag，将其copy到不可见的figure中</span></span><br><span class="line">    set(new_axes,<span class="string">'Units'</span>,<span class="string">'normalized'</span>,<span class="string">'Position'</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.8</span> <span class="number">0.8</span>]);<span class="comment">%将图线缩放</span></span><br><span class="line">    [filename pathname fileindex]=uiputfile(&#123;<span class="string">'*.png'</span>;<span class="string">'*.bmp'</span>;<span class="string">'*.jpg'</span>;<span class="string">'*.eps'</span>;&#125;,<span class="string">'图片保存为'</span>);</span><br><span class="line">    <span class="keyword">if</span>  filename~=<span class="number">0</span><span class="comment">%未点“取消”按钮或未关闭</span></span><br><span class="line">        file=strcat(pathname,filename);</span><br><span class="line">        <span class="keyword">switch</span> fileindex <span class="comment">%根据不同的选择保存为不同的类型</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-dpng'</span>,file);<span class="comment">% print(new_f_handle,'-dpng',filename);效果一样，将图像打印到指定文件中</span></span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-dbmp'</span>,file);</span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-djpg'</span>,file);</span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-depsc'</span>,file);</span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        msgbox(<span class="string">'          图线已成功保存！'</span>,<span class="string">'完成！'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
</search>
