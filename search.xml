<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XPCOM/XPCOM概述</title>
    <url>/2022/03/17/XPCOM/XPCOM%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Guide/Creating_components/An_Overview_of_XPCOM" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Guide/Creating_components/An_Overview_of_XPCOM</a></p>
</blockquote>
<h1 id="nsISupports-基接口"><a href="#nsISupports-基接口" class="headerlink" title="nsISupports 基接口"></a><code>nsISupports</code> 基接口</h1><p>组件与基于接口的编程的两个最基本的问题是: 一个是<em>组件生存期</em>, 也称为<em>对象所属关系</em>; 另一个是<em>接口查询</em>, 它是在运行时刻确定接口能够提供哪些接口。 <code>nsISupports</code>它是 XPCOM 中所有接口的父接口。</p>
<p>在 XPCOM 中, 由于组件可以实现任意多的不同接口, 接口必须是<strong>引用计数的</strong>。</p>
<h2 id="XPCOM中的指针"><a href="#XPCOM中的指针" class="headerlink" title="XPCOM中的指针"></a>XPCOM中的指针</h2><p>但是 XPCOM <strong>接口指针</strong>指向的都是从 <code>nsISupports</code> 基接口_派生_而来的接口实现, 这个基接口包括三个基本的方法: <code>AddRef</code>, <code>Release</code>, 和 <code>QueryInterface</code>.</p>
<h2 id="nsISupports-接口"><a href="#nsISupports-接口" class="headerlink" title="nsISupports 接口"></a><strong><code>nsISupports</code> 接口</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span>:</span> <span class="keyword">public</span> nsISupports</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    nsrefcnt mRefCnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sample();</span><br><span class="line">    <span class="keyword">virtual</span> ~Sample();</span><br><span class="line"></span><br><span class="line">    <span class="function">NS_IMETHOD <span class="title">QueryInterface</span><span class="params">(<span class="keyword">const</span> nsIID &amp;aIID, <span class="keyword">void</span> **aResult)</span></span>;</span><br><span class="line">    NS_IMETHOD_(nsrefcnt) AddRef(<span class="keyword">void</span>);</span><br><span class="line">    NS_IMETHOD_(nsrefcnt) Release(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialize the reference count to 0</span></span><br><span class="line">Sample::Sample() : mRefCnt(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Sample::~Sample()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// typical, generic implementation of QI</span></span><br><span class="line">NS_IMETHODIMP Sample::QueryInterface(<span class="keyword">const</span> nsIID &amp;aIID,<span class="keyword">void</span> **aResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aResult) &#123;</span><br><span class="line">    	<span class="keyword">return</span> NS_ERROR_NULL_POINTER;</span><br><span class="line">    &#125;</span><br><span class="line">    *aResult = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (aIID.Equals(kISupportsIID)) &#123;</span><br><span class="line">    	*aResult = (<span class="keyword">void</span> *) <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!*aResult) &#123;</span><br><span class="line">   		<span class="keyword">return</span> NS_ERROR_NO_INTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add a reference</span></span><br><span class="line">    AddRef();</span><br><span class="line">    <span class="keyword">return</span> NS_OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">NS_IMETHODIMP_(nsrefcnt) Sample::AddRef()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ++mRefCnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">NS_IMETHODIMP_(nsrefcnt) Sample::Release()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--mRefCnt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// optional: return the reference count</span></span><br><span class="line">    <span class="keyword">return</span> mRefCnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在XPCOM，所有接口类从<code>nsISupports</code>类派生，因此所有的对象都是<code>nsISupports</code>。</li>
<li>XPCOM不直接支持C++ exceptions。 在组件内产生的异常必须在传递到接口边界之前全部由组件自己处理掉， 然后接口方法返回一个 <code>nsresult</code> 错误值。</li>
<li>XPCOM 没有采用<strong>C++ RTTI</strong> 机制来实现对象指针的动态转化, 它使用 <code>QueryInterface</code> 方法来把一个对象指针 cast 成正确的接口指针.</li>
<li>XPCOM里所有的接口方法应该返回一个<code>nsresult</code>值，记录错误代码。 有错误代码返回，表示XPCOM处理出现异常。</li>
<li>每一个接口需要被分配一个唯一的标识符（可以通过uuidgen工具生成）。 这个标识符是唯一的，128-bit的数字。 在接口上下文中进行使用，他通常被叫做 <strong><code>IID</code></strong>。</li>
<li>当客户程序<strong>想查询一个对象是否支持某个接口</strong>, 它把接口的 <code>IID</code> 值传递给这个对象的 <code>QueryInterface</code> 方法. 如果对象支持这个接口, 它就会对自己的<strong>引用计数加 1</strong>, 会<strong>返回指向接口的指针</strong>。不支持，则<strong>返回错误码</strong>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nsISupports</span> &#123;</span> </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">QueryInterface</span><span class="params">(<span class="keyword">const</span> nsIID &amp; uuid,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">void</span> **result)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">AddRef</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">Release</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>QueryInterface</code> 的第一个参数是一个 <code>nsIID</code> 类型的引用, 它封装了 IID. <code>nsIID</code> 类有三种方法: <code>Equals</code>, <code>Parse</code>, 和 <code>ToString</code> 。其中<strong><code>Equals</code></strong>在接口查询中是最重要的, 它用来比较两个 <code>nsIID</code> 对象是否相同。<br>在 <code>QueryInterface</code> 方法的实现中, <code>IID</code> 参数与组件支持 <code>nsIID</code> 类进行比较. 如果匹配, <strong>对象的 <code>this</code> 指针转化为 <code>void</code> 指针, 引用计数加1</strong>, 把 <code>void</code> 指针返回给客户程序。</p>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Implementing_QueryInterface" target="_blank" rel="noopener">实现QueryInterface接口</a></p>
</blockquote>
<h2 id="XPCOM-的ID"><a href="#XPCOM-的ID" class="headerlink" title="XPCOM 的ID"></a>XPCOM 的ID</h2><ul>
<li>一个CID是一个128位的数字，用于标识一个类或组件。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLE_CID \</span></span><br><span class="line">&#123; <span class="number">0x777f7150</span>, <span class="number">0x4a2b</span>, <span class="number">0x4301</span>, \</span><br><span class="line">&#123; <span class="number">0xad</span>, <span class="number">0x10</span>, <span class="number">0x5e</span>, <span class="number">0xab</span>, <span class="number">0x25</span>, <span class="number">0xb3</span>, <span class="number">0x22</span>, <span class="number">0xaa</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Contract ID 契约ID的格式由组件域，模块，组件名字和版本号组成，各部分之间用”/“分隔.，用于组件的访问。</li>
</ul>
<p><code>&quot;@mozilla.org/network/ldap-operation;1&quot;</code><br>     1个契约ID只是表示他想实现的一组接口。契约ID和CID不同之处在于，它可能重载组件。</p>
<h2 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h2><p><code>SomeClass* component = new SomeClass();</code><br>在 <code>SomeClass</code> 例子中, 可以按照类厂模式把 <code>SomeClass</code> 对象的构造和初始化封装在 <code>New_SomeInterface</code> 函数中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New_SomeInterface</span><span class="params">(SomeInterface** ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// create the object</span></span><br><span class="line">  SomeClass* out = <span class="keyword">new</span> SomeClass();</span><br><span class="line">  <span class="keyword">if</span> (!out) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// init the object</span></span><br><span class="line">  <span class="keyword">if</span> (out-&gt;Init() == FALSE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> out;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// cast to the interface</span></span><br><span class="line">  *ret = <span class="keyword">static_cast</span>&lt;SomeInterface*&gt;(out);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂就是一个类，用于管理，创建组件的实例。 在XPCOM里工厂由 <strong><code>nsIFactory</code></strong> 接口实现，它使用上面所示的工厂设计模式封装对象的创建和初始化。</p>
<ul>
<li>工厂需要保存它创建的对象的信息。 当工厂管理共享库的类的实例的时候，例如，他需要知道他什么时候可以卸载这个动态库。当类厂保存了这样的信息, 就可以向工厂查询一个对象是否已经被创建.</li>
<li>工厂的另一个状态用于保存一个对象是否是单例对象。 例如，如果工厂创建了一个单例对象，那么后续的对象创建的请求都应该返回同一个对象。 </li>
</ul>
<h2 id="XPCOM-类型"><a href="#XPCOM-类型" class="headerlink" title="XPCOM 类型"></a>XPCOM 类型</h2><p>XPCOM 声明了许多数据类型和简单宏, 这些东西将在我们后面的例子中看到. 大多数的宏都是简单的重定义, 下一节我们会描述一些最常用的数据类型.</p>
<h4 id="方法类型"><a href="#方法类型" class="headerlink" title="方法类型"></a>方法类型</h4><p>下面的类型用在 XPCOM 方法调用的参数和返回值定义中.</p>
<table>
<thead>
<tr>
<th align="left"><code>NS_IMETHOD</code></th>
<th align="left">方法声明返回值. XPCOM 的方法声明缺省的返回值.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NS_IMETHODIMP</code></td>
<td align="left">方法实现返回值. XPCOM 方法函数返回的时候缺省采用这种类型的返回值.</td>
</tr>
<tr>
<td align="left"><code>NS_IMETHODIMP_(type)</code></td>
<td align="left">特定类型的方法实现返回值. 诸如 <code>AddRef</code> 和 <code>Release</code> 的方法不返回缺省类型, 这种返回值的不一致虽然有点不舒服, 但是必需的.</td>
</tr>
<tr>
<td align="left"><code>NS_IMPORT</code></td>
<td align="left">共享库内部使用的符号局部声明</td>
</tr>
<tr>
<td align="left"><code>NS_EXPORT</code></td>
<td align="left">共享库导出的符号声明.</td>
</tr>
</tbody></table>
<h4 id><a href="#" class="headerlink" title></a></h4><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>下面的宏提供对引用计数的基本操作.</p>
<table>
<thead>
<tr>
<th align="left"><code>NS_ADDREF</code></th>
<th align="left">调用 <code>nsISupports</code> 对象的 <code>AddRef</code> 方法.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NS_IF_ADDREF</code></td>
<td align="left">与上一个方法类似, 不同之处在于这个宏在<code>AddRef</code>之前会检查对象指针是否为空(虚函数指针).</td>
</tr>
<tr>
<td align="left"><code>NS_RELEASE</code></td>
<td align="left">调用 <code>nsISupports</code> 对象的 <code>Release</code> 方法.</td>
</tr>
<tr>
<td align="left"><code>NS_IF_RELEASE</code></td>
<td align="left">与上一个方法类似, 不同之处在于这个宏在调用<code>Release</code>之前会检查空指针.</td>
</tr>
</tbody></table>
<h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>下面的宏测试状态码.</p>
<table>
<thead>
<tr>
<th align="left"><code>NS_FAILED</code></th>
<th align="left">如果传递的状态码为失败, 则返回真.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NS_SUCCEEDED</code></td>
<td align="left">如果传递的状态码为成功, 则返回真.</td>
</tr>
</tbody></table>
<h4 id="-2"><a href="#-2" class="headerlink" title></a></h4><h4 id="变量映射"><a href="#变量映射" class="headerlink" title="变量映射"></a>变量映射</h4><table>
<thead>
<tr>
<th align="left"><code>nsrefcnt</code></th>
<th align="left">缺省的引用计数类型, 是一个 32-bit 整数.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>nsresult</code></td>
<td align="left">缺省数据类型, 是一个 32-bit 整数.</td>
</tr>
<tr>
<td align="left"><code>nsnull</code></td>
<td align="left">缺省 null 类型.</td>
</tr>
</tbody></table>
<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="通用-XPCOM-错误码"><a href="#通用-XPCOM-错误码" class="headerlink" title="通用 XPCOM 错误码"></a>通用 XPCOM 错误码</h4><table>
<thead>
<tr>
<th align="left"><code>NS_ERROR_NOT_INITIALIZED</code></th>
<th align="left">如果实例未初试化, 返回该值.</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NS_ERROR_ALREADY_INITIALIZED</code></td>
<td align="left">如果实例已初试化, 返回该值.</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_NOT_IMPLEMENTED</code></td>
<td align="left">如果方法未实现, 返回该值.</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_NO_INTERFACE</code></td>
<td align="left">如果组件不支持某种类型接口, 返回该值.</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_NULL_POINTER</code></td>
<td align="left">如果指针指向 <code>nsnull</code>, 返回该值 .</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_FAILURE</code></td>
<td align="left">如果某个方法失效, 返回该值, 这时一个通用的错误值.</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_UNEXPECTED</code></td>
<td align="left">如果一个未预料的错误发生, 返回该值.</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_OUT_OF_MEMORY</code></td>
<td align="left">如果无法进行内存分配, 返回该值.</td>
</tr>
<tr>
<td align="left"><code>NS_ERROR_FACTORY_NOT_REGISTERED</code></td>
<td align="left">如果一个请求的类型未注册, 返回该值.</td>
</tr>
</tbody></table>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>vscode remote免密连接</title>
    <url>/2020/06/10/other/vscode%20remote%E5%85%8D%E5%AF%86%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<ol>
<li>打开 <code>cmd</code> 输入 `ssh-keygen -t rsa -b 4096</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">C:\Users\lenovo&gt;ssh-keygen -t rsa -b <span class="number">4096</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/lenovo/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>条款08-别让异常逃离析构函数</title>
    <url>/2020/03/21/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE08-%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li><a href="#条款08-别让异常逃离析构函数">条款08-别让异常逃离析构函数</a><ul>
<li><a href="#C-并不禁止析构函数抛出异常，但不鼓励你这么做。">C++ 并不禁止析构函数抛出异常，但不鼓励你这么做。</a></li>
<li><a href="#析构函数的某个动作可能抛出异常，怎么办？">析构函数的某个动作可能抛出异常，怎么办？</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08-别让异常逃离析构函数"></a>条款08-别让异常逃离析构函数</h1><h2 id="C-并不禁止析构函数抛出异常，但不鼓励你这么做。"><a href="#C-并不禁止析构函数抛出异常，但不鼓励你这么做。" class="headerlink" title="C++ 并不禁止析构函数抛出异常，但不鼓励你这么做。"></a>C++ 并不禁止析构函数抛出异常，但不鼓励你这么做。</h2><p>下面这段代码，试图在析构函数里抛出异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   ~Object();</span><br><span class="line">&#125;;</span><br><span class="line">Object::~Object() &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Deconstructor is invoked."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">throw</span> invalid_argument(<span class="string">"another exception"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行后，gcc会报错：大体意思就是C++11默认析构函数是无异常的。这个程序会在抛出异常后停止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">7.cpp: In destructor 'Object::~Object()':</span><br><span class="line"><span class="number">7.</span>cpp:<span class="number">9</span>:<span class="number">45</span>: warning: <span class="keyword">throw</span> will always call terminate() [-Wterminate]</span><br><span class="line">   <span class="keyword">throw</span> invalid_argument(<span class="string">"another exception"</span>);</span><br><span class="line">                                             ^</span><br><span class="line"><span class="number">7.</span>cpp:<span class="number">9</span>:<span class="number">45</span>: note: in C++<span class="number">11</span> destructors <span class="keyword">default</span> to <span class="keyword">noexcept</span></span><br><span class="line">Deconstructor is invoked.</span><br><span class="line"></span><br><span class="line">This application has requested the Runtime to terminate it in an unusual way.</span><br><span class="line">Please contact the application<span class="number">'</span>s support team <span class="keyword">for</span> more information.</span><br><span class="line">terminate called after throwing an instance of 'std::invalid_argument'</span><br><span class="line">  what():  another exception</span><br></pre></td></tr></table></figure>

<h2 id="析构函数的某个动作可能抛出异常，怎么办？"><a href="#析构函数的某个动作可能抛出异常，怎么办？" class="headerlink" title="析构函数的某个动作可能抛出异常，怎么办？"></a>析构函数的某个动作可能抛出异常，怎么办？</h2><p>假设我们有个类负责数据库连接。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BDConnection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;  <span class="comment">// 返回一个DBConnection对象</span></span><br><span class="line">    ... ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;  <span class="comment">// 关闭连接；失败会抛出异常</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了确保用户不会忘记调用 <code>close()</code> 来关闭连接，我们创建一个用来管理 <code>DBConnection</code> 对象的类，在其析构函数里调用 <code>close()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    ~DBConn() &#123;</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection dbc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户此时会写出类似下面的这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在作用域结束时，会调用 <code>dbc</code> 的析构函数，从而调用 <code>close()</code> 关闭连接。但是如果调用 <code>close()</code> 抛出了异常，就会产生一些麻烦，例如程序终止或者其他的未定义行为。</p>
<p>我们有两个办法来解决这个问题：</p>
<ol>
<li><p>若 <code>close()</code> 抛出异常，那么程序就结束。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ... ...<span class="comment">//记录下 这次异常。</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>吞下异常，即：不作处理</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ... ...<span class="comment">//记录下 这次异常。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这两个办法都不太好，一个较好的策略是重新设计 <code>DBConn</code>，使用户有机会对可能出现的问题作出反应。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        db.close();</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                db.close();  <span class="comment">// 如果客户没有手动调用close()</span></span><br><span class="line">            &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">                ... ...<span class="comment">// //记录下 这次异常。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个操作可能抛出异常，又必须要处理该异常，那么这个异常必须来自析构函数之外的某个函数。因为析构函数内抛出异常，往往会程序结束或者发生未定义行为。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>析构函数绝对不要传播异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下（不传播）它们或者结束程序。</li>
<li>如果客户需要对某个操作在运行期间的异常作出反应，那么，类应该提供一个普通函数（而非析构函数）执行该操作。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款07-为多态基类声明virtual析构函数</title>
    <url>/2020/03/16/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE07-%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li><a href="#条款07-为多态基类声明virtual析构函数">条款07-为多态基类声明virtual析构函数</a><ul>
<li><a href="#给基类一个虚析构函数">给基类一个虚析构函数</a></li>
<li><a href="#不作为基类，则析构函数非虚">不作为基类，则析构函数非虚</a></li>
<li><a href="#若类的析构函数非虚，则不能作为基类被继承">若类的析构函数非虚，则不能作为基类被继承</a></li>
<li><a href="#抽象类作为基类">抽象类作为基类</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07-为多态基类声明virtual析构函数"></a>条款07-为多态基类声明virtual析构函数</h1><h2 id="给基类一个虚析构函数"><a href="#给基类一个虚析构函数" class="headerlink" title="给基类一个虚析构函数"></a>给基类一个虚析构函数</h2><p>许多做法可以记录时间，下面是一个计时的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    ~TimeKeeper();</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span> :</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;; <span class="comment">// 原子钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span> :</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;; <span class="comment">// 水钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WristWatch</span> :</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;; <span class="comment">// 腕表</span></span><br></pre></td></tr></table></figure>

<p>我们设计一个 <strong>工厂函数</strong>，返回一个基类指针，指向一个派生类对象。<br><code>TimeKeeper* getTimeKeeper();</code>，同时 <code>getTimeKeeper()</code> 函数返回的对象必须位于 <strong>堆</strong> 上，这意味着我们要手动 <code>delete</code> 它。</p>
<p>上述代码引起的问题是，基类有一个 <code>non-virtual</code> 析构函数，假设我们的工厂函数 <code>getTimeKeeper</code> 返回了一个 <code>AtomicClock</code> 对象。这时我们 <code>delete</code> 一个指向派生类对象的基类指针是未定义行为（c++Primer(5th) P522）。我们可能只销毁了基类成员，而派生类的成员没有被销毁，造成一个 <em>局部销毁</em> 的对象。</p>
<p>最好的做法就是，给基类一个 虚析构函数。</p>
<h2 id="不作为基类，则析构函数非虚"><a href="#不作为基类，则析构函数非虚" class="headerlink" title="不作为基类，则析构函数非虚"></a>不作为基类，则析构函数非虚</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    ~Point();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类总共大小是 8字节，如果我们的虚函数是 <code>virtual</code> 的，那么就要携带一份vptr（虚函数指针），这份指针大小为 4字节。那么多添加一个虚函数，就多占用了 50% 的空间。</p>
<h2 id="若类的析构函数非虚，则不能作为基类被继承"><a href="#若类的析构函数非虚，则不能作为基类被继承" class="headerlink" title="若类的析构函数非虚，则不能作为基类被继承"></a>若类的析构函数非虚，则不能作为基类被继承</h2><p>例如，我们继承标准库中的 <code>string</code> ，它不含任何虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialString</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">string</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SpecialString* pss = <span class="keyword">new</span> SpecialString(<span class="string">"Impending Doom"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> * ps = pss;</span><br><span class="line"><span class="keyword">delete</span> pa; <span class="comment">// 造成一个 局部销毁 的对象。</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>： <code>STL</code> 所有容器都是不带 虚析构函数的类。</p>
<h2 id="抽象类作为基类"><a href="#抽象类作为基类" class="headerlink" title="抽象类作为基类"></a>抽象类作为基类</h2><p>含有纯虚函数的类，被称作为抽象类。</p>
<p>有时你想拥有一个抽象类，但是没有任何纯虚函数。这时就可以把析构函数声明为纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">AMOV::~AWOV() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><code>AWOV</code> 类有一个纯虚函数，所以是抽象类；它还有一个虚析构函数，所以被继承后的析构也没有问题。这里，我们<strong>必须为纯虚析构函数提供一份定义</strong>。</p>
<p>析构函数的运作方式是，最深层的那个派生类的析构函数最先被调用，然后是其基类的析构函数。编译器会在 <code>AWOV</code> 的派生类的析构函数中，调用 <code>~AWOV()</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>带多态性质的基类应该声明一个虚析构函数。如果一个类有任何一个虚函数，它就应该拥有一个虚析构函数。</li>
<li>某个类设计的目的如果不是为了作为基类来使用，或者不是为了具备多态性，就不该声明 虚析构函数。</li>
<li>某个类的析构函数非虚，则不能被用来做基类。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款06-若不想使用编译器自动生成的函数，应该明确拒绝</title>
    <url>/2020/03/12/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE06-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</url>
    <content><![CDATA[<ul>
<li><a href="#条款06-若不想使用编译器自动生成的函数应该明确拒绝">条款06-若不想使用编译器自动生成的函数，应该明确拒绝</a><ul>
<li><a href="#独一无二的对象">独一无二的对象</a></li>
<li><a href="#在编译期间发现错误">在编译期间发现错误</a></li>
<li><a href="#总结">总结</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="条款06-若不想使用编译器自动生成的函数，应该明确拒绝"><a href="#条款06-若不想使用编译器自动生成的函数，应该明确拒绝" class="headerlink" title="条款06-若不想使用编译器自动生成的函数，应该明确拒绝"></a>条款06-若不想使用编译器自动生成的函数，应该明确拒绝</h1><h2 id="独一无二的对象"><a href="#独一无二的对象" class="headerlink" title="独一无二的对象"></a>独一无二的对象</h2><p>“世界上没有两片相同的叶子”，我们定义一个类表示叶子 <code>class Leaf { ... }</code>。显然任何拷贝动作都是不合逻辑的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Leaf l1;</span><br><span class="line">Leaf l2;</span><br><span class="line"><span class="function">Leaf <span class="title">l3</span><span class="params">(l1)</span></span>;  <span class="comment">// 编译不通过</span></span><br><span class="line">l1 = l2;      <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>

<p>如果我们不声明 拷贝构造函数 和 拷贝赋值运算符，那么编译器会为我们生成一个。所以我们要声明这两个函数，但是我们却不能用。因此我们可以把这两个函数声明为 <code>private</code>。</p>
<p><strong>注意：</strong> C++11支持将构造函数声明为 <strong>删除</strong>的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Leaf(<span class="keyword">const</span> Leaf&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">Leaf&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Leaf&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<h2 id="在编译期间发现错误"><a href="#在编译期间发现错误" class="headerlink" title="在编译期间发现错误"></a>在编译期间发现错误</h2><p>上节将拷贝构造函数 和 拷贝赋值运算符声明为 <code>private</code>，但是我们的成员函数和友元函数仍可以调用，这时会产生连接错误。我们要将连接期错误转移到编译期间，我们可以专门为阻止拷贝动作设计一个基类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopytable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopytable() &#123; &#125;</span><br><span class="line">    ~Uncopytable() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopytable(<span class="keyword">const</span> Uncopytable&amp;);</span><br><span class="line">    Uncopytable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopytable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> :</span> <span class="keyword">private</span> Uncopytable &#123;</span><br><span class="line">    ... ...;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，以任何形式来拷贝 <code>Leaf</code> 对象，编译器就算给 <code>Leaf</code> 生成了拷贝构造函数，那么这个拷贝动作会调用<strong>基类</strong>的拷贝构造函数，这会被编译器拒绝。</p>
<p>此代码还有几个微妙的地方：</p>
<ol>
<li><code>Uncopytable</code> 作为基类，析构函数是 <code>non-vitural</code> 的。</li>
<li>继承方式是 <code>private</code>。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>避免编译器暗自生成的拷贝功能，可以将相应的成员函数声明为 <code>private</code> 的。注意：在C++11新标准下，可以直接声明为 <strong>删除</strong>的。</li>
<li>继承像 <code>Uncopytable</code> 的基类也是可行的。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款05-了解C++默默编写并调用哪些函数</title>
    <url>/2020/03/12/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE05-%E4%BA%86%E8%A7%A3C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li><a href="#条款05-了解c默默编写并调用哪些函数">条款05-了解C++默默编写并调用哪些函数</a><ul>
<li><a href="#当我们写了一个空类意味着什么">当我们写了一个空类，意味着什么</a></li>
<li><a href="#编译器什么时候拒绝生成拷贝赋值运算符">编译器什么时候拒绝生成拷贝赋值运算符</a></li>
<li><a href="#总结">总结</a><a id="more"></a>
<h1 id="条款05-了解C-默默编写并调用哪些函数"><a href="#条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="条款05-了解C++默默编写并调用哪些函数"></a>条款05-了解C++默默编写并调用哪些函数</h1></li>
</ul>
</li>
</ul>
<h2 id="当我们写了一个空类，意味着什么"><a href="#当我们写了一个空类，意味着什么" class="headerlink" title="当我们写了一个空类，意味着什么"></a>当我们写了一个空类，意味着什么</h2><p>当我们定义一个空类时，编译器会为我们自动声明<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>和<strong>析构函数</strong>，若你没有声明任何构造函数，编译器会声明一个<strong>默认构造函数</strong>，这些函数都是 <code>public</code> 且 <code>inline</code>。</p>
<p>例如我们定义一个空类：<code>class Empty { };</code>，等同于下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;;</span><br><span class="line">    Empty(cosnt Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~Empty() &#123; ... &#125;</span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>编译器合成的析构函数是 <code>non-virtual</code> 的。</li>
<li>对于拷贝构造函数和拷贝赋值运算符，编译器合成的版本只是单纯的将对象每个 <code>non-static</code> 成员拷贝到目标对象。</li>
</ol>
<h2 id="编译器什么时候拒绝生成拷贝赋值运算符"><a href="#编译器什么时候拒绝生成拷贝赋值运算符" class="headerlink" title="编译器什么时候拒绝生成拷贝赋值运算符"></a>编译器什么时候拒绝生成拷贝赋值运算符</h2><ol>
<li>类的成员变量是 <strong>引用</strong> 类型时。因为C++不允许改变引用的对象。</li>
<li>类的成员变量是 <code>const</code> 类型时。因为C+++不允许修改常量。</li>
<li>基类的拷贝赋值运算符声明为 <strong>删除的(C++11)</strong> 或者 <strong>private</strong> 的，那么编译器拒绝为它的派生类生成拷贝赋值运算符。因为 若生成了拷贝赋值运算符，派生类的拷贝赋值运算符同时也会处理基类部分的成员变量，而基类没有该函数，所以没办法赋值。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>编译器会暗自为类声明<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>、<strong>析构函数</strong>、<strong>默认构造函数</strong>。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CppQuiz：Question-2，Difficulty-normal</title>
    <url>/2020/03/11/CppQuiz/Question2-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h2 id="1-Question-2，Difficulty-normal"><a href="#1-Question-2，Difficulty-normal" class="headerlink" title="1. Question-2，Difficulty-normal"></a>1. Question-2，Difficulty-normal</h2><blockquote>
<p><a href="http://cppquiz.org/quiz/question/2" target="_blank" rel="noopener">cppquiz: question#2</a></p>
</blockquote>
<p>根据C++ 17标准，该程序的输出是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="string">"foo"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bar = <span class="string">"bar"</span>;</span><br><span class="line">    f(bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<div class="spoiler collapsed">
    <div class="spoiler-title">
        答案
    </div>
    <div class="spoiler-content">
        <p><strong>22</strong></p>

    </div>
</div>

<div class="spoiler collapsed">
    <div class="spoiler-title">
        解析
    </div>
    <div class="spoiler-content">
        <p><code>&quot;bar&quot;</code> 是一个字符串字面值，默认类型是 <code>const char []</code>。（参考<a href="https://timsong-cpp.github.io/cppwp/n4659/lex.string#8" target="_blank" rel="noopener">[5] §5.13.5</a>），它更倾向于 <code>f(const void *)</code> 函数。如果选择了 <code>void f(const std::string &amp;)</code> 这个函数，那么首先要将 <code>const char []</code> 转为 <code>std::string</code> 类型，中间多了一次转换。</p>

    </div>
</div>

<h2 id="2-Insight：编译器实际完成的工作"><a href="#2-Insight：编译器实际完成的工作" class="headerlink" title="2. Insight：编译器实际完成的工作"></a>2. Insight：编译器实际完成的工作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::basic_string&lt;<span class="keyword">char</span>, <span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; &gt; &amp;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="keyword">operator</span>&lt;&lt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.<span class="keyword">operator</span>&lt;&lt;(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(<span class="string">"foo"</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * bar = <span class="string">"bar"</span>;</span><br><span class="line">    f(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(bar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CppQuiz</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>条款04-确定对象被使用前已被初始化</title>
    <url>/2020/03/11/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE04-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li><a href="#条款04-确定对象被使用前已被初始化">条款04-确定对象被使用前已被初始化</a><ul>
<li><a href="#1-切勿混淆赋值和初始化">1. 切勿混淆赋值和初始化</a></li>
<li><a href="#2-内置类型的赋值操作移到函数里，以避免重复的工作">2. 内置类型的赋值操作移到函数里，以避免重复的工作</a></li>
<li><a href="#3-成员初始化次序">3. 成员初始化次序</a><ul>
<li><a href="#3-1-类的成员初始化次序">3.1 类的成员初始化次序</a></li>
<li><a href="#3-2-不同编译单元内的-non-local-static-对象的初始化次序">3.2 不同编译单元内的 <code>non-local static</code> 对象的初始化次序</a></li>
</ul>
</li>
<li><a href="#4-总结">4. 总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="条款04-确定对象被使用前已被初始化"><a href="#条款04-确定对象被使用前已被初始化" class="headerlink" title="条款04-确定对象被使用前已被初始化"></a>条款04-确定对象被使用前已被初始化</h1><p>对象的初始化动作何时一定发生，何时不一定发生，这些规则太过复杂。最佳的处理办法就是：永远在使用对象之前将它初始化。</p>
<ul>
<li><p>对于内置类型，我们必须手动完成初始化。例如：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">"A C-style String"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d;  <span class="comment">// 以读取输入流的方式初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于其他类型，初始化由<strong>构造函数</strong>完成，我们要确保每一个构造函数都将对象的每一个成员初始化。</p>
</li>
</ul>
<h2 id="1-切勿混淆赋值和初始化"><a href="#1-切勿混淆赋值和初始化" class="headerlink" title="1. 切勿混淆赋值和初始化"></a>1. 切勿混淆赋值和初始化</h2><p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones) &#123;</span><br><span class="line">    theName = name;     <span class="comment">// 这些是赋值，而非初始化</span></span><br><span class="line">    thePhones = phone;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象的成员变量的初始化动作发生在构造函数本体之前（即 <code>{</code> 之前）。所以上例中这些是赋值，而非初始化。例如 <code>theName</code> 它会先调用 <code>string</code> 类的默认构造函数，再对它进行赋新值。</p>
<p>构造函数应该使用成员初值列代替赋值动作，下面的 <code>theName</code> 直接调用 <code>string</code> 类的拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones) :</span><br><span class="line">                 theName(name), thePhones(phone), num(<span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于大多数类型而言，先调用默认构造函数再赋值 没有 只调用一次拷贝构造函数高效。</li>
<li>对于内置对象而言，初始化和赋值的成本相同。</li>
</ul>
<p><strong>注意：</strong> 如果成员变量是 <strong><code>const</code></strong> 或者是 <strong>引用</strong>，就更不能用赋值。</p>
<h2 id="2-内置类型的赋值操作移到函数里，以避免重复的工作"><a href="#2-内置类型的赋值操作移到函数里，以避免重复的工作" class="headerlink" title="2. 内置类型的赋值操作移到函数里，以避免重复的工作"></a>2. 内置类型的赋值操作移到函数里，以避免重复的工作</h2><p>许多类拥有多个构造函数，如果某个类含有许多成员变量和基类，多份成员初值列就会导致重复的工作。在成员初值列中合理的遗漏那些 <strong>“赋值和初始化成本相同”</strong> 的成员变量，并将这些 赋值操作 移动到某个函数里（通常是 <code>private</code>），供所有构造函数使用。</p>
<p>在 成员变量的初值<strong>由文件或者数据库导入</strong>时 特别适用。</p>
<h2 id="3-成员初始化次序"><a href="#3-成员初始化次序" class="headerlink" title="3. 成员初始化次序"></a>3. 成员初始化次序</h2><h3 id="3-1-类的成员初始化次序"><a href="#3-1-类的成员初始化次序" class="headerlink" title="3.1 类的成员初始化次序"></a>3.1 类的成员初始化次序</h3><ol>
<li>基类更早于其派生类初始化。</li>
<li>类的成员变量初始化次序和声明次序相同，与成员初值列的次序无关。</li>
</ol>
<p>例如 <code>array</code> 必须要知道维度大小，所以一定要保证次序。</p>
<h3 id="3-2-不同编译单元内的-non-local-static-对象的初始化次序"><a href="#3-2-不同编译单元内的-non-local-static-对象的初始化次序" class="headerlink" title="3.2 不同编译单元内的 non-local static 对象的初始化次序"></a>3.2 不同编译单元内的 <code>non-local static</code> 对象的初始化次序</h3><p>函数内的静态对象是 <code>local static</code>，其他静态对象是<code>non-local static</code>。</p>
<p>假设在两个文件里，每个都至少含有一个 <code>non-local static</code> 对象。若某文件里的 <code>non-local static</code> 对象的初始化使用了另一个文件里的 <code>non-local static</code> 对象，它所用到的这个对象可能未被初始化，因为 C+++ 对于 “定义于不同编译单元内的对象” 的初始化次序没有明确规定。</p>
<p>例如：</p>
<ol>
<li><p>某个文件系统：  </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">size_t</span> numDisks() <span class="keyword">const</span>;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户用于处理文件系统的目录</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    Directory( params ) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">size_t</span> disks = tfs.numDisks();</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Directory <span class="title">tempdir</span><span class="params">( params )</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这里的初始化的次序非常重要：除非 <code>tfs</code> 在 <code>tempDir</code> 之前先被初始化，否则 <code>tempDir</code> 的构造函数会用到尚未初始化的 <code>tfs</code>。我们如何确定 <code>tfs</code> 会在 <code>tempDir</code> 之前被初始化呢？</p>
<p>一个解决办法是：将每个 <code>non-local</code> 对象搬到自己的专属函数内（该对象在此函数内被声明为 <code>static</code>），函数返回一个<strong>引用</strong>绑定它所含的对象。然后用户调用这个函数，而不是直接使用其中的对象。（<strong>Singleton模式</strong>）</p>
<p>C++保证函数内的 <code>local static</code> 对象会在 调用该函数时，首次遇到该表达式时，被初始化。</p>
<p>这样不仅解决了初始化次序问题，并且如果你从未调用这个函数（从未有需求使用这个对象），就绝不会引发构造和析构的成本。真正的 <code>non-local static</code> 对象可不会这样。</p>
<p>我们修改代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">size_t</span> numDisks() <span class="keyword">const</span>;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    Directory( params ) &#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">size_t</span> disks = tfs().numDisks();</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempdir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这种 <code>reference-returning</code> 函数可以，避免初始化次序问题，前提是两个对象有着合理的次序。如果对象A必须在对象B前初始化，但A的初始化又受制于B是否已经初始化，这种情况无法解决，应该避免这种情况发生。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul>
<li>为内置类型进行手动初始化，因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。成员初值列的成员变量的次序应该和声明次序相同。</li>
<li>为了避免 “不同编译单元的初始化次序” 问题，用  <code>reference-returning</code> 函数内的 <code>local static</code> 对象替代 <code>non-local static</code> 对象。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>条款03-尽可能使用const</title>
    <url>/2020/03/05/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE03-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</url>
    <content><![CDATA[<ul>
<li><a href="#条款03-尽可能使用-const">条款03-尽可能使用 <code>const</code></a><ul>
<li><a href="#1-复习-const-的用法">1. 复习 <code>const</code> 的用法</a></li>
<li><a href="#2-函数返回常量可以减少错误">2. 函数返回常量可以减少错误</a></li>
<li><a href="#3-const-成员函数">3. <code>const</code> 成员函数</a></li>
<li><a href="#4-两个流行概念-bitwise-constness-、logical-constness">4. 两个流行概念 bitwise constness 、logical constness</a><ul>
<li><a href="#4-1-bitwise-constness">4.1 bitwise constness</a></li>
<li><a href="#4-2-logical-constness">4.2 logical constness</a></li>
</ul>
</li>
<li><a href="#5-在-const-和-non-const-成员函数中避免重复">5. 在 <code>const</code> 和 <code>non-const</code> 成员函数中避免重复</a></li>
<li><a href="#6-总结">6. 总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="条款03-尽可能使用-const"><a href="#条款03-尽可能使用-const" class="headerlink" title="条款03-尽可能使用 const"></a>条款03-尽可能使用 <code>const</code></h1><h2 id="1-复习-const-的用法"><a href="#1-复习-const-的用法" class="headerlink" title="1. 复习 const 的用法"></a>1. 复习 <code>const</code> 的用法</h2><p>可以通过这篇文章先复习一下 <code>const</code> 的使用： <a href="https://blog.csdn.net/qq_36408085/article/details/104080087" target="_blank" rel="noopener">顶层/底层const</a>   or <a href="https://www.faker.top/2020/01/05/CPP-Primer/Notes/2.4const限定符/" target="_blank" rel="noopener">顶层/底层const</a></p>
<p>简单介绍一下 <code>const</code> 的使用：</p>
<ul>
<li>顶层 <code>const</code>，表示指针本身是常量</li>
<li>底层 <code>const</code>，表示指针所指对象是个常量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span>* p1 = s;  <span class="comment">// 非底层，非顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p2 = s;  <span class="comment">// 底层，和 char const * p2 = s;相同，仅写法不同</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p3 = s;  <span class="comment">// 顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = s;  <span class="comment">// 底层，顶层</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; j = i;  <span class="comment">// 顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k = i;  <span class="comment">// 顶层</span></span><br></pre></td></tr></table></figure>

<h2 id="2-函数返回常量可以减少错误"><a href="#2-函数返回常量可以减少错误" class="headerlink" title="2. 函数返回常量可以减少错误"></a>2. 函数返回常量可以减少错误</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span>... ...&#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这里重载 <code>*</code> 函数，返回的是一个 <code>const</code>。</p>
<p>如果我们返回的不是 <code>const</code>，那么下面代码就会产生很难排查的问题，因为编译器认为它是对的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rational a, b ,c;</span><br><span class="line">    <span class="keyword">if</span> ((a * b) = c) &#123;</span><br><span class="line">        ... ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>(a * b) = c</code> ，你可能疑惑为什么有人会在 <code>a * b</code> 的结果上赋值，或许这个人只是想比较是否相等，而少写了个 <code>=</code> 。但是编译器认为这就是个赋值操作（赋值操作也可以转为 <code>bool</code> 类型），没有任何语法问题。</p>
<p>我们的代码就会遇到问题，因为无论怎么样 <code>(a * b) = c</code> 都是 <strong>真</strong> ，我们会浪费时间来排查这种逻辑错误。</p>
<p>如果返回的是 <code>const</code> ，那么这个赋值操作就是不允许的，编译器就会报错。</p>
<h2 id="3-const-成员函数"><a href="#3-const-成员函数" class="headerlink" title="3. const 成员函数"></a>3. <code>const</code> 成员函数</h2><p><code>const</code> 成员函数内 不能修改类的成员，它有两个优点：</p>
<ol>
<li>该函数可以操作 <code>const</code> 对象。</li>
<li>使得类的接口容易理解。知道哪个函数能改动对象内容，哪个函数不能。</li>
</ol>
<h2 id="4-两个流行概念-bitwise-constness-、logical-constness"><a href="#4-两个流行概念-bitwise-constness-、logical-constness" class="headerlink" title="4. 两个流行概念 bitwise constness 、logical constness"></a>4. 两个流行概念 bitwise constness 、logical constness</h2><h3 id="4-1-bitwise-constness"><a href="#4-1-bitwise-constness" class="headerlink" title="4.1 bitwise constness"></a>4.1 bitwise constness</h3><p><strong>bitwise constness</strong> 阵营的人认为，成员函数只有在不改变对象的任何成员变量（<code>static</code> 除外）时，才是 <code>const</code> 的，也就是说它不更改对象内的任何一个 <code>bit</code> 。编译器采取的标准就是这个。</p>
<p>然而，一些成员函数虽然不完全具备 <code>const</code> 的性质，却能通过 <strong>bitwise</strong> 测试。具体来说，一个更改了 <strong>指针所指物</strong> 的成员函数虽然不算是 <code>const</code>，但如果只有指针（而非其所指物）属于对象，那么此函数为 <strong>bitwise constness</strong> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pText[position];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的 <code>operator[]</code> 声明为 <code>const</code> 的，这确实是 <strong>bitwise constness</strong> 的，但是返回的确实一个内部值，我们可以通过这个返回值来修改我们的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'j'</span>;  <span class="comment">// 此时变为 "jello"</span></span><br><span class="line">cctb[<span class="number">1</span>] = <span class="string">'k'</span>;  <span class="comment">// 此时变为 "jkllo"</span></span><br></pre></td></tr></table></figure>

<p>我们创建了一个常量对象，而且只调用了 <code>const</code> 成员函数，但是我们最终还是改变了它的值。</p>
<p><strong>注：</strong> 如果我们确实需要保护一个 <strong>指针成员所指物</strong>，使其不会被改变。我们可以将该指针封装到一个模板中，具体做法参考：<a href="https://stackoverflow.com/questions/19210543/in-c-if-a-member-pointer-point-to-some-data-how-to-protect-that-data-from-be" target="_blank" rel="noopener">在c++中，如果成员指针指向某些数据，如何保护该数据不被修改？</a></p>
<h3 id="4-2-logical-constness"><a href="#4-2-logical-constness" class="headerlink" title="4.2 logical constness"></a>4.2 logical constness</h3><p>由此，我们引出了另一个概念 <strong>logical constness</strong> ：一个 <code>const</code> 成员函数可以修改它所处理的对象内的某些 <code>bits</code> ，但只有当客户端侦测不出的情况下才可以。如下例所示，我们可以在 <code>const</code> 成员函数里修改一些 <strong>私有成员变量</strong>，这些变量对于用户来说是看不见的，所以他们不会知道 也不必知道这些变化。<br>我们使用 <code>mutable</code> 关键字修饰的变量，即使在 <code>const</code> 成员函数内也可以被修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> CTextBlock::length() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);</span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-在-const-和-non-const-成员函数中避免重复"><a href="#5-在-const-和-non-const-成员函数中避免重复" class="headerlink" title="5. 在 const 和 non-const 成员函数中避免重复"></a>5. 在 <code>const</code> 和 <code>non-const</code> 成员函数中避免重复</h2><p>当某个成员函数执行很多操作时，我们要把这些操作同时放进 <code>const</code> 和 <code>non-const</code> 成员函数中，这样的代码就很长且重复。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) &#123;</span><br><span class="line">        ... <span class="comment">//</span></span><br><span class="line">        ... <span class="comment">// 其他操作</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">        ... <span class="comment">//</span></span><br><span class="line">        ... <span class="comment">// 其他操作</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>因此我们可以令其中一个去调用另一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) &#123;</span><br><span class="line">        ... <span class="comment">//</span></span><br><span class="line">        ... <span class="comment">// 其他操作</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们先将 <code>*this</code> 由原来的 <code>TextBlock&amp;</code> 转型为 <code>const TextBlock&amp;</code> ，使它可以调用 <code>cosnt</code> 版本的函数，<code>cosnt</code> 版本的函数返回的是一个 <code>const char&amp;</code>，因此我们还要对返回值转型，使用 <code>const_cat&lt;char&amp;&gt;</code> 移除返回值的 <code>const</code>。</p>
<p><strong>注意</strong>：反向做法——令 <code>const</code> 版本调用 <code>non-const</code> 版本是错误的。<br>因为 <code>non-const</code> 函数并不承诺不改变成员变量，我们可能会改变 <em>不应改动的对象</em>。<br>同时，我们要想<code>const</code> 版本调用 <code>non-const</code> 版本，必须让 <code>*this</code> 由 <code>const TextBlock&amp;</code> 通过 <code>const_cast</code> 变为 <code>TextBlock&amp;</code>。这种做法是不安全的（反向操作是安全的）。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ul>
<li>将某些东西声明为 <code>cosnt</code> 可帮助编译器侦测出错误用法。<code>const</code> 可以被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施 <strong>bitwise constness</strong> ，但你编写的程序应该使用 <strong>logical constness</strong> 。</li>
<li>当 <code>const</code> 和 <code>non-const</code> 成员函数有着相同的实现时（内部代码相同），令 <code>nono-const</code> 版本调用 <code>const</code> 版本可以避免重复，反之则错误。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP 算法详解</title>
    <url>/2020/02/18/Algorithm/kmp%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li><a href="#1-暴力算法及其弊端">1. 暴力算法及其弊端</a></li>
<li><a href="#2-最长的相同前后缀">2. 最长的相同前后缀</a><ul>
<li><a href="#2-1-最长的相同前后缀在kmp中发挥的作用">2.1 最长的相同前后缀在KMP中发挥的作用</a></li>
<li><a href="#2-2-最长的相同前后缀的定义和求法">2.2 最长的相同前后缀的定义和求法</a></li>
<li><a href="#2-3-最长的相同前后缀的算法">2.3 最长的相同前后缀的算法</a></li>
</ul>
</li>
<li><a href="#3-kmp完整代码">3. KMP完整代码</a></li>
</ul>
<p><strong>KMP</strong> 是一种字符串匹配算法，即我们要在源字符串 <code>src</code> 中寻找目标字符串 <code>dst</code>。</p>
<a id="more"></a>

<h2 id="1-暴力算法及其弊端"><a href="#1-暴力算法及其弊端" class="headerlink" title="1. 暴力算法及其弊端"></a>1. 暴力算法及其弊端</h2><p>我们有两个字符串，源字符串 <code>src = &quot;abcabcaba&quot;</code>，目标字符串 <code>dst = &quot;abcaba&quot;</code>，我们要在 <code>src</code> 中寻找 <code>dst</code>，并输出 <code>src</code> 中 <strong>所有匹配到的字符串</strong> 的第一个字符的位置，该例子就是 <code>3</code>。</p>
<p>下面的幻灯片(1)带你理解暴力算法和KMP的区别。</p>
<iframe src="https://myslide.cn/player/22247" width="788" height="480" frameborder="1" marginwidth="0" marginheight="0" scrolling="no" style="margin-bottom:5px; max-width: 100%;" allowfullscreen></iframe>

<p>暴力算法代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> src, <span class="built_in">string</span> dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = dst.size();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = src.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j; j &lt; m; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src[i + j] != dst[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-最长的相同前后缀"><a href="#2-最长的相同前后缀" class="headerlink" title="2. 最长的相同前后缀"></a>2. 最长的相同前后缀</h2><h3 id="2-1-最长的相同前后缀在KMP中发挥的作用"><a href="#2-1-最长的相同前后缀在KMP中发挥的作用" class="headerlink" title="2.1 最长的相同前后缀在KMP中发挥的作用"></a>2.1 最长的相同前后缀在KMP中发挥的作用</h3><p>我们在幻灯片(1) 中讲到（下图），因为当前比较位置（蓝色箭头）之前的 <code>dst[0] ~ dst[4]</code> 的前缀（<code>dst[0~1] = &quot;ab&quot;</code>）和后缀（<code>dst[3~4] = &quot;ab&quot;</code>）相同，并且显然 <code>dst[3~4] = src[3~4] = &quot;ab&quot;</code> ，因此必有<code>dst[0~1] = src[3~4]</code> ，我们才可以直接略过这部分的比较。</p>
<img src="/2020/02/18/Algorithm/kmp%E8%AF%A6%E8%A7%A3/kmp-1.png" height="480" width="700">

<p>这里的主要功劳是 <code>dst</code> 前5个字符（比较位置之前） 的 <strong>最长的相同前后缀</strong>，他帮助我们省去了不必要的操作。</p>
<h3 id="2-2-最长的相同前后缀的定义和求法"><a href="#2-2-最长的相同前后缀的定义和求法" class="headerlink" title="2.2 最长的相同前后缀的定义和求法"></a>2.2 最长的相同前后缀的定义和求法</h3><p>我们继续以 <code>dst = &quot;abcaba&quot;</code> 为例，它的最长前后缀数组（简称为 <strong>匹配数组</strong>）为 <code>F = {0, 0, 0, 1, 2, 1}</code>， <code>F</code> 也可表示字符串的<strong>对称程度</strong>。<br><code>F[i]</code> （i从0开始） 表示 <code>dst[0] ~ dst[i]</code> 组成的字符串 的最长相同前后缀。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dst = a b c a b a</span><br><span class="line">  F = <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>前缀集合 <code>pre</code> ：除最后一个字符外，前面所有 不同长度字符串 的集合。<br>后缀集合 <code>suf</code> ：除第一个字符外，后面所有 不同长度字符串 的集合。<br>例如 <code>&quot;abc&quot;</code> ，前缀集合 <code>pre = {&quot;a&quot;, &quot;ab&quot;}</code>，后缀集合 <code>suf = {&quot;c&quot;, &quot;bc&quot;}</code>。<br>而 单个字符的字符串 <code>&quot;a&quot;</code> 无前后缀。</p>
<p>下面一步步求 <code>dst = &quot;abcaba&quot;</code> 的匹配数组 <code>F</code>。</p>
<!--
1. `"a"`：没有前缀也没有后缀。`F[0] = 0`。
2. `"ab"`：前缀集合 `pre = {"a"}`，后缀集合 `suf = {"c"}`。对应都不相等，`F[1] = 0`。
3. `"abc"`：前缀集合 `pre = {"a", "ab"}`，后缀集合 `suf = {"c", "bc"}`。对应都不相等，`F[2] = 0`。
4. `"abca"` 前缀集合 `pre = {"a", "ab", "abc"}`，后缀集合 `suf = {"a", "ca", "bca"}`。有 `pre[0] = suf[0]`，所以 `F[3] = 2`。
5. `"abcab"`：前缀集合 `pre = {"a", "ab", "abc", "abca"}`，后缀集合 `suf = {"b", "ab", "cab", "bcab"}`。有 `pre[1] = suf[1]`，所以 `F[4] = 2`。
6. `"abcaba"`：前缀集合 `pre = {"a", "ab", "abc", "abca", "abcab"}`，后缀集合 `suf = {"a", "ba", "aba", "caba", "bcaba"}`。有 `pre[0] = suf[0]`，所以 `F[5] = 1`。
-->
<style>
table th:first-of-type {
    width: ;
}
table th:nth-of-type(2) {
    width: 10%;
}
table th:nth-of-type(3) {
    width: ;
}
table th:nth-of-type(4) {
    width: ;
}
table th:nth-of-type(5) {
    width: 17%;
}
table th:nth-of-type(6) {
    width: 10%;
}
</style>

<table>
<thead>
<tr>
<th><code>i</code></th>
<th>字符串</th>
<th>前缀集合</th>
<th>后缀集合</th>
<th>是否相等</th>
<th><code>F</code>数组</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><code>&quot;a&quot;</code></td>
<td><code>pre = {}</code></td>
<td><code>suf = {}</code></td>
<td>否</td>
<td><code>F[1] = 0</code></td>
</tr>
<tr>
<td>1</td>
<td><code>&quot;ab&quot;</code></td>
<td><code>pre = {&quot;a&quot;}</code></td>
<td><code>suf = {&quot;c&quot;}</code></td>
<td>否</td>
<td><code>F[1] = 0</code></td>
</tr>
<tr>
<td>2</td>
<td><code>&quot;abc&quot;</code></td>
<td><code>pre = {&quot;a&quot;, &quot;ab&quot;}</code></td>
<td><code>suf = {&quot;c&quot;, &quot;bc&quot;}</code></td>
<td>否</td>
<td><code>F[2] = 0</code></td>
</tr>
<tr>
<td>3</td>
<td><code>&quot;abca&quot;</code></td>
<td><code>pre = {&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;}</code></td>
<td><code>suf = {&quot;a&quot;, &quot;ca&quot;, &quot;bca&quot;}</code></td>
<td><code>pre[0] = suf[0]</code></td>
<td><code>F[3] = 1</code></td>
</tr>
<tr>
<td>4</td>
<td><code>&quot;abcab&quot;</code></td>
<td><code>pre = {&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abca&quot;}</code></td>
<td><code>suf = {&quot;b&quot;, &quot;ab&quot;, &quot;cab&quot;, &quot;bcab&quot;}</code></td>
<td><code>pre[1] = suf[1]</code></td>
<td><code>F[4] = 2</code></td>
</tr>
<tr>
<td>5</td>
<td><code>&quot;abcaba&quot;</code></td>
<td><code>pre = {&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abca&quot;, &quot;abcab&quot;}</code></td>
<td><code>suf = {&quot;a&quot;, &quot;ba&quot;, &quot;aba&quot;, &quot;caba&quot;, &quot;bcaba&quot;}</code></td>
<td><code>pre[0] = suf[0]</code></td>
<td><code>F[5] = 1</code></td>
</tr>
</tbody></table>
<h3 id="2-3-最长的相同前后缀的算法"><a href="#2-3-最长的相同前后缀的算法" class="headerlink" title="2.3 最长的相同前后缀的算法"></a>2.3 最长的相同前后缀的算法</h3><p>上一小节我们讲了如何求出 匹配数组 <code>F</code>，我们使用的是直接观察法，但是代码中这么暴力的枚举是很浪费的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dst = a b c a b a</span><br><span class="line">  F = <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>首先，我们可以确定所有字符串的 <code>F[0] = 0</code>。</li>
<li>当第 <code>i</code> 个字符的前一个字符的 <code>F[i - 1] = j</code> （<code>j</code>可能等于<code>0</code>）时，这说明前面的字符匹配了 <code>j</code> 个字符，我们判断 <code>dst[i]</code>  和 第 <code>j + 1</code> 个字符（即：<code>dst[j]</code>）是否相等即可。我们分为<strong>三种情况</strong>。</li>
<li>当 <code>F[i - 1] = j = 0</code> 时，即当第 <code>i</code> 个字符的前一个字符的 <code>F[i - 1] = 0</code>，那么我们直接比较 <code>dst[i]</code> 和 <code>dst[0]</code> 即可，因为这时它要么匹配一个字符，要么一个字符也不匹配（即 <code>F[i] = 1 or 0</code>）。例如我们求 <code>abcaba</code> 的 <code>c: F[2] = ?</code>，很明显，前面的 <code>b : F[1] = 0</code>，只需判断 <code>c</code> 和开头的字符是否相同即可。</li>
<li>当 <code>F[i - 1] = j != 0</code> 时，如果 <code>dst[i] == dst[j]</code> ，那么 <code>F[i] = F[i - 1] + 1</code>。例如 我们求 <code>abcaba</code> 的 第二个<code>b: F[4] = ?</code>，前一个字符 <code>a: F[3] = 1</code>，说明 <code>dst[4]</code> 可以继承 <code>dst[3]</code> 的<strong>对称性</strong>。</li>
<li>当 <code>F[i - 1] = j != 0</code> 时，如果 <code>dst[i] != dst[j]</code>，那么 <code>F[i]</code> 就一定为 <code>0</code> 了吗？不一定。因为还可能存在 <strong>子对称</strong>。</li>
</ol>
<p>我们详细讲解 <strong>5</strong> 中的 子对称，（通俗的来说就是，虽然不能构成大的对称，但是能构成小的对称）。</p>
<p><strong>子对称</strong> 指当前字符和前面第一个 <code>F</code> 值不为 <code>0</code> 的字符 之间的所有字符，组成的字符串，是否有对称性。</p>
<img src="/2020/02/18/Algorithm/kmp%E8%AF%A6%E8%A7%A3/kmp-2.png" height="350" width="700">
<img src="/2020/02/18/Algorithm/kmp%E8%AF%A6%E8%A7%A3/kmp-3.png" height="350" width="700">

<p>求 <code>F</code> 的实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dst = <span class="string">"agctagcagctagct"</span>;</span><br><span class="line">    <span class="comment">// string dst = "abaabbabaab";</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; F(dst.size());</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dst.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = F[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 寻找子对称串</span></span><br><span class="line">        <span class="keyword">while</span> (dst[i] != dst[j] &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">            j = F[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dst[j] == dst[i])</span><br><span class="line">            F[i] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            F[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (auto elem : F)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; elem &lt;&lt; " ";</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-KMP完整代码"><a href="#3-KMP完整代码" class="headerlink" title="3. KMP完整代码"></a>3. KMP完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dst = <span class="string">"abaabbabaab"</span>;</span><br><span class="line">    <span class="built_in">string</span> src = <span class="string">"abaabaabbabaaabaabbabaabaabbabaab"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; F(dst.size());</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dst.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = F[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 寻找子对称串</span></span><br><span class="line">        <span class="keyword">while</span> (dst[i] != dst[j] &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">            j = F[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dst[j] == dst[i])</span><br><span class="line">            F[i] = j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            F[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (auto elem : F)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; elem &lt;&lt; " ";</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; src.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dst[i] != src[j])  &#123;</span><br><span class="line">            <span class="comment">// dst第一个字符无法匹配，直接匹配下一个。考虑数组越界。</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i = F[i - <span class="number">1</span>];  <span class="comment">// 直接略过dst中对称的部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == dst.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到之后打印位置，继续寻找下一个</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; j - i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                i = F[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有匹配完成，继续匹配下一位</span></span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>CppQuiz：Question-42，Difficulty-normal</title>
    <url>/2020/02/14/CppQuiz/Question42-2-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-Question-42，Difficulty-normal"><a href="#1-Question-42，Difficulty-normal" class="headerlink" title="1. Question-42，Difficulty-normal"></a>1. Question-42，Difficulty-normal</h2><blockquote>
<p><a href="http://cppquiz.org/quiz/question/42" target="_blank" rel="noopener">cppquiz: question#42</a></p>
</blockquote>
<p>根据C++ 17标准，该程序的输出是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        答案
    </div>
    <div class="spoiler-content">
        <p><strong>1133</strong></p>

    </div>
</div>

<div class="spoiler collapsed">
    <div class="spoiler-title">
        解析
    </div>
    <div class="spoiler-content">
        <ol>
<li><p><code>A a1;</code> 毫无疑问，默认初始化，调用无参构造函数即默认构造函数。</p>
</li>
<li><p><code>A a2{};</code> 有点困难。我们会认为它是一个列表初始化，调用 <code>A(std::initializer_list&lt;int&gt;)</code>，以一个空列表传入这个构造函数。但我们必须要知道 <a href="https://zh.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener"><strong>列表初始化</strong></a> 有一条规则：若花括号初始化列表无任何元素，则执行 <a href="https://zh.cppreference.com/w/cpp/language/value_initialization" target="_blank" rel="noopener"><strong>值初始化</strong></a>。对于值初始化（<code>T object{}</code>）来说，若 <code>T</code> 是有至少一个用户提供的任意种类的构造函数的类类型，则调用默认构造函数。我们的类 <code>A</code> 有一个默认构造函数，所以输出是 <code>&quot;1&quot;</code>。</p>
</li>
<li><p><code>A a3{1};</code> 对于这个我们可能会在答案 <code>&quot;2&quot;</code> 和 <code>&quot;3&quot;</code> 纠结一小会。<br>但它其实遵守这样的规则（重载决议）：对于非聚合类来说，  </p>
<ol>
<li><p>首先的候选函数是，初始化器列表的构造函数（<code>initializer_list</code>）。</p>
</li>
<li><p>若我们没有这样的构造函数，那么就会考虑其他构造函数，并且参数列表就是初始化器列表中的元素。<br>本例中它就会变为 <code>A a3(1)</code>，调用 <code>A(int)</code> 构造函数。</p>
<p><strong>但是</strong>我们有一个<code>initializer_list</code>的构造函数，所以输出 <code>&quot;3&quot;</code> 。</p>
</li>
</ol>
</li>
<li><p><code>A a4{1, 2};</code> 毫无疑问，调用 <code>A(std::initializer_list&lt;int&gt;)</code> ，输出 <code>&quot;3&quot;</code> 。</p>
</li>
</ol>

    </div>
</div>

<h2 id="2-题目变体"><a href="#2-题目变体" class="headerlink" title="2. 题目变体"></a>2. 题目变体</h2><p>我们注释掉了两行，分别是默认构造函数，同时注释掉 <code>A a1</code>（否则会报错）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="comment">// A() &#123; std::cout &lt;&lt; "1"; &#125;</span></span><br><span class="line">    A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>)) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A a1;</span></span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>为什么 <code>A a1</code> 执行出错？</p>
 <div class="spoiler collapsed">
    <div class="spoiler-title">
        答案/解析
    </div>
    <div class="spoiler-content">
        <p>因为此时没有了 <strong>默认构造函数</strong>，编译器也不会生成 <strong>合成的默认构造函数</strong>。</p>
<p><strong>规则：</strong> 只有我们没有定义其他任何构造函数，编译器才会为我们生成 合成的默认构造函数。(C++ Primer 5th P236)</p>

    </div>
</div>
</li>
<li><p>程序这次输出什么？</p>
 <div class="spoiler collapsed">
    <div class="spoiler-title">
        答案/解析
    </div>
    <div class="spoiler-content">
        <p><strong>333</strong>  </p>
<p>似乎有点奇怪。对于 <code>A a2{};</code> 我们还需记住另一条规则：<br>若花括号初始化列表无任何元素，且 T 是没有默认构造函数但带有接受 <code>initializer_list</code> 的构造函数的类类型，则进行列表初始化。ok，这时我们才会把它认为是一个空列表传给 <code>initializer_list</code> 的构造函数。</p>

    </div>
</div>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>CppQuiz</category>
      </categories>
      <tags>
        <tag>initial</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客如何折叠(显示/隐藏)部分文字</title>
    <url>/2020/02/14/Hexo/h6-%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<ul>
<li><a href="#1-html语法使用-lt-details-gt-元素">1. HTML语法：使用 <code>&lt;details&gt;</code> 元素</a><ul>
<li><a href="#1-1-如何使用">1.1 如何使用</a></li>
<li><a href="#1-2-实现效果">1.2 实现效果</a></li>
</ul>
</li>
<li><a href="#2-hexo-sliding-spoiler插件">2. hexo-sliding-spoiler插件</a><ul>
<li><a href="#2-1-安装和自定义设置">2.1 安装和自定义设置</a><ul>
<li><a href="#【1】安装">【1】安装</a></li>
<li><a href="#【2】自定义设置">【2】自定义设置</a></li>
</ul>
</li>
<li><a href="#2-2-如何使用">2.2 如何使用</a></li>
<li><a href="#2-3-实现效果">2.3 实现效果</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<blockquote>
<p>参考：<a href="https://github.com/theme-next/hexo-theme-next/issues/200" target="_blank" rel="noopener">Github/hexo-theme-next
</a></p>
</blockquote>
<h2 id="1-HTML语法：使用-lt-details-gt-元素"><a href="#1-HTML语法：使用-lt-details-gt-元素" class="headerlink" title="1. HTML语法：使用 &lt;details&gt; 元素"></a>1. HTML语法：使用 <code>&lt;details&gt;</code> 元素</h2><h3 id="1-1-如何使用"><a href="#1-1-如何使用" class="headerlink" title="1.1 如何使用"></a>1.1 如何使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>隐藏内容的标题<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"></span><br><span class="line">隐藏文字隐藏文字隐藏文字。  </span><br><span class="line">支持 `markdown` 语法</span><br><span class="line"></span><br><span class="line">- 支持 **粗体**、*斜体*</span><br><span class="line">- 支持列表</span><br><span class="line">- 支持md插入图片语法：![1](hexo-pictures/hexo-6_1.png)</span><br><span class="line">- 支持html插入图片语法：<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"hexo-pictures/hexo-6_1.png"</span> <span class="attr">width</span> = <span class="string">"50%"</span>&gt;</span></span><br><span class="line">- 支持行内代码 `markdown`</span><br><span class="line">- 支持代码块</span><br><span class="line">  </span><br><span class="line">    ```cpp</span><br><span class="line">    #include <span class="tag">&lt;<span class="name">initializer_list</span>&gt;</span></span><br><span class="line">    #include <span class="tag">&lt;<span class="name">iostream</span>&gt;</span></span><br><span class="line">    struct A &#123;</span><br><span class="line">        A() &#123; std::cout &lt;&lt; "1"; &#125;</span><br><span class="line">        A(int) &#123; std::cout &lt;&lt; "2"; &#125;</span><br><span class="line">        A(std::initializer_list&lt;int&gt;) &#123; std::cout &lt;&lt; "3"; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    int main(int argc, char *argv[]) &#123;</span><br><span class="line">        A a1;</span><br><span class="line">        A a2&#123;&#125;;</span><br><span class="line">        A a3&#123; 1 &#125;;</span><br><span class="line">        A a4&#123; 1, 2 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ```// 此处加点文字，防止排版错误：因为这是代码块内的代码。使用时可删除</span><br><span class="line"></span><br><span class="line">- 支持表格</span><br><span class="line"></span><br><span class="line">    |文字|文字|</span><br><span class="line">    |-|-|</span><br><span class="line">    |文字|文字|</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-实现效果"><a href="#1-2-实现效果" class="headerlink" title="1.2 实现效果"></a>1.2 实现效果</h3><details>
  <summary>隐藏内容的标题</summary>

<p>隐藏文字隐藏文字隐藏文字。<br>支持 <code>markdown</code> 语法</p>
<ul>
<li><p>支持 <strong>粗体</strong>、<em>斜体</em></p>
</li>
<li><p>支持列表</p>
</li>
<li><p>支持md插入图片语法：<img src="/2020/02/14/Hexo/h6-%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97/hexo-6_1.png" alt="1"></p>
</li>
<li><p>支持html插入图片语法：<img src="/2020/02/14/Hexo/h6-%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97/hexo-6_1.png" width="50%"></p>
</li>
<li><p>支持行内代码 <code>markdown</code></p>
</li>
<li><p>支持代码块</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持表格</p>
<table>
<thead>
<tr>
<th>文字</th>
<th>文字</th>
</tr>
</thead>
<tbody><tr>
<td>文字</td>
<td>文字</td>
</tr>
</tbody></table>
</li>
</ul>
</details>

<hr>
<h2 id="2-hexo-sliding-spoiler插件"><a href="#2-hexo-sliding-spoiler插件" class="headerlink" title="2. hexo-sliding-spoiler插件"></a>2. hexo-sliding-spoiler插件</h2><h3 id="2-1-安装和自定义设置"><a href="#2-1-安装和自定义设置" class="headerlink" title="2.1 安装和自定义设置"></a>2.1 安装和自定义设置</h3><h4 id="【1】安装"><a href="#【1】安装" class="headerlink" title="【1】安装"></a>【1】安装</h4><p>官网有安装教程：</p>
<blockquote>
<p>插件地址：<a href="https://github.com/fletchto99/hexo-sliding-spoiler" target="_blank" rel="noopener">hexo-sliding-spoiler</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install hexo-sliding-spoiler --save</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/14/Hexo/h6-%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97/hexo-6_4.gif" alt="1"></p>
<h4 id="【2】自定义设置"><a href="#【2】自定义设置" class="headerlink" title="【2】自定义设置"></a>【2】自定义设置</h4><ol>
<li><p>默认是 <code>Show: .../ Hide: ...</code>，我们可以更改前面的字。</p>
</li>
<li><p>打开文件 <code>hexo\node_modules\hexo-sliding-spoiler\assetsspoiler.css</code>，找到25-31行，修改其中的 <code>content</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.spoiler</span><span class="selector-class">.collapsed</span> <span class="selector-class">.spoiler-title</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"Show: "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.spoiler</span><span class="selector-class">.expanded</span> <span class="selector-class">.spoiler-title</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"Hide: "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-2-如何使用"><a href="#2-2-如何使用" class="headerlink" title="2.2 如何使用"></a>2.2 如何使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;% spoiler <span class="string">"隐藏内容的标题"</span> %&#125;</span><br><span class="line"></span><br><span class="line">隐藏文字隐藏文字隐藏文字。  </span><br><span class="line">支持 `markdown` 语法</span><br><span class="line"></span><br><span class="line">- 支持 **粗体**、*斜体*</span><br><span class="line">- 支持列表</span><br><span class="line">- 支持md插入图片语法：![<span class="number">1</span>](hexo-pictures/hexo<span class="number">-6</span>_1.png)</span><br><span class="line">- 支持html插入图片语法：&lt;img src = <span class="string">"hexo-pictures/hexo-6_1.png"</span>&gt;</span><br><span class="line">- 支持行内代码 `markdown`</span><br><span class="line">- 支持代码块</span><br><span class="line">  </span><br><span class="line">    ```cpp</span><br><span class="line">    #include &lt;<span class="built_in">initializer_list</span>&gt;</span><br><span class="line">    #include &lt;iostream&gt;</span><br><span class="line">    struct A &#123;</span><br><span class="line">        A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">        A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">        A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">        A a1;</span><br><span class="line">        A a2&#123;&#125;;</span><br><span class="line">        A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">        A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ```<span class="comment">// 此处加点文字，防止排版错误：因为这是代码块内的代码。使用时可删除</span></span><br><span class="line"></span><br><span class="line">- 支持表格</span><br><span class="line"></span><br><span class="line">    |文字|文字|</span><br><span class="line">    |-|-|</span><br><span class="line">    |文字|文字|</span><br><span class="line"></span><br><span class="line">&#123;% endspoiler %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-实现效果"><a href="#2-3-实现效果" class="headerlink" title="2.3 实现效果"></a>2.3 实现效果</h3><div class="spoiler collapsed">
    <div class="spoiler-title">
        隐藏内容的标题
    </div>
    <div class="spoiler-content">
        <p>隐藏文字隐藏文字隐藏文字。<br>支持 <code>markdown</code> 语法</p>
<ul>
<li><p>支持 <strong>粗体</strong>、<em>斜体</em></p>
</li>
<li><p>支持列表</p>
</li>
<li><p>支持md插入图片语法：<img src="/2020/02/14/Hexo/h6-%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97/hexo-6_1.png" alt="1"></p>
</li>
<li><p>支持html插入图片语法：<img src="/2020/02/14/Hexo/h6-%E6%8A%98%E5%8F%A0%E6%96%87%E5%AD%97/hexo-6_1.png"></p>
</li>
<li><p>支持行内代码 <code>markdown</code></p>
</li>
<li><p>支持代码块</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持表格</p>
<table>
<thead>
<tr>
<th>文字</th>
<th>文字</th>
</tr>
</thead>
<tbody><tr>
<td>文字</td>
<td>文字</td>
</tr>
</tbody></table>
</li>
</ul>

    </div>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo g 时：Cannot read property &#39;replace&#39; of null</title>
    <url>/2020/02/14/Hexo/h5-Cannot%20read%20property%20&#39;replace&#39;%20of%20null/</url>
    <content><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>关键信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ERROR Render HTML failed: index.html</span><br><span class="line">TypeError: Cannot read property 'replace' of null</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>完整信息：</p>
<div class="spoiler collapsed">
    <div class="spoiler-title">
        完整信息
    </div>
    <div class="spoiler-content">
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ERROR Render HTML failed: index.html</span><br><span class="line">TypeError: Cannot read property 'replace' of null</span><br><span class="line">    at Hexo.externalLinkFilter (F:\Program Files\hexo\node_modules\hexo\lib\plugins\filter\after_render\external_link.js:<span class="number">45</span>:<span class="number">15</span>)</span><br><span class="line">    at Hexo.tryCatcher (F:\Program Files\hexo\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (F:\Program Files\hexo\node_modules\bluebird\js\release\method.js:<span class="number">15</span>:<span class="number">34</span>)</span><br><span class="line">    at F:\Program Files\hexo\node_modules\hexo\lib\extend\filter.js:<span class="number">60</span>:<span class="number">50</span></span><br><span class="line">    <span class="function">at <span class="title">tryCatcher</span> <span class="params">(F:\Program Files\hexo\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span></span></span><br><span class="line">    at Object.gotValue (F:\Program Files\hexo\node_modules\bluebird\js\release\reduce.js:166:18)</span><br><span class="line">    at Object.gotAccum (F:\Program Files\hexo\node_modules\bluebird\js\release\reduce.js:<span class="number">155</span>:<span class="number">25</span>)</span><br><span class="line">    at Object.tryCatcher (F:\Program Files\hexo\node_modules\bluebird\js\release\util.js:<span class="number">16</span>:<span class="number">23</span>)</span><br><span class="line">    at Promise._settlePromiseFromHandler (F:\Program Files\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">547</span>:<span class="number">31</span>)</span><br><span class="line">    at Promise._settlePromise (F:\Program Files\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">604</span>:<span class="number">18</span>)</span><br><span class="line">    at Promise._settlePromiseCtx (F:\Program Files\hexo\node_modules\bluebird\js\release\promise.js:<span class="number">641</span>:<span class="number">10</span>)</span><br><span class="line">    at _drainQueueStep (F:\Program Files\hexo\node_modules\bluebird\js\release\async.js:<span class="number">97</span>:<span class="number">12</span>)</span><br><span class="line">    at _drainQueue (F:\Program Files\hexo\node_modules\bluebird\js\release\async.js:<span class="number">86</span>:<span class="number">9</span>)</span><br><span class="line">    at Async._drainQueues (F:\Program Files\hexo\node_modules\bluebird\js\release\async.js:<span class="number">102</span>:<span class="number">5</span>)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (F:\Program Files\hexo\node_modules\bluebird\js\release\async.js:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">    <span class="function">at <span class="title">processImmediate</span> <span class="params">(internal/timers.js:<span class="number">439</span>:<span class="number">21</span>)</span></span></span><br></pre></td></tr></table></figure>

    </div>
</div>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>检查最近的一篇文章，开头的 <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener"><strong>Front-matter</strong></a> （文件最上方以 — 分隔的区域，用于指定个别文件的变量）格式是否正确。</p>
<ol>
<li>可以检查单词的拼写，空格，中英文冒号等等。</li>
<li>文章标题 <code>title:</code> 是否有特殊字符。例如 <code>%</code> ，我们必须使用转义字符 <code>&amp;#37</code> 代替它，否则就会报该错误。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>条款02-尽量以const,enum,inline替换#define</title>
    <url>/2020/02/06/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2define/</url>
    <content><![CDATA[<ul>
<li><a href="#条款02-尽量以constenuminline替换define">条款02-尽量以 <code>const</code>, <code>enum</code> , <code>inline</code> 替换 <code>#define</code></a><ul>
<li><a href="#1-define-定义的名称无法追踪，不利于调试">1. <code>#define</code> 定义的名称无法追踪，不利于调试</a></li>
<li><a href="#2-用常量替换-define-的两种特殊情况">2. 用常量替换 <code>#define</code> 的两种特殊情况</a><ul>
<li><a href="#2-1-定义指针常量">2.1 定义指针常量</a></li>
<li><a href="#2-2-类内常量成员">2.2 类内常量成员</a></li>
<li><a href="#2-3-特殊情况">2.3 特殊情况</a></li>
</ul>
</li>
<li><a href="#3-用-inline-函数替代类函数的宏-function-like-marco">3. 用 <code>inline</code> 函数替代类函数的宏 (function-like marco)</a></li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="条款02-尽量以-const-enum-inline-替换-define"><a href="#条款02-尽量以-const-enum-inline-替换-define" class="headerlink" title="条款02-尽量以 const, enum , inline 替换 #define"></a>条款02-尽量以 <code>const</code>, <code>enum</code> , <code>inline</code> 替换 <code>#define</code></h1><h2 id="1-define-定义的名称无法追踪，不利于调试"><a href="#1-define-定义的名称无法追踪，不利于调试" class="headerlink" title="1. #define 定义的名称无法追踪，不利于调试"></a>1. <code>#define</code> 定义的名称无法追踪，不利于调试</h2><p>当我们使用预处理指令 <code>#define RATIO = 1.653</code> 时，<code>RATIO</code> 这个名称并 <strong>没有被编译器所知道</strong>。这意味着，我们在调试中无法追踪到这个名称。</p>
<ol>
<li><p>调试过程中，我们无法在 变量监视 窗口查看到 <code>RATIO</code> 的值。当然这并不是主要问题，因为 <code>RATIO</code>是不变的，我们无需监视它。主要是为了说明，编译器没有将这个名称存入到调试器的记号表（symbol table）中。</p>
<p> <img src="/2020/02/06/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2define/02-01.png" alt="1"></p>
</li>
<li><p>当使用宏出现编译错误时，我们无法知道是不是宏出现了问题。<br>例如：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANIMAL_NAME dog_name</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">"Ben"</span>;</span><br><span class="line">    <span class="comment">// string dog_name;</span></span><br><span class="line">    ANIMAL_NAME = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果我们没有定义 <code>dog_name</code> 这个变量，那么我们的 <code>ANIMAL_NAME = name;</code> 语句就会出错，因为这句话宏替换为 <code>dog_name = name;</code>。<br> 此时编译器报错：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>:<span class="number">2</span>: error C2065: “dog_name”: 未声明的标识符</span><br></pre></td></tr></table></figure>

<p> 我们回到第6行找错时会疑惑，<code>dog_name</code> 是什么东西？</p>
<p> 当然，现代编译器越来越智能化，例如我使用 <code>Clang</code> 编译时，它会告诉我们出错的宏名称。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">6:2: error: use of undeclared identifier 'dog_name'</span><br><span class="line">         ANIMAL_NAME = name;</span><br><span class="line">         ^</span><br><span class="line">1:21: note: expanded from macro 'ANIMAL_NAME'</span><br><span class="line">          <span class="meta">#<span class="meta-keyword">define</span> ANIMAL_NAME dog_name</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>解决的方法是用一个常量替换掉宏：</strong><code>const double Ratio = 1.653;</code><br>这在VS中，也会建议这么做：</p>
<p><img src="/2020/02/06/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2define/02-02.png" alt="2"><br><img src="/2020/02/06/EffectiveC++/Notes/%E6%9D%A1%E6%AC%BE02-%E5%B0%BD%E9%87%8F%E4%BB%A5const-enum-inline%E6%9B%BF%E6%8D%A2define/02-03.png" alt="3"></p>
<h2 id="2-用常量替换-define-的两种特殊情况"><a href="#2-用常量替换-define-的两种特殊情况" class="headerlink" title="2. 用常量替换 #define 的两种特殊情况"></a>2. 用常量替换 <code>#define</code> 的两种特殊情况</h2><h3 id="2-1-定义指针常量"><a href="#2-1-定义指针常量" class="headerlink" title="2.1 定义指针常量"></a>2.1 定义指针常量</h3><p>有必要将指针定义为 常量指针（指针本身为常量），并且还要所指对象也是常量，即 <code>const char* const musicName = &quot;So Cold&quot;</code>。</p>
<p>当然我们更推荐使用 <code>string</code> 。<code>const std::string musicName(&quot;So Cold&quot;);</code></p>
<h3 id="2-2-类内常量成员"><a href="#2-2-类内常量成员" class="headerlink" title="2.2 类内常量成员"></a>2.2 类内常量成员</h3><p>为了将常量的定义域限制在类内，我们必须使它成为类的一个成员。</p>
<p><code>#define</code> 并不重视作用域，一旦宏被定义，那么在该语句之后都有效（除非被 <code>#undef</code>）。</p>
<p>为了确保该常量只有一份实体，必须使它成为一个 <code>static</code> 成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> score[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常情况下，类的静态成员不应该在类内初始化。但是 <code>const</code> 整型类型 我们可以在类内初始化它，并且不需要在类外提供额外的定义式。<br>若编译器要求提供定义式，我们需要提供定义式 <code>const int A::Num;</code> 放入实现文件而非头文件。<br>此处我们不需要再赋初值，因为我们在类内已经设置了。</p>
<p>当然有些旧编译器不允许这么做，或者只对整数才能进行。我们可以将初值放到类外定义式中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> ratio;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> B::ratio = <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><strong>Best Practice:</strong> 即使在常量静态数据成员在类内初始化了，在类的外部再定义一下该成员。</p>
<h3 id="2-3-特殊情况"><a href="#2-3-特殊情况" class="headerlink" title="2.3 特殊情况"></a>2.3 特殊情况</h3><p>还有一种特殊情况就是，不允许对类内常量静态数据成员，在类内进行初始化，但是我们又必须在编译期间知道该成员的值。这时我们可以使用枚举类型充当 <code>int</code>使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; Num = <span class="number">5</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> score[Num];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11 的 <code>constexpr</code> 已经支持在编译期间确定某个数据是常量了。</p>
<h2 id="3-用-inline-函数替代类函数的宏-function-like-marco"><a href="#3-用-inline-函数替代类函数的宏-function-like-marco" class="headerlink" title="3. 用 inline 函数替代类函数的宏 (function-like marco)"></a>3. 用 <code>inline</code> 函数替代类函数的宏 (function-like marco)</h2><p>前面所述的宏都是 类对象的宏 (<em>object-like marco</em>)。下面这段代码是类函数的宏：</p>
<p>我们必须为函数内容整体加上小括号，还要为所有实参加上小括号，因为要考虑运算符优先级的问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a) &gt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MULTIPLY(a, b) (a * b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 2+2</span></span><br><span class="line">MAX(m, n) * <span class="number">5</span>;  <span class="comment">// 实际是 (a) &gt; (b) ? (a) : (b) * 5，乘号优先级高。</span></span><br><span class="line">MULTIPLY(NUM, NUM); <span class="comment">// 实际是 (2 + 2 * 2 + 2) = 8;</span></span><br></pre></td></tr></table></figure>

<p>纵使我们加上了所有括号，还有很麻烦的事情。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">CALL_MAX(++a, b);   <span class="comment">// ++a &gt; b，调用f(++a); a 共自增两次</span></span><br><span class="line">CALL_MAX(++a, b + <span class="number">10</span>); <span class="comment">// ++a &lt; b + 10, 调用f(b + 10), a 自增一次</span></span><br></pre></td></tr></table></figure>

<p>我们可以同 <code>template inline</code> 函数替代类函数的宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于单纯常量，最好以 <code>const</code> 对象或者 <code>enum</code> 替换 <code>#define</code> 。</li>
<li>对于类函数的宏 (function-like marco)，最好用 <code>inline</code> 函数替换 <code>#define</code> 。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么不推荐使用 rand &amp;#37 n 来生成一定范围的随机数</title>
    <url>/2020/02/06/CPP/summary/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8rand%E6%B1%82%E4%BD%99%E6%9D%A5%E7%94%9F%E6%88%90%E4%B8%80%E5%AE%9A%E8%8C%83%E5%9B%B4%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li><a href="#1-为什么不推荐使用-rand-n-来生成一定范围的随机数">1. 为什么不推荐使用 <code>rand % n</code> 来生成一定范围的随机数</a><ul>
<li><a href="#1-1-rand-n-的弊端">1.1 <code>rand() % n</code> 的弊端</a></li>
<li><a href="#1-2-一些解决办法">1.2 一些解决办法</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="1-为什么不推荐使用-rand-n-来生成一定范围的随机数"><a href="#1-为什么不推荐使用-rand-n-来生成一定范围的随机数" class="headerlink" title="1. 为什么不推荐使用 rand % n 来生成一定范围的随机数"></a>1. 为什么不推荐使用 <code>rand % n</code> 来生成一定范围的随机数</h1><p>最初遇到这个问题是在学习随机数的时候，在 cppreference 上，有这么一段代码，它的写法让我眼前一亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扔 6 面色子 20 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n != <span class="number">20</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">6</span>)</span><br><span class="line">            x = <span class="number">1</span> + rand() / ((RAND_MAX + <span class="number">1u</span>) / <span class="number">6</span>); <span class="comment">// 注意： 1 + rand() % 6 有偏差！</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>StackOverflow上也有个类似的问题。<a href="https://stackoverflow.com/questions/49878942/why-is-rand6-biased" target="_blank" rel="noopener">Why is <code>rand() % 6</code> biased?</a></p>
<h2 id="1-1-rand-n-的弊端"><a href="#1-1-rand-n-的弊端" class="headerlink" title="1.1 rand() % n 的弊端"></a>1.1 <code>rand() % n</code> 的弊端</h2><p>首先，以 <code>n = 100</code>为例，我们要知道 <code>rand() % 100</code> 这段代码的作用是生成 <code>[0, 99]</code> 范围内的随机数。<code>rand()</code> 的范围是 <code>[0, RAND_MAX]</code> , <code>RAND_MAX</code> 的值不小于 <code>32767</code>。</p>
<p>我们看这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> src = rand(); <span class="comment">// 假设均匀分布在 [0, 32767] 范围内</span></span><br><span class="line"><span class="keyword">int</span> dst = src % <span class="number">100</span>; <span class="comment">// 这个非均匀分布在 [0, 99]</span></span><br></pre></td></tr></table></figure>

<p>$src \in [0, 99] \Rightarrow  dst \in [0, 99]$<br>$src \in [100, 199] \Rightarrow  dst \in [0, 99]$<br>$…\ …$<br>$src \in [32700, 32767] \Rightarrow  dst \in [0, 67]$  </p>
<p>我们可以看到，<code>src</code> 取值在 <code>[0, 32700]</code> 之内的，<code>dst</code> 在 <code>[0, 99]</code> 之间的概率都是相等的。但是最后的 <code>[32700, 32767]</code> 使得 <code>dst</code> 只能取到 <code>[0, 67]</code> 范围内的值。这说明 <code>rand() % n</code> 会偏向于较小的数字。</p>
<p>你也许认为这么一点小的偏差不需太过计较，确实，随着 <code>RAND_MAX</code> 的增大、或者 <code>n</code> 的变小，这种误差会越来越小。但是我们举个极端的例子，<code>rand()</code> 范围是 <code>[0, 6]</code> ，<code>n = 6</code>，我们依然要找的是 <code>[0, 5]</code> 之内的随机数。<br>此时 <code>0</code> 出现了频次是 <code>2</code>，其他 <code>1 ~ 5</code> 出现的频次都是 <code>1</code> 。这样看来，<code>0</code> 出现的频率是其他数字的整整2倍，这个误差就比较明显了。</p>
<h2 id="1-2-一些解决办法"><a href="#1-2-一些解决办法" class="headerlink" title="1.2 一些解决办法"></a>1.2 一些解决办法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">6</span> * ((RAND_MAX + <span class="number">1u</span>) / <span class="number">6</span>)</span><br><span class="line"><span class="keyword">int</span> value = rand();</span><br><span class="line"><span class="keyword">while</span> (value &gt;= max)</span><br><span class="line">    value = rand();</span><br></pre></td></tr></table></figure>

<p>这样会使 <code>[0, 5]</code> 的分布频率更加接近。</p>
<p>当然还有很多的办法，上述也未必是最佳的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>rand</tag>
      </tags>
  </entry>
  <entry>
    <title>6.4 函数重载</title>
    <url>/2020/01/31/CPP-Primer/Notes/6.4%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<ul>
<li><a href="#6-4-函数重载">6.4 函数重载</a><ul>
<li><a href="#【1】重载和-const-形参">【1】重载和 <code>const</code> 形参</a></li>
<li><a href="#【2】const-cast-和重载">【2】<code>const_cast</code> 和重载</a></li>
<li><a href="#【3】重载与作用域">【3】重载与作用域</a><a id="more"></a>
<h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1></li>
</ul>
</li>
</ul>
<p>重载函数：函数名字相同但形参列表不同，与返回类型无关。</p>
<h2 id="【1】重载和-const-形参"><a href="#【1】重载和-const-形参" class="headerlink" title="【1】重载和 const 形参"></a>【1】重载和 <code>const</code> 形参</h2><p>一个拥有顶层 <code>const</code> 的形参无法与另一个没有顶层 <code>const</code> 的形参区分开来。<br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重复声明 f1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 重复声明 f2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>底层 <code>const</code> 可以区分开。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="【2】const-cast-和重载"><a href="#【2】const-cast-和重载" class="headerlink" title="【2】const_cast 和重载"></a>【2】<code>const_cast</code> 和重载</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt;= s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个函数的形参和返回类型都是 <code>const string</code> 的，当我们传入非常量的 <code>string</code> 对象时，得到的是一个常量字符串 <code>const string</code> 。</p>
<p>我们需要一个函数，使它接收非常量时，返回的也是非常量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">shorterString</span><span class="params">(<span class="built_in">string</span>&amp; s1, <span class="built_in">string</span>&amp; s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line">                            <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> stirng&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【3】重载与作用域"><a href="#【3】重载与作用域" class="headerlink" title="【3】重载与作用域"></a>【3】重载与作用域</h2><p>如果我们在内层作用域声明一个函数，它将隐藏外层作用域中声明的同名实体。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter06</tag>
      </tags>
  </entry>
  <entry>
    <title>Invalid address specified to RtlValidateHeap</title>
    <url>/2020/01/18/CPP/debug/1-Invalid%20address%20specified%20to%20RtlValidateHeap/</url>
    <content><![CDATA[<h1 id="Invalid-address-specified-to-RtlValidateHeap"><a href="#Invalid-address-specified-to-RtlValidateHeap" class="headerlink" title="Invalid address specified to RtlValidateHeap"></a>Invalid address specified to RtlValidateHeap</h1><h2 id="1-问题概述"><a href="#1-问题概述" class="headerlink" title="1. 问题概述"></a>1. 问题概述</h2><p>报错如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HEAP[<span class="keyword">String</span>.exe]: <span class="function">Invalid address specified to <span class="title">RtlValidateHeap</span><span class="params">( <span class="number">02730000</span>, <span class="number">0274</span>ED98 )</span></span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>监视窗口各变量的值：</p>
<p><img src="/2020/01/18/CPP/debug/1-Invalid%20address%20specified%20to%20RtlValidateHeap/1-1.png" alt="1-1"></p>
<p>异常位置发生在 <code>v.push_back(std::move(s2));</code> ，该语句进入了 <code>free()</code> 函数， 异常最后在函数 <code>free()</code> 的最后。<code>free()</code> 是我自定义的 <code>String</code> 类的析构函数内容，释放 <code>allocator</code> 分配的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 省略一部分代码。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确的代码</span></span><br><span class="line">    String(String&amp;&amp; s) <span class="keyword">noexcept</span> : sz(s.sz), p(s.p) &#123;</span><br><span class="line">        s.p = <span class="number">0</span>;</span><br><span class="line">        s.sz = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move constructor"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误的代码</span></span><br><span class="line">    <span class="comment">// String(String&amp;&amp; s) noexcept : sz(s.sz), p(s.p) &#123;</span></span><br><span class="line">    <span class="comment">//     s.free();</span></span><br><span class="line">    <span class="comment">//     std::cout &lt;&lt; "move constructor" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(String&amp;&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">    ~String() &#123; <span class="built_in">free</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::allocator&lt;<span class="keyword">char</span>&gt; alloc;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::<span class="built_in">free</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">std</span>::for_each(begin(), end(),</span><br><span class="line">        [](<span class="keyword">const</span> <span class="keyword">char</span>&amp; ptr) &#123; alloc.destroy(&amp;ptr); &#125;);</span><br><span class="line">        <span class="comment">// for (auto ptr = end(); ptr != begin();)</span></span><br><span class="line">        <span class="comment">//     alloc.destroy(--ptr);</span></span><br><span class="line">        alloc.deallocate(p, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1("one"), s2("two");</span><br><span class="line">    String s3 = s1;</span><br><span class="line">    s3 = s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"create an empty vector"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;String&gt; v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"----v.reserve(5)----"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.reserve(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"----v.push_back(s1);----"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(s1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"----v.push_back(std::move(s2));----"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(<span class="built_in">std</span>::move(s2));  <span class="comment">/* 异常位置 */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"----v.push_back(String(\"three\"));----"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(String(<span class="string">"three"</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"----v.push_back(\"four\");----"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.push_back(<span class="string">"four"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h2><p>这其实是一段测试 <strong>移动构造函数</strong> 的代码，错误信息的字面意思就是 <strong>为RtlValidateHeap指定的地址无效</strong>。</p>
<ol>
<li>看监视窗口的变量值，<code>p</code> 字符串中的字符无效，初步认为是指针释放的错误。</li>
<li><code>free()</code> 函数最后一句 <code>alloc.deallocate(p, sz)</code> 正是释放内存，那么原因基本就确定下来了。</li>
<li><code>std::move(s2)</code> 会调用移动构造函数，那么可能是移动构造函数出现了问题。</li>
<li>之前写的错误的代码，我是想直接将右侧对象给释放掉。但是这么做是不对的，C++要求<strong>移后源</strong>必须处于可析构状态，那么我这么做就会导致它释放了两次，从而产生错误。</li>
</ol>
<h2 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3. 解决办法"></a>3. 解决办法</h2><p>正确的做法是将右侧对象的指针置为 <code>nullptr</code>，其他内置类型置为初始值即可。</p>
<p>最后的输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*p constructor</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*p constructor</span><br><span class="line">copy constructor</span><br><span class="line">copy assignment</span><br><span class="line">create an empty <span class="built_in">vector</span></span><br><span class="line">----v.reserve(<span class="number">5</span>)----</span><br><span class="line">----v.push_back(s1);----</span><br><span class="line">copy constructor</span><br><span class="line">----v.push_back(<span class="built_in">std</span>::move(s2));----</span><br><span class="line">move constructor</span><br><span class="line">----v.push_back(String(<span class="string">"three"</span>));----</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*p constructor</span><br><span class="line">move constructor</span><br><span class="line">----v.push_back(<span class="string">"four"</span>);----</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*p constructor</span><br><span class="line">move constructor</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
        <category>Debug Problems</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>6.3 返回类型和return语句</title>
    <url>/2020/01/11/CPP-Primer/Notes/6.3%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<ul>
<li><a href="#6-3-返回类型和return语句">6.3 返回类型和return语句</a><ul>
<li><a href="#6-3-1-无返回值函数">6.3.1 无返回值函数</a></li>
<li><a href="#6-3-2-有返回值函数">6.3.2 有返回值函数</a><ul>
<li><a href="#【1】值是如何被返回的">【1】值是如何被返回的</a></li>
<li><a href="#【2】不要返回局部对象的引用或指针">【2】不要返回局部对象的引用或指针</a></li>
<li><a href="#【3】返回类类型的函数和调用运算符">【3】返回类类型的函数和调用运算符</a></li>
<li><a href="#【4】引用返回左值">【4】引用返回左值</a></li>
<li><a href="#【5】列表初始化返回值">【5】列表初始化返回值</a></li>
<li><a href="#【6】主函数main的返回值">【6】主函数main的返回值</a></li>
<li><a href="#【7】递归">【7】递归</a></li>
</ul>
</li>
<li><a href="#6-3-3-返回数组指针">6.3.3 返回数组指针</a><ul>
<li><a href="#【1】使用类型别名">【1】使用类型别名</a></li>
<li><a href="#【2】不使用类型别名">【2】不使用类型别名</a></li>
<li><a href="#【3】使用尾置返回类型">【3】使用尾置返回类型</a></li>
<li><a href="#【4】使用decltype">【4】使用decltype</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h1><p><code>return</code> 语句终止当期函数，并返回到调用处。有两种形式：</p>
<ol>
<li><code>return;</code></li>
<li><code>return expression;</code></li>
</ol>
<h2 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a>6.3.1 无返回值函数</h2><ol>
<li>无返回值的 <code>return</code> 语句只能出现在返回 <code>void</code> 类型的函数里。当然不必非要有 <code>return</code> 语句，若没有，会隐式的执行 <code>return</code>。</li>
<li>返回 <code>void</code> 类型的函数，也可以返回 另一个返回 <code>void</code> 的函数。</li>
</ol>
<h2 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a>6.3.2 有返回值函数</h2><p><code>return</code> 返回类型必须和函数返回类型相同，或者能隐式转换。</p>
<p><strong>注意</strong>：在一个循环里，若含有 <code>return</code> 语句，那么循环外面也应该有一条 <code>return</code> 语句。 因为我们可能没有返回任何值（没有进入循环体内的return语句），函数就结束了。我们一般在函数的最后都会保留一个 <code>return</code> 语句。</p>
<h3 id="【1】值是如何被返回的"><a href="#【1】值是如何被返回的" class="headerlink" title="【1】值是如何被返回的"></a>【1】值是如何被返回的</h3><p>对于引用类型来说，不会真正的拷贝对象，只是一个别名。<br>对于其他类型，会拷贝出一个临时量。</p>
<h3 id="【2】不要返回局部对象的引用或指针"><a href="#【2】不要返回局部对象的引用或指针" class="headerlink" title="【2】不要返回局部对象的引用或指针"></a>【2】不要返回局部对象的引用或指针</h3><p>函数结束后，所占的空间也会被释放掉。我们引用的（或指针所指的）局部变量对象不复存在。<br>例如：非引用类型的形参，函数体内定义的变量都是局部变量。</p>
<h3 id="【3】返回类类型的函数和调用运算符"><a href="#【3】返回类类型的函数和调用运算符" class="headerlink" title="【3】返回类类型的函数和调用运算符"></a>【3】返回类类型的函数和调用运算符</h3><p>调用运算符 <code>()</code> 的优先级和点运算符 <code>.</code> 和箭头运算符 <code>-&gt;</code> 相同，满足左结合律。若函数返回指针、引用或类的对象，我们能使用函数结果访问结果对象的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> sz = f(s1, s2).size();</span><br></pre></td></tr></table></figure>

<h3 id="【4】引用返回左值"><a href="#【4】引用返回左值" class="headerlink" title="【4】引用返回左值"></a>【4】引用返回左值</h3><p>返回引用的函数得到左值，其他的得到右值。我们能为返回类型是 非常量引用 的函数的结果赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>;</span><br><span class="line">f(s1, s2) = <span class="string">"123"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="【5】列表初始化返回值"><a href="#【5】列表初始化返回值" class="headerlink" title="【5】列表初始化返回值"></a>【5】列表初始化返回值</h3><!-- TODO: C++11: 返回花括号列表 -->
<p>C++11规定：函数可以返回花括号包围的值的列表。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f() &#123;</span><br><span class="line">    <span class="keyword">if</span> (...)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;  <span class="comment">// 返回空的vector</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 返回列表初始化的vector</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若函数返回<em>内置类型</em>，花括号列表里只能包含一个值，且该值的所占空间不能大于返回类型。</p>
<h3 id="【6】主函数main的返回值"><a href="#【6】主函数main的返回值" class="headerlink" title="【6】主函数main的返回值"></a>【6】主函数main的返回值</h3><p>我们允许 <code>main</code> 函数没有 <code>return</code> 语句，编译器会隐式的插入一条 <code>return 0</code> 语句。</p>
<p><code>main</code> 函数返回值是一个状态指示器，返回 <code>0</code> 表示成功，其他值表示失败，其他值的具体含义由机器决定。为了使返回值与机器无关，在 <code>cstdlib</code> 头文件引入了两个预处理变量，分别表示成功失败。<br><code>return EXIT_SUCCESS;</code> 和 <code>return EXIT_FAILURE;</code> 。</p>
<h3 id="【7】递归"><a href="#【7】递归" class="headerlink" title="【7】递归"></a>【7】递归</h3><p>如果函数调用了它自身，那么他就是递归函数。我们必须有个终止条件，否则函数永远递归下去，直到 <strong>程序栈空间</strong> 耗尽。</p>
<p><code>main</code> 函数不能调用它自己。</p>
<h2 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h2><h3 id="【1】使用类型别名"><a href="#【1】使用类型别名" class="headerlink" title="【1】使用类型别名"></a>【1】使用类型别名</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">// 两条语句等价</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;  <span class="comment">// 返回含有十个整数的数组的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="【2】不使用类型别名"><a href="#【2】不使用类型别名" class="headerlink" title="【2】不使用类型别名"></a>【2】不使用类型别名</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p1[<span class="number">10</span>];  <span class="comment">// 含有十个指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// 指向数组的指针，该数组有10个整数</span></span><br></pre></td></tr></table></figure>

<p>如上，返回数组指针应该像 <code>p2</code> 一样：<br><code>Type (*function(parameter_list))[dimension]</code></p>
<p>例如：<code>int (*func)(int i)[10]</code>，该函数接收一个 <code>int</code> 型的整数，返回一个指针，该指针指向含有10个整数的数组。</p>
<h3 id="【3】使用尾置返回类型"><a href="#【3】使用尾置返回类型" class="headerlink" title="【3】使用尾置返回类型"></a>【3】使用尾置返回类型</h3><!-- TODO: C++11: 尾置返回类型 -->

<p>C++11 新标准规定，任何函数都能使用 <strong>尾置返回</strong> ，这种对于复杂的返回类型比较有效。在形参列表后加上 <code>-&gt;</code> ，后面跟尾置返回类型；在函数最开头，本该写返回类型的地方使用 <code>auto</code> 。</p>
<p>例如：<code>auto func(int i) -&gt; int(*)[10];</code> ，func接收一个 <code>int</code> 型实参，返回一个指针，该指针指向含有10个整数的数组。</p>
<h3 id="【4】使用decltype"><a href="#【4】使用decltype" class="headerlink" title="【4】使用decltype"></a>【4】使用decltype</h3><p>若我们知道返回的指针指向哪个数组，可以用 <code>decltype</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(arr) *func(<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure>

<p>func接收一个 <code>int</code> 型实参，返回一个指针，该指针指向含有10个整数的数组。</p>
<p><strong>注意</strong>：<code>decltype(arr)</code> 的结果是个数组，还要再加一个 <code>*</code> 表明是个指针</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter06</tag>
      </tags>
  </entry>
  <entry>
    <title>6.2 参数传递</title>
    <url>/2020/01/09/CPP-Primer/Notes/6.2%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<ul>
<li><a href="#6-2-参数传递">6.2 参数传递</a><ul>
<li><a href="#6-2-1-传值参数">6.2.1 传值参数</a><ul>
<li><a href="#【1】指针形参">【1】指针形参</a></li>
</ul>
</li>
<li><a href="#6-2-2-传引用参数">6.2.2 传引用参数</a></li>
<li><a href="#6-2-3-const形参和实参">6.2.3 const形参和实参</a><ul>
<li><a href="#【1】尽量使用常量引用">【1】尽量使用常量引用</a></li>
</ul>
</li>
<li><a href="#6-2-4-数组形参">6.2.4 数组形参</a><ul>
<li><a href="#【1】保证数组长度的三种技术">【1】保证数组长度的三种技术</a></li>
<li><a href="#【2】数组引用形参">【2】数组引用形参</a></li>
<li><a href="#【3】传递多维数组">【3】传递多维数组</a></li>
</ul>
</li>
<li><a href="#6-2-5-main-处理命令行选项">6.2.5 main:处理命令行选项</a></li>
<li><a href="#6-2-5-含有可变形参的函数">6.2.5 含有可变形参的函数</a><ul>
<li><a href="#【1】initializer-list形参">【1】initializer_list形参</a></li>
<li><a href="#【2】省略符形参">【2】省略符形参</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><p>如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</p>
<h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><p>函数对形参做的所有操作都不会影响实参。</p>
<h3 id="【1】指针形参"><a href="#【1】指针形参" class="headerlink" title="【1】指针形参"></a>【1】指针形参</h3><p>执行指针拷贝操作时，拷贝的是指针的值；拷贝之后，两个指针是不同的指针。我们可以通过指针修改它所指对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    p = <span class="number">0</span>;  <span class="comment">// p是q的拷贝，并未改变q的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *q = &amp;i;</span><br><span class="line">reset(q);  <span class="comment">// *q = i = 1</span></span><br></pre></td></tr></table></figure>

<p><strong>Best Practices</strong>：<br>C的程序员常常使用指针类型的形参，在C++中建议使用引用类型。</p>
<h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><p>对引用的操作实际上就是对所引对象上的操作。</p>
<p>拷贝大的类类型或者容器对象比较低效，甚至有的类类型（IO类型）不支持拷贝操作，这时只能用引用。当无需修改引用的值是，使用常量引用。</p>
<h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>用实参初始化形参时，会忽略掉形参的顶层 <code>const</code> 。也就是形参有顶层 <code>const</code> 时，传给它常量对象或者非常量对象都可以。</p>
<p>形参初始化和变量初始化方式一样，记住通用的初始化规则即可。例如：我们可以使用非常量初始化一个底层 <code>const</code> 对象，反过来不行；普通引用必须引用相同类型的对象。</p>
<h3 id="【1】尽量使用常量引用"><a href="#【1】尽量使用常量引用" class="headerlink" title="【1】尽量使用常量引用"></a>【1】尽量使用常量引用</h3><ol>
<li>把函数参数定义为普通引用会给人一种误导，认为该参数可以修改。</li>
<li>使用非常量引用限制了实参类型，例如不能把 <code>const</code> 对象、字面值或者需要类型转换的对象传递给非常量引用形参。</li>
</ol>
<h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>不允许直接拷贝数组，使用数组时通常会（隐式的）转换为指针。所以我们无法以值传递的方式使用数组参数，当我们传递给函数一个数组时，其实是传递的数组首地址。</p>
<p>三种方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度10只是我们希望是10，实际可以传递任意维度的数组。</span></span><br></pre></td></tr></table></figure>

<p>当我们不需要修改数组元素时，形参应该是指向 <code>const</code> 的指针。</p>
<h3 id="【1】保证数组长度的三种技术"><a href="#【1】保证数组长度的三种技术" class="headerlink" title="【1】保证数组长度的三种技术"></a>【1】保证数组长度的三种技术</h3><ol>
<li><p><strong>使用标记指定数组长度</strong>：常用于C风格字符串，字符数组以 <code>\0</code> 结束。</p>
</li>
<li><p><strong>使用标准库规范</strong>：传递数组的首元素和尾后元素的指针。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* beg, <span class="keyword">const</span> <span class="keyword">int</span>* end)</span></span>;  <span class="comment">// 函数定义</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">print(begin(a), end(a));  <span class="comment">// 如何调用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显式传递数组的长度：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], <span class="keyword">size_t</span> sz)</span></span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">print(a, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="【2】数组引用形参"><a href="#【2】数组引用形参" class="headerlink" title="【2】数组引用形参"></a>【2】数组引用形参</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>;</span><br><span class="line"><span class="keyword">int</span> j[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">print(j);  <span class="comment">// 错误，维度必须为10</span></span><br><span class="line">print(k);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>与指针数组不同的是，<strong>这里的维度10指定了我们只能向函数传递大小为10的数组。</strong><br>在后面，我们会介绍如何编写一个函数，可以给引用形参传递任意大小的数组。</p>
<!-- TODO: 引用形参传递任意大小的数组P578 -->

<p>注意区分：</p>
<ol>
<li><code>f(int &amp;arr[10])</code>，arr是引用的数组，不存在引用的数组，这是错误的。</li>
<li><code>f(int (&amp;arr)[10])</code>，arr是数组的引用，该数组包含10个整型。</li>
</ol>
<h3 id="【3】传递多维数组"><a href="#【3】传递多维数组" class="headerlink" title="【3】传递多维数组"></a>【3】传递多维数组</h3><p>两种形参的形式，注意 <code>rowSize</code> 是行数，<code>3</code> 就是列数。<code>m</code> 实际上是指向<strong>含有3个整数的数组</strong>的指针。</p>
<ol>
<li><code>void print(int (*m)[3], int rowSize);</code></li>
<li><code>void print(int m[][3], int rowSize);</code></li>
</ol>
<p>多维数组真正传递的是数组首元素的指针，例如：<code>int a[2][3]</code> ，调用形式：<code>print(a, 2)</code>。</p>
<h2 id="6-2-5-main-处理命令行选项"><a href="#6-2-5-main-处理命令行选项" class="headerlink" title="6.2.5 main:处理命令行选项"></a>6.2.5 main:处理命令行选项</h2><p>两种形参的形式：</p>
<ol>
<li><code>int main(int argc, char *argv[]) {...}</code></li>
<li><code>int main(int argc, char **argv) {...}</code></li>
</ol>
<p><code>argc</code> 代表 <code>argv</code> 的大小，<code>argv</code> 中是我们命令行的字符串数组。</p>
<p>例如我们在命令行输入 <code>./a.out src.txt dest.txt</code>。<br>那么 <code>argc = 3</code>，<code>argv[0] = &quot;./a.out&quot;</code>，<code>argv[1] = &quot;src.txt&quot;</code>，<code>argv[2] = &quot;dest.txt&quot;</code>。</p>
<h2 id="6-2-5-含有可变形参的函数"><a href="#6-2-5-含有可变形参的函数" class="headerlink" title="6.2.5 含有可变形参的函数"></a>6.2.5 含有可变形参的函数</h2><h3 id="【1】initializer-list形参"><a href="#【1】initializer-list形参" class="headerlink" title="【1】initializer_list形参"></a>【1】initializer_list形参</h3><p>如果函数的实参数量未知并且实参类型都相同，可以使用 <code>initializer_list</code> 类型的形参。<br>它是一种标准库模板类型，定义于同名的头文件内。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>initializer_list&lt;T&gt; lst;</code></td>
<td>执行默认初始化；T类型的空列表</td>
</tr>
<tr>
<td><code>initializer_list&lt;T&gt; lst{a, b, c...}</code></td>
<td><code>lst</code> 中元素是初始值的<strong>副本</strong>(拷贝)，且为 <strong><code>const</code></strong> ；<code>lst</code> 的大小就是初始值的数量</td>
</tr>
<tr>
<td><code>lst2(lst)</code> / <code>lst2 = lst</code></td>
<td>拷贝/赋值一个该对象，不会拷贝列表中的元素；拷贝后，<strong>二者共享元素</strong></td>
</tr>
<tr>
<td><code>lst.size()</code></td>
<td>元素数量</td>
</tr>
<tr>
<td><code>lst.begin()</code> / <code>lst.end()</code></td>
<td><code>lst</code> 首元素指针/尾后元素指针</td>
</tr>
</tbody></table>
<p><strong>注意</strong>： <code>initializer_list</code> 中元素始终为常量。</p>
<p>使用举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; lst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : lst) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; lst&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    print(lst);</span><br><span class="line">    print(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);  <span class="comment">// 直接传递大括号列表也是可行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>含有 <code>initializer_list</code> 形参的函数也可以拥有其他形参，其他形参的位置任意。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; lst, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : lst) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; lst&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">"abc"</span>;</span><br><span class="line">    print(s, lst, s);</span><br><span class="line">    print(s, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="【2】省略符形参"><a href="#【2】省略符形参" class="headerlink" title="【2】省略符形参"></a>【2】省略符形参</h3><p>是为了便于C++程序访问特殊的C代码设置的，这些代码使用了 <code>varargs</code> 的C标准库功能。</p>
<p><strong>注意</strong>：大多数类类型传递给省略符形参时都无法正确拷贝。</p>
<p>省略符形参只能出现在形参列表的 <strong>最后</strong> 一个位置。</p>
<ol>
<li><code>void print(parm_list, ...);</code></li>
<li><code>void print(...);</code></li>
</ol>
<p>略写，不常使用。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter06</tag>
      </tags>
  </entry>
  <entry>
    <title>6.1 函数基础</title>
    <url>/2020/01/08/CPP-Primer/Notes/6.1%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li><a href="#6-1-函数基础">6.1 函数基础</a><ul>
<li><a href="#6-1-1-局部对象">6.1.1 局部对象</a></li>
<li><a href="#6-1-2-函数声明">6.1.2 函数声明</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><p>执行函数的第一步是(隐式的)定义并初始化它的形参（局部变量）。</p>
<p>空形参列表有两种方式：</p>
<ol>
<li><code>void f()</code></li>
<li><code>void f(void)</code></li>
</ol>
<p>函数的返回类型：</p>
<ol>
<li>返回类型 <code>void</code>，表示函数不返回任何值。</li>
<li>返回类型不能是 数组类型或函数类型，但可以是 指针或引用。</li>
</ol>
<h2 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h2><p>形参和函数体内定义的变量都是局部变量，局部变量还会隐藏外层作用域的同名变量。</p>
<ol>
<li>自动对象(普通局部变量)：变量定义时创建该对象，函数结束时销毁它。例如形参。</li>
<li>局部静态对象：令局部变量的生命周期贯穿函数调用和之后的时间。它在第一次经过对象定义语句时初始化，直到程序终止才被销毁。</li>
</ol>
<p><strong>注意</strong>：</p>
<ol>
<li>局部静态变量只被初始化一次，即使又一次执行了定义和初始化语句。</li>
<li>局部静态变量如果没有显式初始值，<strong>内置类型初始化为0</strong>。</li>
</ol>
<h2 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h2><ol>
<li>函数名字必须在使用前声明。</li>
<li>函数只能定义一次，可以声明多次。</li>
<li>函数声明也称作函数原型。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter06</tag>
      </tags>
  </entry>
  <entry>
    <title>2.4 const限定符</title>
    <url>/2020/01/05/CPP-Primer/Notes/2.4const%E9%99%90%E5%AE%9A%E7%AC%A6/</url>
    <content><![CDATA[<ul>
<li><a href="#24-const限定符">2.4 const限定符</a><ul>
<li><a href="#2-4-1-const的引用-reference-to-const">2.4.1 const的引用(reference to const)</a><ul>
<li><a href="#【1】初始化和对const的引用">【1】初始化和对const的引用</a></li>
</ul>
</li>
<li><a href="#2-4-2-指针和const">2.4.2 指针和const</a><ul>
<li><a href="#【1】指向常量的指针-pointer-to-const">【1】指向常量的指针(pointer to const)</a></li>
<li><a href="#【3】const指针-const-pointer">【2】const指针(const pointer)</a></li>
</ul>
</li>
<li><a href="#2-4-3-顶层const">2.4.3 顶层const</a><ul>
<li><a href="#【1】顶层/底层const的区别">【1】顶层/底层const的区别</a></li>
</ul>
</li>
<li><a href="#2-4-4-constexpr和常量表达式">2.4.4 constexpr和常量表达式</a><ul>
<li><a href="#【1】constexpr变量">【1】constexpr变量</a></li>
<li><a href="#【2】字面值类型">【2】字面值类型</a></li>
<li><a href="#【3】指针和constexpr">【3】指针和constexpr</a></li>
</ul>
</li>
<li><a href="#2-4-5关于引用的一些补充知识">2.4.5 关于引用的一些补充知识</a><ul>
<li><a href="#【1】对常量的引用和普通引用的相同点-不同点">【1】对常量的引用和普通引用的相同点/不同点</a></li>
<li><a href="#【2】有没有-int-amp-const-r-i">【2】有没有 int &amp;const r = i</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h1><ol>
<li><code>const</code> 对象创建后，值不能被改变。</li>
<li><code>const</code> 对象必须被初始化。</li>
</ol>
<p><strong>这两条对以下所述的 <code>const</code> 类型都适合。</strong></p>
<h3 id="const对象仅在文件内有效"><a href="#const对象仅在文件内有效" class="headerlink" title="const对象仅在文件内有效"></a>const对象仅在文件内有效</h3><ol>
<li>如果在多个文件中出现了同名的 <code>const</code> 变量时，相当于在不同文件里分别定义了一个独立的变量。</li>
<li>若我们希望在文件之间共享，只在一个文件里定义它，其他文件里声明它（<code>extern</code>）。</li>
</ol>
<h2 id="2-4-1-const的引用-reference-to-const"><a href="#2-4-1-const的引用-reference-to-const" class="headerlink" title="2.4.1 const的引用(reference to const)"></a>2.4.1 const的引用(reference to const)</h2><p>即：对常量的引用</p>
<h3 id="【1】初始化和对const的引用"><a href="#【1】初始化和对const的引用" class="headerlink" title="【1】初始化和对const的引用"></a>【1】初始化和对const的引用</h3><ol>
<li><p>引用类型必须和引用的对象类型不需要一致，只要能够转化成引用的类型即可。因此，常量引用可以绑定 常量/非常量对象、字面值、表达式。</p>
</li>
<li><p>非常量引用不能绑定一个常量对象。</p>
</li>
<li><p>对常量的引用 不能被用作 修改所指的对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;</span><br><span class="line">r = <span class="number">1</span>;  <span class="comment">// 错误，r是常量引用</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h2><h3 id="【1】指向常量的指针-pointer-to-const"><a href="#【1】指向常量的指针-pointer-to-const" class="headerlink" title="【1】指向常量的指针(pointer to const)"></a>【1】指向常量的指针(pointer to const)</h3><p>性质和对 <code>const</code> 的引用几乎类似。</p>
<ol>
<li>指针类型必须和所指对象的类型一致。</li>
<li>指向常量的指针可以绑定 常量/非常量对象。</li>
<li>普通指针不能绑定一个常量对象。</li>
<li>指向常量的指针 不能通过该指针 修改所指的对象的值。</li>
</ol>
<p>唯一的不同就是第2条：对常量的引用可以绑定字面值、表达式。指向常量的指针不能。</p>
<p><strong>注意：</strong><br>我们不能通过 <code>*p</code> 来修改所指对象的值，但是我们可以修改 <code>p</code> 的值，此时 <code>p</code> 指向另一个对象。也就是说 <code>*p</code> 是一个不可修改的左值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x61fe3c 1</span></span><br><span class="line"><span class="keyword">int</span> *q = &amp;j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q &lt;&lt; <span class="string">" "</span> &lt;&lt; *q &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x61fe38 2</span></span><br><span class="line">p = q;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">" "</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x61fe38 2</span></span><br><span class="line">*p = <span class="number">3</span>;  <span class="comment">// 错误，*p是一个不可修改的左值</span></span><br></pre></td></tr></table></figure>

<h3 id="【2】const指针-const-pointer"><a href="#【2】const指针-const-pointer" class="headerlink" title="【2】const指针(const pointer)"></a>【2】const指针(const pointer)</h3><p>把 <code>*</code> 放在 <code>const</code> 前说明指针是个常量，即指针本身的值不变，而非指向的值不变。<br>我们可以通过 <code>*p</code> 来改变指向的对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</span><br><span class="line">p = j;  <span class="comment">// 错误，p的值不能改变，p中存放着i的地址</span></span><br><span class="line">*p = <span class="number">10</span>;  <span class="comment">// 正确，i的值变为10</span></span><br></pre></td></tr></table></figure>

<p>性质和指向常量的指针相同。</p>
<h2 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h2><p>顶层const(top-level const)：指针本身是个常量。<br>底层const(low-level const)：指针所指的对象是个常量。</p>
<h3 id="【1】顶层-底层const的区别"><a href="#【1】顶层-底层const的区别" class="headerlink" title="【1】顶层/底层const的区别"></a>【1】顶层/底层const的区别</h3><ol>
<li>顶层const适用于算术类型、类、指针。</li>
<li>底层const适用于指针和引用。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = i;  <span class="comment">// 顶层，j是int型的对象</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> q = &amp;i;  <span class="comment">// 顶层，表示指针本身是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;  <span class="comment">// 底层，表示指针所指对象是个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;  <span class="comment">// 底层，引用类型都是底层const</span></span><br></pre></td></tr></table></figure>

<p>顶层/底层 <code>const</code> 赋值规则，书上说的太过复杂，其实就是前面几节 const的引用，指向常量的指针，常量指针一些性质。</p>
<p>比较通用的规则：<br><strong>我们可以使用非常量初始化一个底层 <code>const</code> 对象，反过来不行。</strong></p>
<h2 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h2><p>常量表达式(const expression)：值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式。</p>
<p>一个对象或者表达式是不是常量表达式由数据类型和初始值共同决定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>; <span class="comment">// no, 因为不是const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d = get_size();  <span class="comment">//no, 我们到运行get_size()时才能确定d的值</span></span><br></pre></td></tr></table></figure>

<h3 id="【1】constexpr变量"><a href="#【1】constexpr变量" class="headerlink" title="【1】constexpr变量"></a>【1】constexpr变量</h3><!-- TODO: C++11: constexpr -->
<p>我们很难区分一个变量到底是不是常量表达式，或者我们变量的初始值根本不是常量表达式。于是，<strong>C++11</strong> 允许将变量声明为 <code>constexpr</code> 由编译器验证变量是否是常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> a = <span class="number">1</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">// yes</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> c = size();  <span class="comment">// 当size()是constexpr函数时正确。</span></span><br></pre></td></tr></table></figure>

<h3 id="【2】字面值类型"><a href="#【2】字面值类型" class="headerlink" title="【2】字面值类型"></a>【2】字面值类型</h3><p>算术类型、指针和引用都属于字面值类型，自定义类、IO库、string类都不属于。</p>
<p>指针能定义为 <code>constexpr</code>，但初始值必须为 <code>nullptr</code> 或 <code>0</code>，或者是某个固定地址的对象。函数体内的变量一般并非存在固定地址中，所以 <code>constexpr</code> 指针不能指向这样的对象，函数体之外的可以。当然函数体内的静态变量也可以。</p>
<h3 id="【3】指针和constexpr"><a href="#【3】指针和constexpr" class="headerlink" title="【3】指针和constexpr"></a>【3】指针和constexpr</h3><p><code>constexpr</code> 只对指针本身有效，与其所指对象无关。<br>例如：<code>constexpr int *q = nullptr</code>，q是一个常量指针。</p>
<p><code>constexpr</code> 指针既可以指向常量也可指向非常量。</p>
<!-- TODO: VS: 对常量的引用 VS 普通引用 -->
<h2 id="2-4-5-关于引用的一些补充知识"><a href="#2-4-5-关于引用的一些补充知识" class="headerlink" title="2.4.5 关于引用的一些补充知识"></a>2.4.5 关于引用的一些补充知识</h2><h3 id="【1】对常量的引用和普通引用的相同点-不同点"><a href="#【1】对常量的引用和普通引用的相同点-不同点" class="headerlink" title="【1】对常量的引用和普通引用的相同点/不同点"></a>【1】对常量的引用和普通引用的相同点/不同点</h3><p><strong>相同点</strong>：</p>
<ol>
<li>必须初始化。</li>
</ol>
<p><strong>不同点</strong>：</p>
<ol>
<li>对常量的引用不能被修改它的值。</li>
<li>普通引用必须绑定到<strong>类型相同</strong>的对象上，对常量的引用可以绑定 常量/非常量对象、字面值、表达式，只要能够转化成对应的类型即可。</li>
</ol>
<h3 id="【2】有没有-int-amp-const-r-i"><a href="#【2】有没有-int-amp-const-r-i" class="headerlink" title="【2】有没有 int &amp;const r = i"></a>【2】有没有 <code>int &amp;const r = i</code></h3><p>指针有两种行为的 <code>const</code> ，引用有没有呢？  </p>
<p>首先，我们明确一些概念。</p>
<ol>
<li><code>const int i = 0; const int &amp;r1 = i;</code>，像这样，我们把引用绑定到 <code>const</code> 对象上，这叫<strong>对常量的引用</strong>。当然我们也能绑定到非常量对象上，这个暂时不考虑。</li>
<li><code>const int i = 0; int &amp;const r2 = i;</code>，这种情况的 <code>const</code> 限定的是我们不能更改 <code>r2</code> 的绑定对象。</li>
</ol>
<p>我们学习引用时就知道，<strong>不允许改变引用所绑定的对象</strong>。这其实就说明：引用本身就是 <code>const</code> 的。所以 <code>int &amp;const r2 = i;</code> 这条语句本质上就是 <code>int &amp;r2 = i;</code> ，是冗余的，所以C++没有这种语法。</p>
<blockquote>
<p><a href="https://www.embedded.com/references-and-const/" target="_blank" rel="noopener">References and const</a><br><a href="https://www.quora.com/What-are-the-differences-between-int-const-int-const-const-int-and-const-int-in-C" target="_blank" rel="noopener">Quora</a><br><a href="https://blog.csdn.net/xiaoyi39/article/details/51273795" target="_blank" rel="noopener">C++中的引用与const</a></p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>2.3 复合类型</title>
    <url>/2020/01/04/CPP-Primer/Notes/2.3%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li><a href="#2-3-1-引用-reference">2.3.1 引用(reference)</a></li>
<li><a href="#2-3-2-指针-pointer">2.3.2 指针(pointer)</a><ul>
<li><a href="#【1】空指针">【1】空指针</a></li>
<li><a href="#【2】指针操作">【2】指针操作</a></li>
<li><a href="#【3】void-指针">【3】void* 指针</a></li>
</ul>
</li>
<li><a href="#2-3-复合类型的声明">2.3 复合类型的声明</a><ul>
<li><a href="#【1】定义多个变量">【1】定义多个变量</a></li>
<li><a href="#【2】指向指针的指针">【2】指向指针的指针</a></li>
<li><a href="#【3】指向指针的引用">【3】指向指针的引用</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h1><h2 id="2-3-1-引用-reference"><a href="#2-3-1-引用-reference" class="headerlink" title="2.3.1 引用(reference)"></a>2.3.1 引用(reference)</h2><p><em>引用</em>为<em>对象</em>起了另外一个名字，引用类型 引用 另外一种类型。<br>形式为：<code>int &amp;refVal = ival;</code> ，<code>refVal</code> 是 <code>ival</code> 的引用。</p>
<p>引用必须遵守一下三个规定：</p>
<ol>
<li>引用必须被初始化</li>
<li>引用的初始值必须是一个对象</li>
<li>引用类型和所绑定对象的类型必须相同。</li>
</ol>
<p>引用和它的初始值对象将一直绑定到一起，无法绑定到另一个对象上。<br>引用并非<strong>对象</strong>，它只是为一个对象起了另一个名字。就像每个人都有学名和乳名。<br>所以我们对引用进行一系列操作的同时，也会对<em>与之绑定的对象</em>进行相同的操作。<br>由 引用并非<strong>对象</strong>，可知不存在 <strong>对引用的引用</strong>。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br><span class="line">refVal = <span class="number">2</span>;  <span class="comment">// 此时ival也变为了2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-2-指针-pointer"><a href="#2-3-2-指针-pointer" class="headerlink" title="2.3.2 指针(pointer)"></a>2.3.2 指针(pointer)</h2><p>指针和引用的两个不同点：</p>
<ol>
<li>指针是个对象。</li>
<li>指针无须在定义时赋值。</li>
</ol>
<p>指针的类型要和它所指的对象的类型严格匹配。</p>
<!-- TODO:指针类型匹配的两种例外：P47 -->

<h3 id="【1】空指针"><a href="#【1】空指针" class="headerlink" title="【1】空指针"></a>【1】空指针</h3><p>生成空指针的三种办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<!-- TODO: C++11: nullptr -->
<!-- TODO: 类型转换P143下 -->
<p><code>nullptr</code> 是指针字面值 (<strong>C++11</strong>)，它可以转换成任意其他指针类型。</p>
<p><strong>注意</strong>：</p>
<ol>
<li>尽量使用 <code>nullptr</code></li>
<li><code>int</code> 变量不能赋给指针，即使该变量为0。<br>例如：<code>int i = 0; int *pi = i;</code> , 这是错误的。</li>
<li>建议初始化所有指针，暂不知道初始化对象是谁，可以先初始化为 <code>nullptr</code>。</li>
</ol>
<h3 id="【2】指针操作"><a href="#【2】指针操作" class="headerlink" title="【2】指针操作"></a>【2】指针操作</h3><ol>
<li><p>赋值永远改变的是等号左侧的对象。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;i1;  <span class="comment">// p1暂时指向i1</span></span><br><span class="line">p1 = &amp;i2;  <span class="comment">// 改变了p1的值，i2没有变，p1指向i2。</span></span><br><span class="line">*p1 = <span class="number">10</span>;  <span class="comment">// 改变了i2的值变为10，p1没有变。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>任何非 <code>nullptr, 0, NULL</code> 的指针的条件值都为 <code>true</code>。</p>
</li>
<li><p><strong>类型相同</strong> 的合法指针可以进行条件比较。</p>
<!-- TODO: 更多指针操作 P105-->

</li>
</ol>
<h3 id="【3】void-指针"><a href="#【3】void-指针" class="headerlink" title="【3】void* 指针"></a>【3】void* 指针</h3><p><code>void*</code> 指针可以存放任意类型对象的地址。但是我们不能直接操作 <code>void*</code> 指针所指的对象，因为我们不知道它到底是什么类型。</p>
<h2 id="2-3-复合类型的声明"><a href="#2-3-复合类型的声明" class="headerlink" title="2.3 复合类型的声明"></a>2.3 复合类型的声明</h2><h3 id="【1】定义多个变量"><a href="#【1】定义多个变量" class="headerlink" title="【1】定义多个变量"></a>【1】定义多个变量</h3><p><code>int* p1, p2</code> : p1是指针类型，p2是int</p>
<h3 id="【2】指向指针的指针"><a href="#【2】指向指针的指针" class="headerlink" title="【2】指向指针的指针"></a>【2】指向指针的指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;ival;  <span class="comment">// p1指向 int型的整数</span></span><br><span class="line"><span class="keyword">int</span> **P2 = &amp;p1;  <span class="comment">// p2指向 int型的指针</span></span><br></pre></td></tr></table></figure>

<h3 id="【3】指向指针的引用"><a href="#【3】指向指针的引用" class="headerlink" title="【3】指向指针的引用"></a>【3】指向指针的引用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;  <span class="comment">// r是指针p的引用，r是p的别名</span></span><br><span class="line">r = &amp;i;  <span class="comment">// 令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;  <span class="comment">// 令i=0</span></span><br></pre></td></tr></table></figure>

<p>如何理解 <code>int *&amp;r</code> 中 <code>r</code> 是什么类型？  </p>
<ol>
<li>首先看离 <code>r</code> 最近的声明符，即 <code>&amp;r</code>， 说明 <code>r</code> 是一个引用类型。</li>
<li><code>r</code> 引用的什么类型，看剩余的。即 <code>int *</code>，说明 <code>r</code> 引用的是个<code>int</code> 型指针。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>2.2 变量(variable)</title>
    <url>/2020/01/03/CPP-Primer/Notes/2.2%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<ul>
<li><a href="#2-2-1-变量定义">2.2.1 变量定义</a><ul>
<li><a href="#【1】初始值">【1】初始值</a></li>
<li><a href="#【2】列表初始化">【2】列表初始化</a></li>
<li><a href="#【3】默认初始化">【3】默认初始化</a></li>
</ul>
</li>
<li><a href="#2-2-2-变量声明和定义的关系">2.2.2 变量声明和定义的关系</a></li>
<li><a href="#2-2-4-名字的作用域">2.2.4 名字的作用域</a><ul>
<li><a href="#【1】嵌套的作用域">【1】嵌套的作用域</a><a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="2-2-变量-variable"><a href="#2-2-变量-variable" class="headerlink" title="2.2 变量(variable)"></a>2.2 变量(variable)</h1><h2 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h2><h3 id="【1】初始值"><a href="#【1】初始值" class="headerlink" title="【1】初始值"></a>【1】初始值</h3><p>对象被创建时获得了一个特定的值，就称该对象被<strong>初始化</strong>了。</p>
<p>我们经常用 <code>=</code> 进行初始化，注意，初始化并不是赋值。<br>初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象的当前值擦除，用一个新值代替。</p>
<h3 id="【2】列表初始化"><a href="#【2】列表初始化" class="headerlink" title="【2】列表初始化"></a>【2】列表初始化</h3><p>4种初始化形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; # <span class="number">1</span></span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;; # <span class="number">2</span></span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;; # <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>; # <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>用花括号初始化变量称为 <strong>列表初始化(list initialization)</strong> *[C++11]<em>。<br>其中 <code>#2</code> 称为 *</em>复制列表初始化** ， <code>#4</code> 称为 <strong>直接列表初始化</strong> 。</p>
<p><strong>注意</strong> ：<em>列表初始化存在丢失信息的风险</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;pi&#125;;     <span class="comment">// 错误，存在丢失信息的危险</span></span><br><span class="line"><span class="keyword">int</span> b = &#123;pi&#125;;  <span class="comment">// 错误，存在丢失信息的危险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(pi)</span></span>;     <span class="comment">// 正确，丢失了小数位的值。</span></span><br><span class="line"><span class="keyword">int</span> d = pi;    <span class="comment">// 错误，存在丢失信息的危险</span></span><br></pre></td></tr></table></figure>

<h3 id="【3】默认初始化"><a href="#【3】默认初始化" class="headerlink" title="【3】默认初始化"></a>【3】默认初始化</h3><ol>
<li>若为 <a href="https://www.faker.top/2019/12/30/CPP-Primer/Notes/2.1基本内置类型/" target="_blank" rel="noopener"><strong>内置类型</strong></a> 且没有被显示初始化，它的值由它的位置决定。<ol>
<li>定义于任何函数体之外的变量被初始化为0。(<strong>注意</strong>：<code>main</code> 也是个函数。)</li>
<li>任何函数体之内的将 <strong>不被初始化</strong> ，其变量的值时 <strong>未定义的</strong>。</li>
</ol>
</li>
<li>若为 <strong>类类型</strong> ，每个类都有自己初始化对象的方式。若类的对象没有被显式初始化，其值由类决定。例如 <code>string</code> 类会被默认初始化为空串。</li>
</ol>
<h2 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h2><ol>
<li><p><strong>变量声明</strong> 规定了变量的类型和名字，<strong>定义</strong> 也是。除此之外，<strong>定义</strong> 还申请存储空间，也可能会为变量赋一个初始值。</p>
</li>
<li><p><strong>声明而不定义</strong> 一个变量：在最前面加一个 <code>extern</code> 关键字，且不要显式初始化。</p>
</li>
<li><p>任何包含显式初始化的声明就成为 <strong>定义</strong>。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">// 声明i而不是定义i</span></span><br><span class="line"><span class="keyword">int</span> j;  <span class="comment">// 定义j</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;  <span class="comment">// 定义pi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量只能 <strong>定义一次</strong>，但可以 <strong>多次声明</strong>。</p>
</li>
<li><p>若在多个文件里使用同一个变量，变量的定义只能出现在一个文件里，其他文件要使用该变量，必须对其声明，不能重复定义。</p>
</li>
</ol>
<h2 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h2><p>C++的标识符（即变量命名）由数字、字母和下划线组成，必须以字母和下划线为开头，长度没有限制，对大小写敏感。</p>
<h2 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h2><p>C++语言大部分作用域使用大括号 <code>{}</code> 分离，一个 <code>{}</code> 表示一个作用域。</p>
<p>简单地名词：<strong>全局作用域</strong> ， <strong>块作用域</strong> 。</p>
<h3 id="【1】嵌套的作用域"><a href="#【1】嵌套的作用域" class="headerlink" title="【1】嵌套的作用域"></a>【1】嵌套的作用域</h3><ol>
<li>允许在内层作用域，重新定义外层作用域已有的名字。在内层作用域里使用新定义的变量的值，出了内层作用域，使用外层作用域该变量的值。</li>
<li>可以使用作用域操作符 <code>::</code> 覆盖默认的作用域。<br><code>::a</code> 访问的是全局作用域的 <code>a</code> ，因为全局作用域没有名字，所以 <code>::</code> 左侧为空时，就代表全局作用域。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">// a有全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面的&#123;&#125;是一个块作用域。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 10</span></span><br><span class="line">        a ++;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 11</span></span><br><span class="line">        <span class="comment">// 使用作用域操作符显式访问全局变量a</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 0</span></span><br><span class="line">    &#125; <span class="comment">// 内层作用域结束，其中的局部变量a被销毁。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 0，此时回到了全局变量的作用域。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 若变量是全局变量，不要在局部作用域里，定义一个同名的变量。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客新建菜单，并在该菜单内添加单篇/多篇文章</title>
    <url>/2020/01/01/Hexo/h3-hexo%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ul>
<li><a href="#1-如何添加新的菜单">1 如何添加新的菜单</a></li>
<li><a href="#2-更改菜单名">2 更改菜单名</a><ul>
<li><a href="#2-1-更改左侧菜单名-schedule">2.1 更改左侧菜单名 schedule</a></li>
<li><a href="#2-1-更改-schedule-页面内上方的文字">2.1 更改 schedule 页面内上方的文字</a></li>
</ul>
</li>
<li><a href="#3-使菜单-schedule-里面只包含一篇文章">3 使菜单 schedule 里面只包含一篇文章。</a></li>
<li><a href="#4-使菜单-schedule-里面包含多篇文章">4 使菜单 schedule 里面包含多篇文章。</a></li>
</ul>
<a id="more"></a>

<h2 id="1-如何添加新的菜单"><a href="#1-如何添加新的菜单" class="headerlink" title="1 如何添加新的菜单"></a>1 如何添加新的菜单</h2><p>执行命令：<code>hexo new page schedule</code>, 这里的菜单名就是 <code>schedule</code>。</p>
<p>这时候我们就会发现，网站上多了一个菜单。但是点击这个菜单，页面里只有 <strong>schedule</strong> 这几个大字。</p>
<h2 id="2-更改菜单名"><a href="#2-更改菜单名" class="headerlink" title="2 更改菜单名"></a>2 更改菜单名</h2><h3 id="2-1-更改左侧菜单名-schedule"><a href="#2-1-更改左侧菜单名-schedule" class="headerlink" title="2.1 更改左侧菜单名 schedule"></a>2.1 更改左侧菜单名 schedule</h3><ol>
<li>打开 <code>hexo/_config.yml</code> 文件，找到 <code>language:</code>，这行代码。例如我的语言是 <code>language: zh-CN</code> 。</li>
<li>打开文件 <code>hexo/themes/next/language</code>（next是我的主题，打开你当前主题里的 <code>language</code> 文件夹）。那么我就打开 <code>language/zh-CN.yml</code>，与你的语言对应的文件。</li>
<li>在 <code>Menu:</code> 下方添加一行 <code>schedule: 札记</code>，就修改成 <strong>札记</strong> 了。</li>
</ol>
<h3 id="2-1-更改-schedule-页面内上方的文字"><a href="#2-1-更改-schedule-页面内上方的文字" class="headerlink" title="2.1 更改 schedule 页面内上方的文字"></a>2.1 更改 schedule 页面内上方的文字</h3><ol>
<li>打开 <code>hexo/source/schedule/index.md</code> ，修改成 <code>title: 札记</code>，写成你想要的名字即可。</li>
</ol>
<h2 id="3-使菜单-schedule-里面只包含一篇文章"><a href="#3-使菜单-schedule-里面只包含一篇文章" class="headerlink" title="3 使菜单 schedule 里面只包含一篇文章"></a>3 使菜单 schedule 里面只包含一篇文章</h2><p>具体效果就是，我们点击这个 <code>schedule</code> 就相当于打开了一篇文章，适合用来写日记。</p>
<p><img src="/2020/01/01/Hexo/h3-hexo%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95-%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0/hexo-3_1.png" alt="1"></p>
<ol>
<li><p>打开 <code>hexo/source/schedule</code> 文件夹，里面只有一个 <code>index.md</code> 文件。我们在这个文件夹里新建文件 <code>notes.md</code> 。该文件，就是你想要展示的那篇文章。</p>
</li>
<li><p>打开 <code>hexo/themes/next/_config.yml</code> 文件，找到 <code>menu:</code>，添加一行 <code>schedule: /schedule/notes.html || calendar</code> 即可。<code>||</code> 前面的是文章的路径，后面是菜单的图标。图标可以更改，请百度 <code>Font Awesome</code> 。</p>
</li>
<li><p><code>notes.md</code> 开头的格式和以前一样，只是没有 <code>categories</code> 和 <code>tags</code> 选项。例如：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 札记</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-30</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">51</span></span><br><span class="line">toc: <span class="literal">true</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="4-使菜单-schedule-里面包含多篇文章"><a href="#4-使菜单-schedule-里面包含多篇文章" class="headerlink" title="4 使菜单 schedule 里面包含多篇文章"></a>4 使菜单 schedule 里面包含多篇文章</h2><p>这里用到的办法借用了 <code>categories</code> 的分类功能，其实就是将某个分类移到了左侧菜单上。</p>
<ol>
<li>我们在 <code>_post</code> 目录下有几篇文章想放到该菜单下，我们给这些文章分类为 <code>categories: -schedule</code> 。</li>
<li>打开 <code>hexo/themes/next/_config.yml</code> 文件，找到 <code>menu:</code>，添加一行 <code>schedule: //categories/schedule/ || calendar</code> 即可。</li>
<li>这时我们点击，该菜单，就会发现里面可以显示这几篇文章。但是点开目录菜单，发现多了一个分类 <code>schedule</code>，因为实际上这俩是一样的。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-icarus主题下, 文章内部的目录问题</title>
    <url>/2019/12/31/Hexo/h4-hexo-icarus%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%96%87%E7%AB%A0%E7%9A%84%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>首先icarus主题，本身就支持目录功能，只要在md文件首部加上 <code>toc: true</code> ，就可以在文章左侧生成目录，且可以正常跳转。</li>
<li>在我们浏览网站首页时，每一个文章只会显示一部分的内容，并且有一个 <strong>read more</strong> 按钮，供我们阅读全文。</li>
</ol>
<p>待完成。。。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>2.1 基本内置类型</title>
    <url>/2019/12/30/CPP-Primer/Notes/2.1%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li><a href="#2-1-1-算术类型-arithmetic-type">2.1.1 算术类型(arithmetic type)</a><ul>
<li><a href="#【1】算术类型的分类">【1】算术类型的分类</a></li>
<li><a href="#【2】算术类型的尺寸">【2】算术类型的尺寸</a></li>
<li><a href="#【3】带无符号类型">【3】带/无符号类型</a></li>
<li><a href="#【4】如何选择类型">【4】如何选择类型</a></li>
</ul>
</li>
<li><a href="#2-1-2-类型转换">2.1.2 类型转换</a><ul>
<li><a href="#【1】六种类型转换的情况">【1】六种类型转换的情况</a></li>
<li><a href="#【2】含有无符号类型的表达式">【2】含有无符号类型的表达式</a></li>
</ul>
</li>
<li><a href="#2-1-3-字面值常量-literal">2.1.3 字面值常量(literal)</a><ul>
<li><a href="#【1】整型浮点型字符字符串布尔指针字面值">【1】整型、浮点型、字符、字符串、布尔、指针字面值</a></li>
<li><a href="#【2】转义序列">【2】转义序列</a></li>
<li><a href="#【3】指定字面值的类型">【3】指定字面值的类型</a></li>
</ul>
</li>
</ul>
<a id="more"></a>

<h1 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h1><h2 id="2-1-1-算术类型-arithmetic-type"><a href="#2-1-1-算术类型-arithmetic-type" class="headerlink" title="2.1.1 算术类型(arithmetic type)"></a>2.1.1 算术类型(arithmetic type)</h2><p>基本内置类型包括 <strong>算术类型</strong> 和 <strong>空类型</strong> 。</p>
<h3 id="【1】算术类型的分类"><a href="#【1】算术类型的分类" class="headerlink" title="【1】算术类型的分类"></a>【1】算术类型的分类</h3>
$$
\text{内置类型} \begin{cases}
    \text{算术类型} \begin{cases}
    \text{整型} \begin{cases}
    \text{布尔值}: bool\\
    \text{字符型}: char,\ wchar\_t,\ char16\_t,\ char32\_t\\
    \text{整型数}: short,\ int,\ long,\ long\ long\\
\end{cases}\\
    \text{浮点型}: float,\ double,\ long\ double\\
\end{cases}\\
    \text{空类型}:void\\
\end{cases}
$$


<h3 id="【2】算术类型的尺寸"><a href="#【2】算术类型的尺寸" class="headerlink" title="【2】算术类型的尺寸"></a>【2】算术类型的尺寸</h3><p>算术类型的尺寸在不同机器上有所差距，下表列出 C++ 标准规定的尺寸的最小值。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>最小尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>布尔类型</td>
<td>未定义</td>
</tr>
<tr>
<td>char</td>
<td>字符</td>
<td>8位</td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符</td>
<td>16位</td>
</tr>
<tr>
<td>char16_t</td>
<td>Unicode字符</td>
<td>16位</td>
</tr>
<tr>
<td>char32_t</td>
<td>Unicode字符</td>
<td>32位</td>
</tr>
<tr>
<td>short</td>
<td>短整形</td>
<td>16位</td>
</tr>
<tr>
<td>int</td>
<td>整形</td>
<td>16位</td>
</tr>
<tr>
<td>long</td>
<td>长整形</td>
<td>32位</td>
</tr>
<tr>
<td>long long(C++11)</td>
<td>长整形</td>
<td>64位</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>10位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>扩展精度浮点数</td>
<td>10位有效数字</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ol>
<li>一个 <code>char</code> 大小和一个机器字节一样。</li>
<li>C++规定，一个 <code>int</code> 至少和一个 <code>short</code> 一样大，一个 <code>long</code> 至少和一个 <code>int</code> 一样大，一个 <code>long long</code> 至少和一个 <code>long</code> 一样大。</li>
<li>通常，<code>float</code> 为32位， <code>double</code> 为64位， <code>long double</code> 为96位或128位。类型 <code>float</code> 和 <code>double</code> 分别有7和16个有效位。</li>
</ol>
<h3 id="【3】带-无符号类型"><a href="#【3】带-无符号类型" class="headerlink" title="【3】带/无符号类型"></a>【3】带/无符号类型</h3><ol>
<li><code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code> 都是带符号的，在他们前面加上 <code>unsigned</code> 就可以得到无符号类型。<br><strong>注意</strong>：类型 <code>unsigned int</code> 可以缩写为 <code>unsigned</code> 。</li>
<li>字符型分为三种：<code>char</code>, <code>signed char</code>, <code>unsigned char</code>。因为类型 <code>char</code> 是无符号还是带符号的，对于不同编译器来说，是不同的。<br><strong>注意</strong>：如果你需要一个不大的整数进行运算（算术表达式），明确指定它是 <code>signed char</code> 或者 <code>unsigned char</code> 。</li>
</ol>
<h3 id="【4】如何选择类型"><a href="#【4】如何选择类型" class="headerlink" title="【4】如何选择类型"></a>【4】如何选择类型</h3><ol>
<li>明确知道数值不可能为负时，选无符号类型。</li>
<li>使用 <code>int</code> 进行整数运算。</li>
<li>在算术表达式中，不要使用 <code>char</code> 或 <code>bool</code> 。如果你需要一个不大的整数进行运算（算术表达式），明确指定它是 <code>signed char</code> 或者 <code>unsigned char</code> 。</li>
<li>执行浮点数运算选用 <code>double</code> 。因为 <code>float</code> 精度不够且两者计算代价相差无几。</li>
</ol>
<hr>
<h2 id="2-1-2-类型转换"><a href="#2-1-2-类型转换" class="headerlink" title="2.1.2 类型转换"></a>2.1.2 类型转换</h2><h3 id="【1】六种类型转换的情况"><a href="#【1】六种类型转换的情况" class="headerlink" title="【1】六种类型转换的情况"></a>【1】六种类型转换的情况</h3><ol>
<li><strong>非布尔-&gt;布尔</strong>：值为 0 则转换为 <code>false</code> ，否则为 <code>true</code> 。</li>
<li><strong>布尔-&gt;非布尔</strong>：值为 <code>flase</code> 则转换为 0 ，值为 <code>true</code> 则为 1 。</li>
<li><strong>浮点数-&gt;整数</strong>：去掉小数，只取整数部分。</li>
<li><strong>整数-&gt;浮点数</strong>：小数部分记为 0 。若整数超过了浮点数的容量，精度可能会损失。</li>
<li><strong>当赋给 <em>无符号类型</em> 一个超出它范围的数</strong>，结果是该数对 <em>无符号类型表示数值总数</em> 取模后的余数。例如：<code>unsigned char c = -1</code> ，实际结果是对256取模后的余数，即255。</li>
<li><strong>当赋给 <em>带符号类型</em> 一个超出它范围的数</strong>，结果是<strong>未定义的</strong>。程序可能继续工作、可能崩溃，也可能产生垃圾数据。<br><strong>例如</strong>：用 <code>g++</code> 运行 <code>int b = INT_MAX + 1;</code> , 输出 <code>b = INT_MIN = -2147483648</code>。这意味着在某些编译器下，含有无法预知的行为的程序也能正确执行。</li>
</ol>
<h3 id="【2】含有无符号类型的表达式"><a href="#【2】含有无符号类型的表达式" class="headerlink" title="【2】含有无符号类型的表达式"></a>【2】含有无符号类型的表达式</h3><p>当一个表达式既有无符号数，又有 <code>int</code> 值时，那个 <code>int</code> 值就会转换成无符号数。<br>把负值转化成无符号数，相当于给一个无符号数赋一个负值，参考上述 <strong>5</strong>。</p>
<p><strong>例1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u + i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>假设 <code>int</code> 为32位，输出 $2^{32}-42+10=4294967264$ 。</p>
<p><strong>例2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; u * i &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>假设 <code>int</code> 为32位，输出 $(2^{32}-1) \times 1=4294967295$ 。</p>
<hr>
<h2 id="2-1-3-字面值常量-literal"><a href="#2-1-3-字面值常量-literal" class="headerlink" title="2.1.3 字面值常量(literal)"></a>2.1.3 字面值常量(literal)</h2><p>形如 -42 的值被称作 <strong>字面值常量</strong> 。</p>
<h3 id="【1】整型、浮点型、字符、字符串、布尔、指针字面值"><a href="#【1】整型、浮点型、字符、字符串、布尔、指针字面值" class="headerlink" title="【1】整型、浮点型、字符、字符串、布尔、指针字面值"></a>【1】整型、浮点型、字符、字符串、布尔、指针字面值</h3><p>整型字面值可以写作十进制数、八进制数、十六进制数。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号，也可能是无符号的。</p>
<p>十进制字面值是 <code>int</code>, <code>long</code>, <code>long long</code> 中，最小的那个，前提是能容纳下当前的值。<br>八进制和十六进制字面值是 <code>int</code>, <code>long</code>, <code>long long</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long long</code> 中，最小的那个，前提是能容纳下当前的值。<br>若最大的数据类型都放不下，将产生错误。</p>
<p><strong>注意：</strong> 类型 <code>short</code> 没有对应的字面值。</p>
<p>默认的，浮点数字面值是一个 <code>double</code> 类型。浮点数字面值表现为一个小数或者科学计数法。<br><code>3.14159 ; 2.14159E0 ; 0. ; 0e0 ; .001</code> 。</p>
<p>由单引号括起来的一个字符成为 <code>char</code> 型字面值，双引号括起来的零个或多个字符则是字符串字面值。</p>
<p><code>true</code> 和 <code>false</code> 是布尔类型的字面值。</p>
<p><code>nullptr</code> 是指针字面值。</p>
<h3 id="【2】转义序列"><a href="#【2】转义序列" class="headerlink" title="【2】转义序列"></a>【2】转义序列</h3><ul>
<li>不可打印字符：退格等控制字符</li>
<li>特殊含义的字符：单双引号、问号、反斜线等</li>
</ul>
<p>C++规定的转义序列：<br><code>\n \t\a \v \b \&quot; \\ \? \&#39; \r \f</code></p>
<p><strong>泛化的转义序列</strong>，形式是 <code>\x</code> 后跟1个或多个十六进制数，或者 <code>\</code> 后跟着1个、2个、3个八进制数。<br>例如：<code>\7(响铃) \12(换行) \40(空格) \x4d(字符M)</code></p>
<ol>
<li>若反斜线 <code>\</code> 后跟的八进制数超过三个，只有前3个构成转义序列。<br>例如：<code>\1234</code>，表示八进制数 123 对应的字符和数字 4 。  </li>
<li><code>\x</code> 则会用到后面跟的所有十六进制数，不过大多数机器 <code>char</code> 只有8位，<code>\x</code> 也不会跟着很多数，超过可能会报错。</li>
</ol>
<h3 id="【3】指定字面值的类型"><a href="#【3】指定字面值的类型" class="headerlink" title="【3】指定字面值的类型"></a>【3】指定字面值的类型</h3><p>字符和字符串字面值：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>Unicode 16字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode 32字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8(仅用于字符串字面常量)</td>
<td>char</td>
</tr>
</tbody></table>
<p>整型字面值：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody><tr>
<td>u 或 U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long</td>
</tr>
<tr>
<td>ll 或 LL</td>
<td>long long</td>
</tr>
</tbody></table>
<p>浮点型字面值：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>f 或 F</td>
<td>float</td>
</tr>
<tr>
<td>l 或 L</td>
<td>long double</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：</p>
<ol>
<li>对于一个整型字面值来说，我们指定的是最小匹配类型，依据当前值选择最小的尺寸。</li>
<li>我们还能组合后缀使用，例如 <code>UL</code> 为后缀，将根据具体数值选取 <code>unsigned long</code> 还是 <code>unsigned long long</code>。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
        <category>The Basics of C++</category>
      </categories>
      <tags>
        <tag>Chapter02</tag>
      </tags>
  </entry>
  <entry>
    <title>习题13.13：理解各种操作中的拷贝、构造、析构函数，特别是容器操作中的调用。</title>
    <url>/2019/12/18/CPP-Primer/Exercise/vector%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p><strong>练习13.13</strong>：理解拷贝控制成员和构造函数的一个好方法是定义一个简单的类，为该类定义这些成员，每个成员都打印出自己的名字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    X() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    X(<span class="keyword">const</span> X&amp;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"X(const X&amp;)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给 X 添加拷贝赋值运算符和析构函数，并编写一个程序以不同方式使用 X 的对象：将它们作为非引用和引用参数传递；动态分配它们；将它们存放于容器中；诸如此类。观察程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。<br>当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。</p>
<a id="more"></a>
<h2 id="2-C-Primer自带答案解析"><a href="#2-C-Primer自带答案解析" class="headerlink" title="2. C++ Primer自带答案解析"></a>2. C++ Primer自带答案解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -默认构造函数Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Test(<span class="keyword">const</span> Test&amp;) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -拷贝构造函数Test(const Test&amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; rhs) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -拷贝赋值运算符="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Test() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"  -析构函数~Test()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Test x)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Test&amp; x)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1.局部变量:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test x;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2.非引用传递参数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f1(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3.引用传递参数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f2(x);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"3.1 定义一个引用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Test &amp;x1 = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4.动态分配对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test* px = <span class="keyword">new</span> Test;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"5.添加到容器中"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Test&gt; Vx;</span><br><span class="line">        Vx.push_back(x);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6.释放动态分配对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> px;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7.间接初始化y,z、赋值操作"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test y = x;</span><br><span class="line">    <span class="function">Test <span class="title">z</span><span class="params">(x)</span></span>;</span><br><span class="line">    y = z;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8.程序结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>局部变量:</span><br><span class="line">  -默认构造函数Test()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>非引用传递参数</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>引用传递参数</span><br><span class="line"></span><br><span class="line"><span class="number">3.1</span> 定义一个引用</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>动态分配对象</span><br><span class="line">  -默认构造函数Test()</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加到容器中</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>释放动态分配对象</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>拷贝初始化y、直接初始化z、赋值操作</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝赋值运算符=</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>程序结束</span><br><span class="line"></span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>不用多说，默认构造函数。</p>
</li>
<li><p>非引用传递参数，我们传给函数 <code>f1()</code> 的是 对象 <code>x</code> 的拷贝。<br>也就是在 <code>f1()</code> 内出现了局部临时对象 <code>xTemp = x</code>，当函数完成时，<code>xTemp</code> 作用域结束，被销毁（调用析构函数）。</p>
</li>
<li><p>引用传递参数。就和 <strong>结果3.1</strong> 所示一样，我们将 局部临时对象  <code>xTemp</code> 绑定到 <code>x</code> 上，即： <code>Test &amp;xTemp = x</code>。<br>既没有拷贝构造也没有析构函数，因为它是一个引用。</p>
<blockquote>
<p>可参考P187， 6.2节-参数传递</p>
</blockquote>
</li>
<li><p>动态分配对象。<code>new</code> 表达式在自由空间构造一个Test型对象，返回指向该对象的指针。所以是默认构造函数。</p>
<blockquote>
<p>可参考P407，12.1.2节-直接管理内存</p>
</blockquote>
</li>
<li><p>添加到容器里。当调用push_back函数时，我们将元素类型的对象传递给他们，这些对象 <strong>拷贝</strong> 到容器里。所以是拷贝构造函数。<br>大括号是个作用域，作用域结束，<code>vector</code> 被销毁，其中的元素也被销毁。  </p>
<blockquote>
<p>可参考P308，使用emplace操作</p>
</blockquote>
</li>
<li><p>对于动态分配的对象，当对指向它的指针执行 <code>delete</code> 操作时被销毁。</p>
<blockquote>
<p>P445，什么时候会调用析构函数</p>
</blockquote>
</li>
<li><p>使用另一个对象初始化一个新对象，都是拷贝构造函数。<br>一个对象赋值给另一个对象，是调用了拷贝赋值运算符。</p>
</li>
<li><p>程序结束，释放 <code>x, y, z</code> 。</p>
</li>
</ol>
<h2 id="2-容器push-back操作中，调用拷贝构造函数的次数"><a href="#2-容器push-back操作中，调用拷贝构造函数的次数" class="headerlink" title="2.容器push_back操作中，调用拷贝构造函数的次数"></a>2.容器push_back操作中，调用拷贝构造函数的次数</h2><p>上面我们只是简单地给 <code>vector</code> 添加了一个元素，但是我发现，当我们添加多个元素时，调用拷贝构造函数的次数与我预期的结果大相径庭。</p>
<p>我们通过几个不同的例子，来搜索一下其中的规律。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(<span class="built_in">vector</span>&lt;Test&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" size:"</span> &lt;&lt; v.size() &lt;&lt; <span class="string">"  "</span> &lt;&lt; <span class="string">"capacity:"</span> &lt;&lt;  v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1. 定义4个对象"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Test x1, x2, x3, x4;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2. 逐一push_back四个对象:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Test&gt; q;</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x1);</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x2);</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x3);</span><br><span class="line">        printInfo(q);</span><br><span class="line">        q.push_back(x4);</span><br><span class="line">        printInfo(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 定义几个对象</span><br><span class="line">  -构造函数Test()</span><br><span class="line">  -构造函数Test()</span><br><span class="line">  -构造函数Test()</span><br><span class="line">  -构造函数Test()</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 逐一push_back四个对象:</span><br><span class="line">size:<span class="number">0</span>  capacity:<span class="number">0</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">size:<span class="number">1</span>  capacity:<span class="number">1</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">size:<span class="number">2</span>  capacity:<span class="number">2</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">size:<span class="number">3</span>  capacity:<span class="number">4</span></span><br><span class="line">  -拷贝构造函数Test(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">size:<span class="number">4</span>  capacity:<span class="number">4</span></span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line"></span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br><span class="line">  -析构函数~Test()</span><br></pre></td></tr></table></figure>

<ol>
<li>由此我们发现，当 <code>size == capacity</code> 时，我们再添加一个元素，那么拷贝构造函数的调用次数为：再添加一个元素后的 <code>size</code> 值。</li>
<li>这表明，当容量不足时，<code>vector</code> 会扩充容量，然后将元素重新拷贝一遍。容量足时（例如 <code>q.push_back(x4);</code>），此时只需调用一次拷贝构造函数。</li>
<li>并且，<code>vector</code> 的容量是翻倍增长的：<code>0-&gt;1-&gt;2-&gt;4-&gt;8....</code> 。<blockquote>
<p>翻倍增长可参考P320最上面一段话。</p>
</blockquote>
</li>
</ol>
<p>再深入的讲，就要涉及源码问题了，可参考《STL源码剖析》。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++Primer(5th) Notes</category>
      </categories>
      <tags>
        <tag>Chapter13</tag>
      </tags>
  </entry>
  <entry>
    <title>27-移除元素</title>
    <url>/2019/12/15/LeetCode/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">56.32%</td>
<td align="center">array / two-pointers</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个数组 nums 和一个值 val，你需要 <strong>原地</strong> 移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地</strong> 修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“<strong>引用</strong>”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li><code>index</code> 记录我们不和 <code>val</code> 相等的个数。</li>
<li>若不相等，就从开头逐一放在数组中。</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了89.70%的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了93.39%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> elem : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elem != val)</span><br><span class="line">                nums[index ++] = elem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>26-删除排序数组中的重复项</title>
    <url>/2019/12/15/LeetCode/26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">46.91%</td>
<td align="center">array / two-pointers</td>
<td align="center">bloomberg / facebook / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong>原地</strong>修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“<strong>引用</strong>”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li><code>index</code> 记录我们不重复的数字的个数。</li>
<li>如果 <code>nums[i] != nums[i - 1]</code> ，则就出现了新的不重复的值，令 <code>nums[index] = nums[i]</code> 即可。</li>
</ol>
<p><strong>注意以下几个细节：</strong></p>
<ol>
<li>第一个数字（<code>nums[0]</code>）肯定是要记录下来的，也就是不变的，所以我们判断条件是 <code>nums[i] != nums[i - 1]</code> ，而不是 <code>nums[i] != nums[i + 1]</code> 。</li>
<li><code>index</code> 实际是从下标1，开始赋值的。</li>
</ol>
<blockquote>
<p>执行用时: 24 ms, 在所有 cpp 提交中击败了91.69%的用户<br>内存消耗: 9.8 MB, 在所有 cpp 提交中击败了86.78%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// nums[0]不变，index从1开始赋值。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                index ++;</span><br><span class="line">                nums[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><ol>
<li>在 <strong>解法一</strong> 中，我们是判断相邻两个数不相等时，则出现了新的不重复数。实际上数组是递增的，当后一个数大于前一个数时，也是出现了新的不重复数。</li>
<li>该程序巧妙的解决了当数组为空时的特殊情况。<br> 当数组为空时，<code>i = 0</code>；非空时，<code>i = 1</code>。</li>
</ol>
<blockquote>
<p>执行用时: 20 ms, 在所有 cpp 提交中击败了98.93%的用户<br>内存消耗: 9.8 MB, 在所有 cpp 提交中击败了87.97%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = !nums.empty();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">            <span class="keyword">if</span> (n &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">                nums[i ++] = n;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>25-K个一组翻转链表</title>
    <url>/2019/12/12/LeetCode/25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">linked-list</td>
<td align="center">facebook / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个链表，每 $k$ 个节点一组进行翻转，请你返回翻转后的链表。<br>$k$ 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 $k$ 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定这个链表：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">当 k = <span class="number">2</span> 时，应当返回: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line">当 k = <span class="number">3</span> 时，应当返回: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2.解法"></a>2.解法</h2><h3 id="2-1-解法一：递归解法"><a href="#2-1-解法一：递归解法" class="headerlink" title="2.1 解法一：递归解法"></a>2.1 解法一：递归解法</h3><p>总的来说，这道题就是多次反转链表。</p>
<p><strong>1. 如何反转链表？</strong></p>
<ol>
<li>我们需要三个指针 <code>pre, cur, next</code> ，分别指向前一个结点、当前结点、后一个结点。</li>
<li>注意：当 <code>cur</code> 指向第一个结点时，我们要令 <code>pre = nullptr</code> 。</li>
<li>我们先保存好下一个节点：<code>next = cur-&gt;next</code> 。再反转当前结点和前一个结点： <code>cur-&gt;next = pre</code> 。然后 <code>pre, h</code> 都向后移一次：<code>pre = h; h = next</code>。</li>
<li>需要反转几个结点即循环几次。</li>
</ol>
<p><strong>2. 递归返回值和如何使用返回值？</strong></p>
<ol>
<li>应该返回反转之后的头结点（也就是反转之前的尾结点），这里就是 <code>pre</code> 。</li>
<li>令反转之后的尾结点（也就是反转之前的头结点）指向下一次递归的返回值（也就是下一次递归的反转后的头结点）。</li>
</ol>
<p><strong>3. 递归什么时候结束？</strong></p>
<p>当剩余结点数不足 $k$ 个时，我们的递归函数要先检查结点数有没有 $k$ 个。</p>
<blockquote>
<p>执行用时: 20 ms, 在所有 cpp 提交中击败了97.34%的用户<br>内存消耗: 9.5 MB, 在所有 cpp 提交中击败了98.88%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; k; ++ i) &#123;</span><br><span class="line">            ListNode* next = h-&gt;next;</span><br><span class="line">            h-&gt;next = pre;</span><br><span class="line">            pre = h;</span><br><span class="line">            h = next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = reverseKGroup(h, k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客内图片不能正常显示，但本地文件可以显示</title>
    <url>/2019/12/11/Hexo/h2-hexo%E5%8D%9A%E5%AE%A2%E5%86%85%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%EF%BC%8C%E4%BD%86%E6%9C%AC%E5%9C%B0%E5%8F%AF%E4%BB%A5/</url>
    <content><![CDATA[<h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>markdown文件中，插入图片的方式为 <code>![](文件路径)</code> ，此时markdown文件可以正常显示图片。<br>但是一上传到博客上，便不能正常显示。</p>
<a id="more"></a>
<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h2><ol>
<li><p>修改 <strong>hexo 目录下</strong>的 .config.yml 文件，<br>将 <code>post_asset_folder: false</code> 修改为 <code>post_asset_folder: true</code>。</p>
</li>
<li><p>安装一个图片路径转换的插件。<br>在hexo文件夹下打开 Git bush。输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">npm install https:<span class="comment">//github.com/7ym0n/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 这使经过修改的插件代码，网上流传的另一份代码 <code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code> 并不能使用。  </p>
<p>如果你之前安装了这个错误的插件，请将 <strong>/node_modules/hexo-asset-image/index.js</strong><br>这个文件替换成下面的代码：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.config;</span><br><span class="line"><span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">    ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">    xmlMode: <span class="literal">false</span>,</span><br><span class="line">    lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">    decodeEntities: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">            <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.html();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完上述插件后，当我们创建新文章时 <code>hexo new post &quot;new article&quot;</code> ，就自动在 <code>new article.md</code> 文件的同目录下创建一个同名的文件夹，这里就是文件夹 <code>new article</code> 。我们把在 <code>new article.md</code> 使用的图片放入该文件夹中。  </p>
</li>
</ol>
<p><strong>我们的文件目录如下所示：</strong>  </p>
<pre><code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|- _post  </span><br><span class="line">|    |- pictures</span><br><span class="line">|    |    |- hexo.png</span><br><span class="line">|    |- <span class="keyword">new</span> article  </span><br><span class="line">|    |    |- hexo.png  </span><br><span class="line">|    |- <span class="keyword">new</span> article.md</span><br></pre></td></tr></table></figure></code></pre><ol start="4">
<li><p>这里我们给出两种办法来引用图片。</p>
<ol>
<li><p>直接使用代码 <code>![](hexo.png)</code> （虽然没有写文件夹的名字，但是可以的），<code>hexo.png</code> 是我们存在 <code>new article</code> 文件夹内的图片。这时你会发现markdown预览中无法显示这张图片，但是当你将博客上传到网站时，网站上是可以正常显示的。</p>
</li>
<li><p>使用代码 <code>![](new article/hexo.png)</code>不仅可以本地预览，上传到网站也可以正常显示。</p>
</li>
<li><p>本地无法预览也是件很不舒服的事情，其实我们还可以另外创建一个文件夹 <code>pictures</code> ，里面专门存放所有文章的图片，代码 <code>![](pictures/hexo.png)</code> 不仅可以本地预览，上传到网站也可以正常显示。</p>
<p><strong>注意：</strong> 不管采取哪种办法，都要创建一个和md文件同名的文件夹，里面放上需要的图片。<br>如果 <strong>2和3</strong> 中代码无法实现网站上的正常显示，那就使用 <strong>1</strong> 中的代码。<br>因为 <strong>2和3</strong> 中代码我无法保证每个人都成功。</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>参考：<br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">Ericam_：hexo引用本地图片无法显示</a><br><a href="https://www.cnblogs.com/Jesee/p/11234387.html" target="_blank" rel="noopener">Jesse-jia：解决Hexo图片无法显示问题</a></p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>24-两两交换链表中的节点</title>
    <url>/2019/12/11/LeetCode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">linked-list</td>
<td align="center">bloomberg / microsoft / uber</td>
</tr>
</tbody></table>
<h1 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, 你应该返回 <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：递归解法"><a href="#2-1-解法一：递归解法" class="headerlink" title="2.1 解法一：递归解法"></a>2.1 解法一：递归解法</h3><p>我们以 <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6</code> 为例。  </p>
<ol>
<li>我们拿出中间两个节点进行分析，例如 <code>3 -&gt; 4</code> 。</li>
<li>我们最终要使 <code>4</code> 指向 <code>3</code> ，上一个节点指向 <code>4</code>，<code>3</code> 指向下一个节点。<br>即 <code>上一节点 -&gt; 4 -&gt; 3 -&gt; 下一节点</code>。</li>
<li>我们对每一对节点都是 <strong>步骤2</strong> 中这样操作的。</li>
</ol>
<p><strong>现在有两个问题，递归函数返回什么？怎么使用递归函数的返回值？</strong></p>
<ol>
<li>假设我们在某次调用递归时完成了前两个节点的交换，得到了 <code>4 -&gt; 3</code> ，这时 结点 <code>4</code> 应该返回给上一次递归函数的结果，结点 <code>3</code> 应该指向下一次的递归函数的返回值。</li>
<li>然后，传递给递归函数的结点应该向后移动两位。</li>
</ol>
<p><strong>递归结束的条件？</strong><br>当我们的结点数不足两个时，递归结束。</p>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了49.37%的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了73.37%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *next = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(next-&gt;next);</span><br><span class="line">        next-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：非递归解法"><a href="#2-2-解法二：非递归解法" class="headerlink" title="2.2 解法二：非递归解法"></a>2.2 解法二：非递归解法</h3><p>我们用两个图来描述这个算法的过程。  </p>
<ul>
<li>实线箭头是原来的链表结构，虚线是我们改变之后的。</li>
<li>①②③④是我们交换链表的过程顺序。</li>
<li>注意，<code>p</code> 指针最后会更新（如④所示）。</li>
<li>当 <code>p</code> 之后的结点数不足两个时，循环结束。</li>
</ul>
<p><img src="/2019/12/11/LeetCode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/24_solution_1.png" alt="1"></p>
<p><img src="/2019/12/11/LeetCode/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/24_solution_2.png" alt="2"></p>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了49.37%的用户<br>内存消耗: 8.6 MB, 在所有 cpp 提交中击败了79.04%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode *h = p;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;next) &#123;</span><br><span class="line">            ListNode *c = p-&gt;next;</span><br><span class="line">            ListNode *n = p-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next = c-&gt;next;</span><br><span class="line">            c-&gt;next = n-&gt;next;</span><br><span class="line">            n-&gt;next = c;</span><br><span class="line">            p = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>23-合并K个排序链表</title>
    <url>/2019/12/08/LeetCode/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">linked-list / divide-and-conquer / heap</td>
<td align="center">airbnb / amazon / facebook / google / linkedin / microsoft / twitter / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>合并 $k$ 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：全部合并再排序"><a href="#2-1-解法一：全部合并再排序" class="headerlink" title="2.1 解法一：全部合并再排序"></a>2.1 解法一：全部合并再排序</h3><p>暴力而有效的解法：<br>我们将 $k$ 个链表全部放入向量中，然后进行排序，最后再放回到一个链表中。</p>
<p>当然我们也可以使用优先队列，那么在放入元素时自动进行了排序。</p>
<p>两者的性能是几乎没有任何差别的。</p>
<h4 id="2-1-1-向量-vector"><a href="#2-1-1-向量-vector" class="headerlink" title="2.1.1 向量 vector"></a>2.1.1 向量 vector</h4><blockquote>
<p>执行用时: 32 ms, 在所有 cpp 提交中击败了89.24%的用户<br>内存消耗: 11.7 MB, 在所有 cpp 提交中击败了63.01%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; elem;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *h = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;vec : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span>(vec) &#123;</span><br><span class="line">                elem.push_back(vec-&gt;val);</span><br><span class="line">                vec = vec-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(elem.begin(), elem.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : elem) &#123;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(i);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *ptrDelete = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-优先队列-priority-queue"><a href="#2-1-2-优先队列-priority-queue" class="headerlink" title="2.1.2 优先队列 priority_queue"></a>2.1.2 优先队列 priority_queue</h4><blockquote>
<p>执行用时: 36 ms, 在所有 cpp 提交中击败了78.17%的用户<br>内存消耗: 11.6 MB, 在所有 cpp 提交中击败了66.99%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *h = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;vec : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span>(vec) &#123;</span><br><span class="line">                q.push(vec-&gt;val);</span><br><span class="line">                vec = vec-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(q.top());</span><br><span class="line">            q.pop();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *ptrDelete = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：两两合并链表"><a href="#2-2-解法二：两两合并链表" class="headerlink" title="2.2 解法二：两两合并链表"></a>2.2 解法二：两两合并链表</h3><p>利用 <a href="https://www.faker.top/2019/11/19/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/" target="_blank" rel="noopener">LeetCode-21题：合并两个有序链表</a> ，将合并 $k$ 个链表转化为合并 $k-1$ 次两个链表。  </p>
<p>也就是将前两个链表合并成新的链表，新链表再和第三个链表合并，合并出的新链表再和第四个链表合并……<br>不过这个方法的复杂度很高。</p>
<blockquote>
<p>执行用时: 1428 ms, 在所有 cpp 提交中击败了5.02%的用户<br>内存消耗: 13.9 MB, 在所有 cpp 提交中击败了17.09%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode *res = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vec : lists) &#123;</span><br><span class="line">            res = mergeTwoLists(res, vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-解法三：分治"><a href="#2-3-解法三：分治" class="headerlink" title="2.3 解法三：分治"></a>2.3 解法三：分治</h3><blockquote>
<p>参考 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/23-he-bing-kge-pai-xu-lian-biao-yi-bu-bu-you-hua-d/" target="_blank" rel="noopener">Sun</a></p>
</blockquote>
<ol>
<li>两两合并链表，最后变成了 $\frac{k}{2}$ 个链表，继续合并，链表数目 $\frac{k}{2}$ -&gt; $\frac{k}{4}$ -&gt; $\frac{k}{8}$… ，直至最后变为一个链表。</li>
<li>我们使用队列实现该操作，将队列前两个链表合并后并弹出，合并后的链表添加到队列尾部，如此循环，直至队列中只有一个链表。</li>
</ol>
<blockquote>
<p>执行用时: 28 ms, 在所有 cpp 提交中击败了96.42%的用户<br>内存消耗: 14.2 MB, 在所有 cpp 提交中击败了17.09%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (lists.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;ListNode*&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> vec : lists)</span><br><span class="line">            q.push(vec);</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode* l1 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            ListNode* l2 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            q.push(mergeTwoLists(l1, l2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
        <tag>divide-and-conquer</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>执行 hexo d 时，提示连接Github的22端口超时</title>
    <url>/2019/12/06/Hexo/h1-hexo%20d%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA%E8%BF%9E%E6%8E%A5Github%E7%9A%8422%E7%AB%AF%E5%8F%A3%E8%B6%85%E6%97%B6/</url>
    <content><![CDATA[<p><strong>问题预览：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port <span class="number">22</span>: Connection timed out</span><br><span class="line">fatal: Could <span class="keyword">not</span> read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line"><span class="keyword">and</span> the repository exists.</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>具体错误信息如下：</p>
<p><img src="/2019/12/06/Hexo/h1-hexo%20d%E6%97%B6%EF%BC%8C%E6%8F%90%E7%A4%BA%E8%BF%9E%E6%8E%A5Github%E7%9A%8422%E7%AB%AF%E5%8F%A3%E8%B6%85%E6%97%B6/hexo-1_1.png" alt="1"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port <span class="number">22</span>: Connection timed out</span><br><span class="line">fatal: Could <span class="keyword">not</span> read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line"><span class="keyword">and</span> the repository exists.</span><br><span class="line">FATAL Something<span class="number">'</span>s wrong. Maybe you can find the solution here: https:<span class="comment">//hexo.io/docs/troubleshooting.html</span></span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (F:\Program Files\hexo\node_modules\hexo-util\lib\spawn.js:<span class="number">51</span>:<span class="number">21</span>)</span><br><span class="line">    at ChildProcess.emit (events.js:<span class="number">210</span>:<span class="number">5</span>)</span><br><span class="line">    at ChildProcess.cp.emit (F:\Program Files\hexo\node_modules\cross-spawn\lib\enoent.js:<span class="number">34</span>:<span class="number">29</span>)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:<span class="number">272</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>一开始我把目光聚焦在后面的 <code>Error: Spawn failed</code> 上，但是没有学过前端的我并看不懂。<br>但是，真正的错误是在上面一部分信息里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh: connect to host github.com port <span class="number">22</span>: Connection timed out</span><br><span class="line">fatal: Could <span class="keyword">not</span> read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line"><span class="keyword">and</span> the repository exists.</span><br><span class="line"></span><br><span class="line">ssh：连接到主机github.com端口<span class="number">22</span>：连接超时</span><br><span class="line">致命：无法从远程存储库读取。</span><br><span class="line">请确保您具有正确的访问权限，并且存储库存在。</span><br></pre></td></tr></table></figure>

<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2 解决办法"></a>1.2 解决办法</h2><p>直接暴力解决：<strong>重新配置密钥</strong></p>
<ol>
<li><p><code>git bash</code> 窗口依次输入:（注意：双引号里改为你的Github的名字和邮箱）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"MagicConchCpp"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">"csuzhangyang@gmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成新秘钥：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"csuzhangyang@gmail.com"</span></span><br></pre></td></tr></table></figure>

<p>选择文件路径，然后遇到下面这个直接回车。</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"csuzhangyang@gmail.com"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/lenovo/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p> 文件已经存在，是否重写？输入 <code>y</code> ，回车。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/c/Users/lenovo/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br></pre></td></tr></table></figure>

<p> 然后设置密码什么的，不用管，直接两下回车。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /c/Users/lenovo/.ssh/id_rsa.</span><br><span class="line">Your <span class="keyword">public</span> key has been saved in /c/Users/lenovo/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br></pre></td></tr></table></figure>
</li>
<li><p>新秘钥保存在 <code>/c/Users/lenovo/.ssh/id_rsa.pub</code> 。<br>打开这个文件，复制其中的的内容。<br>在 <code>github</code> 中，打开 <code>setting -&gt; SSH and GPG keys</code> 。删除原来的，把新的复制进去，即解决。重新执行 <code>hexo d</code>。</p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>22-括号生成</title>
    <url>/2019/11/21/LeetCode/22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">72.20%</td>
<td align="center">string / backtracking</td>
<td align="center">google / uber / zenefits</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出 $n$ 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如，给出 n = <span class="number">3</span>，生成结果为：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  <span class="string">"((()))"</span>,</span><br><span class="line">  <span class="string">"(()())"</span>,</span><br><span class="line">  <span class="string">"(())()"</span>,</span><br><span class="line">  <span class="string">"()(())"</span>,</span><br><span class="line">  <span class="string">"()()()"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：回溯"><a href="#2-1-解法一：回溯" class="headerlink" title="2.1 解法一：回溯"></a>2.1 解法一：回溯</h3><p>以 <code>n = 3</code> 为例：我们的字符串 <code>s</code> 一共有 <code>6</code> 个位置来放置 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code>。</p>
<ol>
<li>首先我们知道：第一个位置一定是 <code>&#39;(&#39;</code>，此时 <code>s = ( _ _ _ _ _</code>。</li>
<li>此时我们考虑第二个位置，我们选择可以放置<code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code>。<br><strong>那么什么情况下，我们可以有两个选择呢？</strong><br>很容易想到，应该是当 <code>&#39;(&#39;</code> 的数量大于 <code>&#39;)&#39;</code> 的数量 <strong>并且</strong> <code>&#39;(&#39;</code> 的数量小于 <code>n</code> 时，即 <code>if (left &lt; N &amp;&amp; left &gt; right)</code>。<br>可以思考 <code>s = ( ( ) _ _ _</code> 和 <code>s = ( ( ( ) _ _</code>这两种情况下，下一个位置应该放哪种括号。</li>
<li>步骤2中，我们可以有两个选择。那么我们接下来就应该考虑什么情况下只有一种选择。</li>
<li><strong>只能放置 <code>&#39;(&#39;</code></strong>。<br>易知，当 <code>&#39;(&#39;</code> 的数量等于 <code>&#39;)&#39;</code> 的数量时，我们只能向后添加 <code>&#39;(&#39;</code> 。<br>可以思考 <code>s = ( ( ) ) _ _</code> 和 <code>s = ( ) ( ) _ _</code>这两种情况下，下一个位置应该放哪种括号。</li>
<li><strong>只能放置 <code>&#39;)&#39;</code></strong>。<br>易知，当 <code>&#39;(&#39;</code> 的数量等于 <code>n</code> 时，我们只能向后添加 <code>&#39;)&#39;</code> 。<br>可以思考 <code>s = ( ( ( _ _ _</code> 和 <code>s = ( ) ( ( _ _</code>这两种情况下，下一个位置应该放哪种括号。</li>
</ol>
<p>我们的回溯函数 <code>void backtrack(int left, int right, const string &amp;s)</code> 中，<code>left</code> 和 <code>right</code> 代表的是 <code>s</code> 中左右括号的数量。<br>当 <code>left + right == 2 * N</code> 时，回溯结束。</p>
<p><strong>注意：</strong><br>初始情况下，我们必须要先添加一个 <code>&#39;(&#39;</code>，此时 <code>s =  ( _ _ _ _ _</code>，所以参数 <code>left = 1, right = 0</code>。</p>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了96.60%的用户<br>内存消耗: 17.4 MB, 在所有 cpp 提交中击败了36.95%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">        backtrack(<span class="number">1</span>, <span class="number">0</span>, s + <span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left + right == <span class="number">2</span> * N) &#123;</span><br><span class="line">            res.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; N &amp;&amp; left &gt; right) &#123;</span><br><span class="line">            backtrack(left + <span class="number">1</span>, right, s + <span class="string">"("</span>);</span><br><span class="line">            backtrack(left, right + <span class="number">1</span>, s + <span class="string">")"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == N) &#123;</span><br><span class="line">            backtrack(left, right + <span class="number">1</span>, s + <span class="string">")"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            backtrack(left + <span class="number">1</span>, right, s + <span class="string">"("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：动态规划"><a href="#2-2-解法二：动态规划" class="headerlink" title="2.2 解法二：动态规划"></a>2.2 解法二：动态规划</h3><blockquote>
<p>参考 <a href="https://leetcode.com/rockrock2/" target="_blank" rel="noopener">rockrock2</a>，<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/" target="_blank" rel="noopener">Yuyu</a></p>
</blockquote>
<p>首先看 <code>n</code> 较小时的结果。</p>
<ol>
<li><code>n = 0</code> 是，<code>res = { &quot;&quot; }</code>，为空。</li>
<li><code>n = 1</code> 是，<code>res = { &quot;()&quot; }</code>。</li>
<li><code>n = 2</code> 是，<code>res = { &quot;(())&quot;, &quot;()()&quot; }</code>。</li>
<li><code>n = 3</code> 是，<code>res = { &quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot; }</code>。</li>
</ol>
<p>问题来了，你没有考虑过每一个 <code>n</code> 的结果，都和比它小的 <code>n</code> 的结果，有点关联？</p>
<p>我们可以这么看待这个问题：</p>
<ol>
<li><code>n = i</code> 的结果其实就是比 <code>n = i - 1</code> 多了一对括号。我们可能会想，那么这对括号应该如何放置呢？而事实上，我们应该这样想，那么 <code>n = 1..i-1</code> 的结果，应该如何放到这对括号里呢？也就是这对括号，是不动的。</li>
<li>我们只有两个地方可以放，一是这一对括号内部，二是括号外部。<br><strong>外部：</strong> 其实放在括号左侧或者右侧都行。但是放在右侧，结果会按照字典序排列，因此我们选择放在右侧。但是要知道，放在左侧也是可以的。</li>
<li>我们要对所有 <code>n &lt; i</code> 的情况遍历，要保证最后括号一共 <code>i</code> 对。<ol>
<li>所以如果内部放 <code>n = 0</code> 的结果，右侧就要放 <code>n = i - 1</code> 的结果，排列所有情况。</li>
<li>如果内部放 <code>n = 1</code> 的结果，右侧就要放 <code>n = i - 2</code> 的结果，排列所有情况。</li>
<li>以此类推。。。<br>最后，内部放 <code>n = i - 1</code> 的结果，右侧就要放 <code>n = 0</code> 的结果，排列所有情况。</li>
</ol>
</li>
<li>我们可以得出状态方程：<code>dp[i] = &#39;(&#39; + dp[k] + &#39;)&#39; + dp[i-1-k], k = 0..i-1</code></li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了82.13%的用户<br>内存消耗: 9.9 MB, 在所有 cpp 提交中击败了97.08%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dp[0] = ""</span></span><br><span class="line"><span class="comment">// dp[i] = '(' + dp[k] + ')' + dp[i-1-k], k = 0..i-1 (按字典序)</span></span><br><span class="line"><span class="comment">// 或者dp[i] = dp[k] + '(' + dp[i-1-k] + ')', k = 0..i-1 (非字典序)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">        dp[<span class="number">0</span>] = &#123;<span class="string">""</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; i; ++ k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> s1 : dp[k]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> s2 : dp[i - <span class="number">1</span> - k]) &#123;</span><br><span class="line">                        dp[i].push_back(<span class="string">"("</span> + s1 + <span class="string">")"</span> + s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>21-合并两个有序链表</title>
    <url>/2019/11/19/LeetCode/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">57.92%</td>
<td align="center">linked-list</td>
<td align="center">amazon / apple / linkedin / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：归并排序"><a href="#2-1-解法一：归并排序" class="headerlink" title="2.1 解法一：归并排序"></a>2.1 解法一：归并排序</h3><ol>
<li>创建一个新的链表 <code>h</code> ，用于存储合并后的链表。</li>
<li>遍历两个链表。比较两者当前的 <code>val</code> 大小，小的则加入到 <code>h</code> 中，并向后移，另外一个链表不用移动。直至某一个链表遍历到尾部，结束。</li>
<li>此时肯定有一个链表没有遍历到尾部，将这个链表剩余的元素依次加入到 <code>h</code> 后面即可。</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了96.15%的用户<br>内存消耗: 9.1 MB, 在所有 cpp 提交中击败了73.70%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* h = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* head = h;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l1) &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l1-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l2) &#123;</span><br><span class="line">                h-&gt;next = <span class="keyword">new</span> ListNode(l2-&gt;val);</span><br><span class="line">                h = h-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ptrDelete = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：递归（两种）"><a href="#2-2-解法二：递归（两种）" class="headerlink" title="2.2 解法二：递归（两种）"></a>2.2 解法二：递归（两种）</h3><h4 id="2-2-1-简单递归"><a href="#2-2-1-简单递归" class="headerlink" title="2.2.1 简单递归"></a>2.2.1 简单递归</h4><blockquote>
<p>参考<a href="https://leetcode.com/zxyperfect/" target="_blank" rel="noopener">zxyperfect</a></p>
</blockquote>
<ol>
<li><strong>递归思路：</strong><br> 我们每次从两个链表的头结点选出一个较小的放在结果中，并在原链表中删除该结点，然后继续比较两个链表。直至一个链表为空。</li>
<li><strong>递归结束条件：</strong><br>当某个链表为空时，递归结束，但我们返回的是另一个链表。因为另一个链表剩下的肯定是值最大的那部分。例如：<code>if(l1 == nullptr) { return l2; }</code>。</li>
</ol>
<blockquote>
<p>执行用时: 12 ms, 在所有 cpp 提交中击败了69.38%的用户<br>内存消耗: 9 MB, 在所有 cpp 提交中击败了74.60%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-利用swap函数递归"><a href="#2-2-2-利用swap函数递归" class="headerlink" title="2.2.2 利用swap函数递归"></a>2.2.2 利用swap函数递归</h4><blockquote>
<p>参考 <a href="https://leetcode.com/StefanPochmann/" target="_blank" rel="noopener">StefanPochmann</a></p>
</blockquote>
<p><strong>swap函数介绍：</strong><br><code>swap(a, b)</code> ：交换a和b。在此结构体中的意思就是 <code>a-&gt;next</code> 和 <code>b-&gt;next</code> 交换，<code>a-&gt;val</code> 和 <code>b-&gt;val</code> 也交换。</p>
<ol>
<li>首先注意，我们的合并后的链表是 <code>a</code> 头结点所指向的链表，也就是 <code>a</code> 所走过的位置, 都被按顺序加了进来。</li>
<li>总的思想就是：若 <code>a-&gt;val &gt; b-&gt;val</code> ，就 <code>swap(a, b)</code> ，把 <code>a</code> 放到小的那个节点。<br>反之，<code>a</code> 继续向所在节点后面移动，继续比较，<code>a</code> 会始终保持在较小的那个节点上。</li>
<li>若 <code>a</code> 所在链表到达尾部时（<code>a = nullptr</code>），说明另外一个链表剩余的都是最大的几个值，我们这时仍需要 <code>swap(a, b)</code> ，将 <code>a</code> 放到另一个链表剩余的值上。</li>
<li>后续我会画个图例出来。</li>
</ol>
<blockquote>
<p>执行用时 :8 ms, 在所有 cpp 提交中击败了95.91%的用户<br>内存消耗 :8.7 MB, 在所有 cpp 提交中击败了97.11%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);</span><br><span class="line">        <span class="keyword">if</span> (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>20-有效的括号</title>
    <url>/2019/11/15/LeetCode/20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">39.88%</td>
<td align="center">string / stack</td>
<td align="center">airbnb / amazon / bloomberg / facebook / google / microsoft / twitter / zenefits</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><ol>
<li>通过栈来解决。</li>
<li>遇见左括号就压入栈中，遇见右括号，则判断当前栈顶元素是否是对应的左括号。若是，则将该左括号出栈；若不是，则返回 <code>false</code>。</li>
<li>最后根据栈是否为空来判断括号是否有效，栈为空则有效。</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了75.87%的用户<br>内存消耗: 8.6 MB, 在所有 cpp 提交中击败了71.46%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; m = &#123; &#123;<span class="string">'('</span>, <span class="string">')'</span>&#125;, &#123;<span class="string">'['</span>, <span class="string">']'</span>&#125;, &#123;<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st.empty() &amp;&amp; m[st.top()] == c) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m[c] == <span class="number">0</span>) &#123; <span class="comment">// m[c] == 0即：是右括号的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                st.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>19-删除链表的倒数第N个节点</title>
    <url>/2019/11/14/LeetCode/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">36.08%</td>
<td align="center">linked-list / two-pointers</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2.</span></span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5.</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>
<h2 id="2-解法：双指针法"><a href="#2-解法：双指针法" class="headerlink" title="2. 解法：双指针法"></a>2. 解法：双指针法</h2><p><strong>如何找到链表的倒数第 $n$ 个节点？</strong></p>
<ol>
<li>定义两个指针 <code>l1</code>，<code>l2</code>，均指向头结点。</li>
<li>先让 <code>l1</code> 向右移动 <code>n - 1</code> 次。</li>
<li>然后再同时向右移动 <code>l1</code> 和 <code>l2</code>，等到 <code>l1</code> 移动到尾节点时， <code>l2</code> 此时指向倒数第 <code>n</code> 个节点。</li>
</ol>
<p>需要注意的是，我们目的是要 <strong>删除</strong> 倒数第 <code>n</code> 个节点，所以我们要找到倒数第 <code>n + 1</code> 个节点。也就是步骤 <strong>2</strong> 中，<code>l1</code> 总共应该向右移动 <code>n</code> 次。</p>
<p><strong>接下来，思考这么一个问题。</strong> 假如我们的链表长度为 $n$，而我们要删除倒数第 $n$ 个元素（也就是第一个元素），这时会有什么问题呢？</p>
<p>答案很明显，我们无法找到倒数第 $n+1$ 个元素，也就是第0个元素，但是我们没有第0个元素，这时就无法删除第一个元素了。</p>
<p>有的人可能会说，那我们直接对这种情况特殊处理就好啦。<br>但是，需要注意的是，我们的复杂度要求是 <strong>只遍历一遍链表</strong> ，也就是我们先前并不知道链表的长度，也就无法判断是否是这种情况。</p>
<p>在这里，我们给出<strong>两种</strong>解决办法。  </p>
<h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>向头结点前增加一个结点，也就是添加了第0个元素。</p>
<p><strong>注意一个问题。</strong> 最后返回的是 <code>h-&gt;next</code>，开头我们定义了 <code>l1 = l2 = h, l1-&gt;next = head</code>，即：<code>h-&gt;next = head</code>，那么能不能返回 <code>head</code> 呢？<br>答案是<strong>不能</strong>。<br>在删除的是第一个元素的情况下结果会出错，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">预期结果：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>因为我们的目的是删除该头结点，我们并没有对 <code>head</code> 这个头结点有任何操作，那么最后返回 <code>head</code> 的话就必定会有头结点存在。</p>
<p>我们会在<strong>解法二</strong>中看到，处理删除第一个元素的情况是返回 <code>head-&gt;next</code>。</p>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了72.41%的用户<br>内存消耗: 8.6 MB, 在所有 cpp 提交中击败了76.23%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 头结点前增加一个结点</span></span><br><span class="line">        ListNode* l1 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        l1-&gt;next = head;</span><br><span class="line">        ListNode* l2 = l1;</span><br><span class="line">        ListNode* h = l2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1-&gt;next) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next = l2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-解法二"><a href="#2-1-解法二" class="headerlink" title="2.1 解法二"></a>2.1 解法二</h3><blockquote>
<p>参考<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/java-shuang-zhi-zhen-jie-fa-zhi-xing-shi-jian-chao/" target="_blank" rel="noopener">【微笑永恒】</a></p>
</blockquote>
<ol>
<li>先让 <code>l1</code> 向右移动 <code>n - 1</code> 次，若此时 <code>l1-&gt;next</code> 为空，说明我们要删除第一个元素。直接返回 <code>head-&gt;next</code> 即可。</li>
<li>若 <code>l1-&gt;next</code> 不为空，<code>l1</code> 再向右移动一次，即共移动 <code>n</code> 次。</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了96.70%的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了90.51%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* l1 = head;</span><br><span class="line">        ListNode* l2 = l1;</span><br><span class="line">        <span class="comment">// 右移n-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要删除的元素是不是第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (!l1-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="comment">// 应该右移n次，补上一次</span></span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">        <span class="comment">// 两个指针同时移动，直到l1到末尾</span></span><br><span class="line">        <span class="keyword">while</span> (l1-&gt;next) &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除该元素</span></span><br><span class="line">        l2-&gt;next = l2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>two-pointers</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>18-四数之和</title>
    <url>/2019/11/14/LeetCode/18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">36.01%</td>
<td align="center">array / hash-table / two-pointers</td>
<td align="center">linkedin</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包含 $n$ 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 $a$，$b$，$c$ 和 $d$ ，使得 $a + b + c + d$ 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">2</span>]，和 target = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">-2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><p>与前面三数之和类似，还是采用双指针法，双指针是用来选择后两个数的，因此前面还需要两个循环，来选择前两个数。</p>
<p>需要注意的是这四个数，都需要进行去重处理。双指针的去重我不再赘述，详情参考 <a href="https://blog.csdn.net/qq_36408085/article/details/102907454" target="_blank" rel="noopener">LeetCode(C++)刷题计划：15-三数之和</a>。</p>
<p>下面我们讲一下，前两个数的去重代码，以 <code>nums = [0, 0, 1, 1, 1, 2]</code> 为例。</p>
<ol>
<li>首先第一个数的去重代码 <code>if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;</code><ol>
<li><code>nums[i] == nums[i - 1]</code> 的作用就是判断当前数是否和前一个数相等。</li>
<li><code>i &gt; 0</code>，是为了防止第一个数的 <code>nums[0] == nums[-1]</code>，这样数组就越界了。</li>
</ol>
</li>
<li>第二个数的去重代码 <code>if (k &gt; i + 1 &amp;&amp; nums[k] == nums[k - 1]) continue;</code><ol>
<li><code>nums[k] == nums[k - 1]</code> 的作用和前面一样。</li>
<li><code>k &gt; i + 1</code> 的目的倒不是防止越界，因为不可能越界。它主要为了防止过度去重。<br>举个例子：<code>nums = [0, 0, 1, 1, 1, 2]</code>。<br>当 <code>i = 2</code> 时, <code>nums[i] = 1</code>。此时 <code>k = i + 1 = 3</code>, <code>nums[k] = 1</code>。<br>如果我们没有 <code>k &gt; i + 1</code> 这句，他会认为 <code>nums[k]</code> 是重复数据(因为 <code>nums[k] == nums[k - 1]</code>)。但是实际上是<code>nums[k]</code> 和 <code>nums[i]</code> (k = i + 1)在比较是否相等，然而这两个数是可以相等的。<br><strong>我们需要避免的是</strong>，在同一个 <code>nums[i]</code> 下，连续的 <code>nums[k]</code> 不能相等， <code>nums[i]</code> 不在我们的比较范围内。</li>
</ol>
</li>
</ol>
<blockquote>
<p>执行用时: 76 ms, 在所有 cpp 提交中击败了42.69%的用户<br>内存消耗: 8.9 MB, 在所有 cpp 提交中击败了96.88%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> k = i + <span class="number">1</span>; k &lt; n - <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; i + <span class="number">1</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> r = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[k] + nums[l] + nums[r];</span><br><span class="line">                    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                        res.push_back(&#123;nums[i], nums[k], nums[l], nums[r]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++ l]) &#123; &#125;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[--r ]) &#123; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        ++ l;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        -- r;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>17-电话号码的字母组合</title>
    <url>/2019/11/10/LeetCode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">51.27%</td>
<td align="center">string / backtracking</td>
<td align="center">amazon / dropbox / facebook / google / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 <code>1</code> 不对应任何字母。</p>
<img src="/2019/11/10/LeetCode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/17.png" width="300" height="300" alt="图片名称">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入：<span class="string">"23"</span></span><br><span class="line">输出：[<span class="string">"ad"</span>, <span class="string">"ae"</span>, <span class="string">"af"</span>, <span class="string">"bd"</span>, <span class="string">"be"</span>, <span class="string">"bf"</span>, <span class="string">"cd"</span>, <span class="string">"ce"</span>, <span class="string">"cf"</span>].</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：递归法"><a href="#2-1-解法一：递归法" class="headerlink" title="2.1 解法一：递归法"></a>2.1 解法一：递归法</h3><p>以 <code>digits = &quot;23&quot;</code>为例：</p>
<ol>
<li><p>我们递归函数只接受两个参数：上一次的结果 <code>res</code> ，这一次要结合的数字 <code>digits[i]</code>。</p>
</li>
<li><p>首先用第一个数字初始化我们的 <code>res</code>，例如第一个数字是 <code>2</code> ，那么 <code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}</code> 。</p>
</li>
<li><p>第二个数字是 <code>3</code>，<code>m[3] = &quot;def&quot;</code>。那么 <code>m[3]</code> 和 <code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}</code>怎么组合呢？</p>
</li>
<li><p>首先 <code>res</code> 暂时只有3个元素，和 <code>m[3]</code> 组合后应该有 $3 \times 3 = 9$ 个元素。</p>
</li>
<li><p>总的来说，元素的添加顺序是，</p>
<ol>
<li><p><code>res.push_back(res[0] + &#39;e&#39;); res.push_back(res[0] + &#39;f&#39;);</code><br>结果：<code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;}</code></p>
</li>
<li><p><code>res.push_back(res[1] + &#39;e&#39;); res.push_back(res[1] + &#39;f&#39;);</code><br>结果：<code>res = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;}</code></p>
</li>
<li><p><code>res[0] += &#39;d&#39;; res[1] += &#39;d&#39;; res[2] += &#39;d&#39;;</code><br>结果：<code>res = {&quot;ad&quot;, &quot;bd&quot;, &quot;cd&quot;, &quot;ae&quot;, &quot;be&quot;, &quot;ce&quot;, &quot;af&quot;, &quot;bf&quot;, &quot;cf&quot;}</code></p>
</li>
</ol>
</li>
<li><p>我们得出一个规律，假设当前数字中所含字母长度为 <code>l</code>（n=3或4）。我们可以将前 <code>l-1</code> 个字母和 <code>res</code> 进行排列组合加入到 <code>res</code>中。为什么要剩下一个字母呢，因为我们 <code>res</code> 中还有一些元素仍然是上次的结果，我们把最后一个字母直接加入到上次的结果的元素后。</p>
</li>
<li><p>当然你也可以选择将所以字母和 <code>res</code> 进行排列组合，然后删除前面的无效的元素。</p>
</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了 77.47% 的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了 90.68% 的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> m[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; digits.size(); ++ i) &#123;</span><br><span class="line">            combine(res, digits[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = res.size();</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ch) - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">int</span> l = m[digit].size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; l; ++ j) &#123;</span><br><span class="line">                <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">1</span>, m[digit][j])</span></span>;</span><br><span class="line">                res.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; l - <span class="number">1</span>; ++ j)</span><br><span class="line">                res.push_back(res[i] + m[digit][j]);</span><br><span class="line">            res[i] += m[digit][l - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：使用队列"><a href="#2-2-解法二：使用队列" class="headerlink" title="2.2 解法二：使用队列"></a>2.2 解法二：使用队列</h3><ol>
<li>每次从队头取出一个元素，与m[]中字符串中的每个字符分别组合，然后放入队尾。</li>
</ol>
<blockquote>
<p>执行用时: 0 ms, 在所有 cpp 提交中击败了 100.00% 的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了 48.35% 的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m = &#123; &#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;, &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125; &#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="comment">// 先处理第一个数字。是为了使q不为空。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m[digits[<span class="number">0</span>]]) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">1</span>, i)</span></span>;</span><br><span class="line">            q.push(s);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; digits.size(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; len; ++ j) &#123;</span><br><span class="line">                <span class="built_in">string</span> s = q.front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; m[digits[i]].size(); ++ k) &#123;</span><br><span class="line">                    q.push(s + m[digits[i]][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            res.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-深度优先遍历"><a href="#2-3-深度优先遍历" class="headerlink" title="2.3 深度优先遍历"></a>2.3 深度优先遍历</h3><blockquote>
<p>第一段代码来自 <a href="https://leetcode.com/zefengsong/" target="_blank" rel="noopener">zefengsong</a>。<br>第二份代码是参考 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/yan-du-you-xian-bian-li-by-gqxing/" target="_blank" rel="noopener">GQXING</a> 修改了的第一份代码。<br>图来自 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode/" target="_blank" rel="noopener">LeetCode</a></p>
</blockquote>
<p>如图所示。<br><img src="/2019/11/10/LeetCode/17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/17_solution.png" alt="2"></p>
<blockquote>
<p>执行用时: 0 ms, 在所有 cpp 提交中击败了 100.00% 的用户<br>内存消耗: 8.5 MB, 在所有 cpp 提交中击败了 79.75% 的用户</p>
</blockquote>
<p><strong>代码一：</strong> <code>path</code> 引用传值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;letter(&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;);</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">""</span>;</span><br><span class="line">        DFS(digits, <span class="number">0</span>, path, res, letter);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> pos, <span class="built_in">string</span>&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; letter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.size())&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: letter[digits[pos] - <span class="string">'0'</span>])&#123;</span><br><span class="line">            path.push_back(c);</span><br><span class="line">            DFS(digits, pos + <span class="number">1</span>, path, res, letter);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>代码二：</strong> <code>path</code> 非引用传值。</p>
<p>虽然我们知道，在传递字符串时，最好使用引用传值。但是我们的目的是在一次递归里不修改 <code>path</code> 的值(否则我们就要像代码1一样，还要删除 <code>path</code> 的尾元素)，所以我们不使用引用传值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; letterCombinations(<span class="built_in">string</span> digits) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;res;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;letter(&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;);</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">""</span>;</span><br><span class="line">        DFS(digits, <span class="number">0</span>, path, res, letter);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> pos, <span class="built_in">string</span> path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; letter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.size())&#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c: letter[digits[pos] - <span class="string">'0'</span>])&#123;</span><br><span class="line">            DFS(digits, pos + <span class="number">1</span>, path + c, res, letter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>16-最接近的三数之和</title>
    <url>/2019/11/07/LeetCode/16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">41.91%</td>
<td align="center">array / two-pointers</td>
<td align="center">bloomberg</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [<span class="number">-1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">-4</span>], 和 target = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 <span class="number">2.</span> (<span class="number">-1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><ol>
<li>与第15题三数之和类似。三数之和是当和为 <code>target</code> 是我们需要的值，此题则是$|sum - target|$最小时，是我们需要的值。</li>
<li>其余部分和三数之和相同。参考链接：<a href="https://blog.csdn.net/qq_36408085/article/details/102907454" target="_blank" rel="noopener">15 - 三数之和</a></li>
</ol>
<blockquote>
<p>执行用时: 12 ms, 在所有 cpp 提交中击败了 72.29% 的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了 87.01% 的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">long</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">0</span>; k &lt; nums.size() - <span class="number">2</span>; ++ k) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                sum = nums[k] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(sum - target) &lt; <span class="built_in">abs</span>(res - target))</span><br><span class="line">                        res = sum;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++ l]) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[-- r]) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>15-三数之和</title>
    <url>/2019/11/04/LeetCode/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">24.31%</td>
<td align="center">array / two-pointers</td>
<td align="center">adobe / amazon / bloomberg / facebook / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个包含 <em>n</em> 个整数的数组 nums，判断 nums 中是否存在三个元素 $a，b，c ，$使得 $a + b + c = 0$ ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><ol>
<li>首先对数组从大到小排序，数组的大小为 <code>n</code> 。</li>
<li>固定一个数，从其右侧的数中寻找另外两个数。<br>假设我们固定的数为 <code>nums[k], k = 0 to n-1</code> , 另外两个数初始时分别为 <code>nums[l], nums[r]</code> , 其中 <code>l = k + 1, r = n - 1</code> 。</li>
<li>令 <code>sum = nums[k] + nums[l] + nums[r]</code> 。<ol>
<li>若 <code>sum &lt; 0</code> ，则我们要增大 <code>sum</code> ，此时只能对 <code>l</code> 向右挪一格，即：<code>l ++</code> 。</li>
<li>若 <code>sum &gt; 0</code> ，则我们要减小 <code>sum</code> ，此时只能对 <code>r</code> 向左挪一格，即：<code>r --</code> 。</li>
<li>若 <code>sum == 0</code> ，此时这三个数就我们需要的数，将他们加入结果里。此时，<code>l</code> 和 <code>r</code> 之间的数还可能有我们需要的数，我们此时需要左右都向内移动，即：<code>l ++, r --</code> 。。  </li>
</ol>
</li>
<li><strong>避免重复的数据。</strong><ol>
<li>当 <code>sum == 0</code> 时，我们需要 <code>l</code> 和 <code>r</code> 都向内移动。此时需要过滤掉和当前 <code>nums[l], nums[r]</code> 重复的数据，我们巧妙的使用了两个while循环，同时需注意 <code>l 要一直小于 r</code>。<br><code>while (l &lt; r &amp;&amp; nums[l] == nums[++ l]) { }</code><br><code>while (l &lt; r &amp;&amp; nums[r] == nums[-- r]) { }</code></li>
<li>同时，我们也要在 <code>k</code> 的循环中过滤掉和当前 <code>nums[k]</code> 重复的数字。这里的 <code>k &lt; len - 2</code>主要是防止数组越界。<br><code>while (k &lt; len - 2 &amp;&amp; nums[k] == nums[++ k]) { }</code></li>
</ol>
</li>
<li>当 <code>l &gt;= r</code> 时，说明与当前固定的 <code>nums[k]</code> 相组合的两个数已经找完，所以要进入下一个 <code>nums[k]</code>。</li>
</ol>
<blockquote>
<p>执行用时: 112 ms, 在所有 cpp 提交中击败了98.73%的用户<br>内存消耗: 14.6 MB, 在所有 cpp 提交中击败了86.17%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; len - <span class="number">2</span> &amp;&amp; nums[k] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[k] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.push_back(&#123;nums[k], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[++ l]) &#123; &#125;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[-- r]) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++ l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    -- r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; len - <span class="number">2</span> &amp;&amp; nums[k] == nums[++ k]) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>14-最长公共前缀</title>
    <url>/2019/11/02/LeetCode/14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">35.13%</td>
<td align="center">string</td>
<td align="center">yelp</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong> 所有输入只包含小写字母 <code>a-z</code> 。</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li>从第一个位置开始，判断每个字符串该位置是否全部相等。</li>
<li>即：若 <code>vector&lt;string&gt;</code> 字符串为 <code>str1, str2, str3</code>。<ul>
<li>我们比较 <code>str1[0], str2[0], str3[0]</code> 是否全部相等。</li>
<li>若相等，比较 <code>str1[1], str2[1], str3[1]</code> 是否全部相等。</li>
<li>依次下去比较，直至第一次不全部相等时结束。</li>
</ul>
</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了71.92%的用户<br>内存消耗: 8.7 MB, 在所有 cpp 提交中击败了92.56%的用户</p>
</blockquote>
<p><strong>1. 将 <code>vector&lt;string&gt;</code> 视为二维数组：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> m = strs.size();</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i].size() &gt; maxSize)</span><br><span class="line">                maxSize = strs[i].size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; maxSize; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (strs[j][i] != strs[j + <span class="number">1</span>][i])</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res += strs[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 利用迭代器：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = strs.begin();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; strs.size(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*(iter + i)).size() &gt; maxSize)</span><br><span class="line">                maxSize = (*(iter + i)).size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; maxSize; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; strs.size() - <span class="number">1</span>; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*(iter + j))[i] != (*(iter + j + <span class="number">1</span>))[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += (*iter)[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>13-罗马数字转整数</title>
    <url>/2019/11/01/LeetCode/13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">59.40%</td>
<td align="center">math / string</td>
<td align="center">bloomberg / facebook / microsoft / uber / yahoo</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>罗马数字包含以下七种字符： <code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"III"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"IV"</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"IX"</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/roman-to-integer/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li>我们可以发现，如果前一个字母小于后一个字母（例如：<code>CM</code>），那么它俩肯定是组合数（即<code>CM = M-C = 900</code>）。</li>
<li>所以我们只要发现 <code>s[i] &lt; s[i + 1]</code> 那么我们就加上它俩之差。</li>
<li>其余的都是单个字母，加上单个字母的值。</li>
</ol>
<p>我们给出两种代码，一种是正序遍历，一种是逆序遍历，显然逆序遍历更加简洁。</p>
<blockquote>
<p>执行用时: 24 ms, 在所有 cpp 提交中击败了62.53%的用户<br>内存消耗: 10.7 MB, 在所有 cpp 提交中击败了84.86%的用户</p>
</blockquote>
<p><strong>正序遍历：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; romanMap= &#123; &#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;, &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;, &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;, &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> num[n];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            num[i] = romanMap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> romanMap[s[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] &lt; num[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                sum = sum + num[i + <span class="number">1</span>] - num[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sum += num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[n - <span class="number">2</span>] &gt;= num[n - <span class="number">1</span>])</span><br><span class="line">            sum += num[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>逆序遍历：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; romanMap= &#123; &#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;, &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                                             &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;, &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;, &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = romanMap[s.back()];</span><br><span class="line">        <span class="comment">// auto i = s.size() - 2 报错</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            sum += romanMap[s[i]] &gt;= romanMap[s[i + <span class="number">1</span>]] ? romanMap[s[i]] : -romanMap[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>12-整数转罗马数字</title>
    <url>/2019/10/31/LeetCode/12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">61.47%</td>
<td align="center">math / string</td>
<td align="center">twitter</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>罗马数字包含以下七种字符： <code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="number">9</span></span><br><span class="line">输出: <span class="string">"IX"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: L = <span class="number">50</span>, V = <span class="number">5</span>, III = <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：字典寻找法"><a href="#2-1-解法一：字典寻找法" class="headerlink" title="2.1 解法一：字典寻找法"></a>2.1 解法一：字典寻找法</h3><ol>
<li>我们将个、十、百、千位所有可能出现的数字的罗马字母都罗列出来，然后求出所求数字的个、十、百、千位的值，找出对应的罗马字母即可。</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了91.78%的用户<br>内存消耗: 8.3 MB, 在所有 cpp 提交中击败了90.53%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ge[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> shi[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> bai[<span class="number">10</span>] = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> qian[<span class="number">4</span>] = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> qian[num / <span class="number">1000</span>] + bai[(num % <span class="number">1000</span>) / <span class="number">100</span>] + shi[(num % <span class="number">100</span>) / <span class="number">10</span>] + ge[num % <span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：贪心算法"><a href="#2-2-解法二：贪心算法" class="headerlink" title="2.2 解法二：贪心算法"></a>2.2 解法二：贪心算法</h3><ol>
<li>我们列出所有最小单位的罗马字母组合，假设输入整数为 <code>num</code>。</li>
<li>从最大的数开始匹配，看 <code>num</code> 能匹配几次，每次匹配 <code>num</code> 都要减去这个数。</li>
<li>若 <code>num</code> 开始小于最大的数，则从第二大的数再次开始匹配，直至 <code>num</code> 变为 <code>0</code>。</li>
</ol>
<p>我给出两种代码，一种是利用反向迭代器，一种利用普通迭代器，主要是为了熟悉迭代器操作。</p>
<blockquote>
<p>执行用时 :28 ms, 在所有 cpp 提交中击败了22.65%的用户<br>内存消耗 :15.3 MB, 在所有 cpp 提交中击败了70.87%的用户</p>
</blockquote>
<p><strong>1 反向迭代器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; romanMap= &#123; &#123;<span class="number">1</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"IV"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"V"</span>&#125;, &#123;<span class="number">9</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">10</span>, <span class="string">"X"</span>&#125;, &#123;<span class="number">40</span>, <span class="string">"XL"</span>&#125;, &#123;<span class="number">50</span>, <span class="string">"L"</span>&#125;, &#123;<span class="number">90</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">100</span>, <span class="string">"C"</span>&#125;, &#123;<span class="number">400</span>, <span class="string">"CD"</span>&#125;, &#123;<span class="number">500</span>, <span class="string">"D"</span>&#125;, &#123;<span class="number">900</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">1000</span>, <span class="string">"M"</span>&#125; &#125;;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::reverse_iterator r_iter = romanMap.rbegin();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (r_iter != romanMap.rend()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= r_iter-&gt;first) &#123;</span><br><span class="line">                res += r_iter-&gt;second;</span><br><span class="line">                num -= r_iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r_iter ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2 普通迭代器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; romanMap= &#123; &#123;<span class="number">1</span>, <span class="string">"I"</span>&#125;, &#123;<span class="number">4</span>, <span class="string">"IV"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"V"</span>&#125;, &#123;<span class="number">9</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">10</span>, <span class="string">"X"</span>&#125;, &#123;<span class="number">40</span>, <span class="string">"XL"</span>&#125;, &#123;<span class="number">50</span>, <span class="string">"L"</span>&#125;, &#123;<span class="number">90</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">100</span>, <span class="string">"C"</span>&#125;, &#123;<span class="number">400</span>, <span class="string">"CD"</span>&#125;, &#123;<span class="number">500</span>, <span class="string">"D"</span>&#125;, &#123;<span class="number">900</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">                                     &#123;<span class="number">1000</span>, <span class="string">"M"</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">auto</span> iter = -- romanMap.end();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (iter != -- romanMap.begin()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= iter-&gt;first) &#123;</span><br><span class="line">                res += iter-&gt;second;</span><br><span class="line">                num -= iter-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                -- iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>11-盛最多水的容器</title>
    <url>/2019/10/28/LeetCode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">58.84%</td>
<td align="center">array / two-pointers</td>
<td align="center">bloomberg</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定 $n$ 个非负整数 $a1，a2，…，an$，每个数代表坐标中的一个点 $(i, ai)$ 。在坐标内画 $n$ 条垂直线，垂直线 $i$ 的两个端点分别为 $(i, ai)$ 和 $(i, 0)$。找出其中的两条线，使得它们与 $x$ 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明</strong>：你不能倾斜容器，且 $n$ 的值至少为 2。</p>
<p><img src="/2019/10/28/LeetCode/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/11.jpg" alt="1"></p>
<p>图中垂直线代表输入数组 <code>[1,8,6,2,5,4,8,3,7]</code>。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <strong>49</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：双指针法"><a href="#2-1-解法一：双指针法" class="headerlink" title="2.1 解法一：双指针法"></a>2.1 解法一：双指针法</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/" target="_blank" rel="noopener">Krahets</a></p>
</blockquote>
<ol>
<li>指针 $l$，$r$ 分别指向最左边和最右边的木板，根据规则移动两个指针。获取每次移动之后的容器的大小，最后得到一个最大值。</li>
<li>由题意可知，$S = 底\times高 = (r - l) \times min(h[l], h[r])$，面积是由两个木板中的短板决定的。</li>
<li>无论我们移动哪一侧的木板，底 $(r - l)$ 都会减1。<ol>
<li>如果我们选择<strong>短板</strong>一侧的指针向内移一格，那么容器的宽 $min(h[l], h[r])$ <strong>可能变小也可能变大</strong>。</li>
<li>如果我们选择<strong>长板</strong>一侧的指针向内移一格，那么容器的宽 $min(h[l], h[r])$ <strong>可能不变也可能变小</strong>。</li>
</ol>
</li>
<li>所以，我们可以推断出，只有向内移动<strong>短板</strong>一侧的指针， $S$ <strong>才可能会变大</strong>（虽然也可能变小）。但是向内移动<strong>长板</strong>一侧的指针，$S$ <strong>一定不会变大</strong>。</li>
</ol>
<blockquote>
<p>执行用时: 16 ms, 在所有 cpp 提交中击败了95.90%的用户<br>内存消耗: 9.8 MB, 在所有 cpp 提交中击败了75.70%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right])</span><br><span class="line">                maxS = max(maxS, (right - left) * height[left ++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                maxS = max(maxS, (right - left) * height[right --]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>two-pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>10-正则表达式匹配</title>
    <url>/2019/10/27/LeetCode/10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Hard</td>
<td align="center">25.22%</td>
<td align="center">string / dynamic-programming / backtracking</td>
<td align="center">airbnb / facebook / google / twitter / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">'.'</span> 匹配任意单个字符</span><br><span class="line"><span class="string">'*'</span> 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>

<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 s的，而不是部分字符串。</p>
<p><strong>说明:</strong></p>
<ul>
<li>s 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li>p 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: <span class="string">"a"</span> 无法匹配 <span class="string">"aa"</span> 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="string">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"ab"</span></span><br><span class="line">p = <span class="string">".*"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: <span class="string">".*"</span> 表示可匹配零个或多个（<span class="string">'*'</span>）任意字符（<span class="string">'.'</span>）。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"c*a*b"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 表示零个或多个，这里 <span class="string">'c'</span> 为 <span class="number">0</span> 个, <span class="string">'a'</span> 被重复一次。因此可以匹配字符串 <span class="string">"aab"</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入:</span><br><span class="line">s = <span class="string">"mississippi"</span></span><br><span class="line">p = <span class="string">"mis*is*p*."</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：递归法"><a href="#2-1-解法一：递归法" class="headerlink" title="2.1 解法一：递归法"></a>2.1 解法一：递归法</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/di-gui-dong-tai-gui-hua-by-joy-teng/" target="_blank" rel="noopener">Joy</a></p>
</blockquote>
<ol>
<li><p>p为空。s为空，则返回true；s不为空，则返回false。</p>
</li>
<li><p>当p的第二个元素是 <code>*</code> 时，<strong>有两种情况，满足一种就可以（即 <code>||</code> ）</strong>：</p>
<ol>
<li><strong>剔除p中前两个元素，再来判断是否匹配。</strong><br> 例如：<code>s = &quot;aab&quot;</code>, <code>p = &quot;c*a*b&quot;</code>。其中 <code>c*</code> 可以是0个c，所以可以无视掉。<br> 直接判断<code>s = &quot;aab&quot;</code> 和 <code>p = &quot;a*b&quot;</code>是否匹配。  </li>
<li><strong>当 <code>s[0] == p[0] || p[0] == &#39;.&#39;</code> 时，剔除s中第一个元素，再来判断是否匹配。</strong><br> 例如：<code>s = &quot;aab&quot;</code>, <code>p = &quot;a*b&quot;</code>。<code>a*</code>可以匹配0~多个，<code>s[0] = &#39;a&#39;</code>被匹配，可以删除。接下来比较<code>s = &quot;ab&quot;</code> 和 <code>p = &quot;a*b&quot;</code>是否匹配。</li>
</ol>
</li>
<li><p><strong>如果第二个元素不是 <code>*</code>，那就只能是 <code>a-z</code> 或者 <code>&#39;.&#39;</code> 了。</strong><br>当第一个元素两两匹配时，我们就可以删除掉这俩元素了，因为没有 <code>*</code>的情况下，<code>a-z</code> 和 <code>&#39;.&#39;</code>只能匹配一次。<br>例如：<code>s = &quot;aab&quot;</code>, <code>p = &quot;.a*b&quot;</code>。因为 <code>p[1] = &#39;a&#39;</code>, <code>p[0] = &#39;.&#39;, s[0] = &#39;a&#39;</code>，两者匹配。所以剔除掉首元素，接下来判断<code>s = &quot;ab&quot;</code>, <code>p = &quot;a*b&quot;</code>是否匹配。</p>
</li>
</ol>
<blockquote>
<p>执行用时: 300 ms, 在所有 cpp 提交中击败了29.78%的用户<br>内存消耗: 15.5 MB, 在所有 cpp 提交中击败了14.56%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.empty())</span><br><span class="line">            <span class="keyword">return</span> s.empty();</span><br><span class="line">        <span class="keyword">if</span> (p.size() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：动态规划"><a href="#2-2-解法二：动态规划" class="headerlink" title="2.2 解法二：动态规划"></a>2.2 解法二：动态规划</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/" target="_blank" rel="noopener">乔碧萝殿下❤</a>，<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/zheng-ze-biao-da-shi-pi-pei-dong-tai-gui-hua-by-jy/" target="_blank" rel="noopener">Krahets</a></p>
</blockquote>
<p><strong>dp数组的样子:</strong> <code>s=&quot;abb&quot;,p=&quot;ab*c*&quot;</code>，方便大家理解。<br>为什么加 <code>&#39;#&#39;</code> 见步骤5。<br><code>1</code> 表示 <code>true</code>，<code>0</code> 表示 <code>false</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta"># a b * c *</span></span><br><span class="line"># <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">a <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>建立二维数组 <code>dp</code>，<code>dp[i][j]</code> 表示 <code>s</code> 的前 <code>i</code> 个元素和 <code>p</code> 的前 <code>j</code> 个元素是否匹配。</p>
</li>
<li><p>首先分析最简单的情况：<code>s[i] == p[j]</code>。此时若s的前<code>i-1</code>个元素和p的前<code>j-1</code>个元素相匹配，那么s的前<code>i</code>个元素和p的前<code>j</code>个元素也必相匹配。即此时的状态转移方程为: <code>dp[i][j] = dp[i - 1][j - 1]</code>。</p>
</li>
<li><p>第二种情况，当 <code>p[j] == &#39;.&#39;</code> 时，和2中情况相同，状态转移方程仍为：<code>dp[i][j] = dp[i - 1][j - 1]</code>。</p>
</li>
<li><p>第三种比较复杂的情况，当 <code>p[j] == &#39;*&#39;</code>时。此时我们必须要考虑 <code>&#39;*&#39;</code> 之前的元素，分为以下两种情况：  </p>
<ol>
<li><strong><code>s[i] != p[j - 1]</code>：<code>dp[i][j] = dp[i][j - 2]</code></strong>，此时表示 <code>*</code> 前面的字母根本和 <code>s[i]</code> 中字母不相同。<br>例如： <code>s = &quot;abb&quot;, p = &quot;ab*c*&quot;</code>，对于p中第二个 <code>*</code> 来说，其前面的字母<code>c</code>满足这种情况，<code>c*</code>相当于匹配了0次c，相当于直接剔除 <code>c*</code>，是否匹配取决于<code>s = &quot;abb&quot;, p = &quot;ab*&quot;</code>。</li>
<li><strong><code>s[i] == p[j - 1] || p[j] == &#39;.&#39;</code></strong>，此时表示匹配上了，但是不知道匹配了几次。<ul>
<li><strong>匹配多次： <code>dp[i][j] = dp[i-1][j]</code></strong><br>例如：<code>s = &quot;abbb&quot;, p = &quot;ab*&quot;</code>，此时代表匹配了<code>3</code>次<code>b</code>。<br>和<code>s = &quot;abb&quot;, p = &quot;ab*</code>的匹配状态相同，继而又和<code>s = &quot;ab&quot;, p = &quot;ab*</code>的匹配状态相同。</li>
<li><strong>匹配一次：<code>dp[i][j] = dp[i][j - 1]</code></strong><br>例如：<code>s = &quot;ab&quot;, p = &quot;ab*&quot;</code>。若<code>s = &quot;ab&quot;, p = &quot;ab</code>匹配，那么它肯定也匹配。</li>
<li><strong>匹配零次：<code>dp[i][j] = dp[i][j - 2]</code></strong><br>例如：<code>s = &quot;ab&quot;, p = &quot;abc*&quot;</code>，对于<code>c</code>来说匹配了0次，那么<code>c*</code>就没有什么意义，也就可以剔除掉<code>c*</code>。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>考虑边界值的问题。</strong><br>因为如果当 <code>i=0</code> 时，<code>dp[i][j] = dp[i - 1][j - 1]</code>就会数组越界。这里我们的处理办法是行和列各增加一个维度，即: <code>dp[m + 1][n + 1]</code>。<br>这时读者可能会有疑问，还有 <code>dp[j - 2]</code> 的情况呢，你这里只增加了 <code>1</code> ，<code>j = 0</code> 时仍然会数组越界啊？实际上我们观察步骤4，<code>dp[j - 2]</code>只出现在 <code>p[j] == &#39;*&#39;</code> 的情况下，而 <code>*</code> 不可能是 <code>p</code> 的首元素的。</p>
</li>
<li><p><strong>数组 <code>dp</code> 的初始化。</strong><br>我们只需要对<strong>第一列</strong>和<strong>第一行</strong>进行初始化即可，其他地方均赋值为 <code>false</code>。我们的行和列都比原来增加了1，我们可以假设在 <code>s</code> 和 <code>p</code> 前面都加了一个字符<code>&#39;#&#39;</code>。<br>例如 <code>s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;</code>，那么dp的第一行就是代表 <code>s[0]</code> 和 <code>p</code> 的前 <code>j</code> 个元素是否匹配。此时 <code>dp[0][0] = true</code>，因为 <code>s[0] = p[0] = &#39;#&#39;</code>。  </p>
<ol>
<li><p><strong>第一行的初始化：</strong><br>因为我们的 <code>p</code> 始终和 <code>&#39;#&#39;</code>进行匹配判断，并且 <code>p[0] = &#39;#&#39;</code> ，那么后面只要出现了 <code>&#39;*&#39;</code>，那它肯定匹配了0次；单独出现 <code>a-z</code> 或者 <code>&#39;.&#39;</code> 肯定无法与 <code>s[0] = &#39;#&#39;</code> 匹配，因为 <code>p</code> 首元素就是 <code>#</code>。</p>
</li>
<li><p><strong>第一列的初始化：</strong><br>例如 <code>s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;</code>，那么dp的第一行就是 <code>p[0]</code> 和 <code>s</code> 的前 <code>i</code> 个元素是否匹配。我们可以看出，只有 <code>p[0] = s[0] = &#39;#&#39;</code> 是匹配的，其他地方都不匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#&#39;</code> 匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#a&#39;</code> 不匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#ab&#39;</code> 也不匹配。<br><code>&#39;#&#39;</code> 和 <code>&#39;#abb&#39;</code> 也不匹配。</p>
<p>下面举两个例子方便大家理解初始化规则，只需看第一列和第一行即可。<br><strong>初始化例子1：</strong><code>s = &quot;#abb&quot;, p = &quot;#ab*c*&quot;</code>时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta"># a b * c *</span></span><br><span class="line"># <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">a <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化例子2：</strong><code>s = &quot;#abb&quot;, p = &quot;#a*b*c*&quot;</code>时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="meta"># a * b * c *</span></span><br><span class="line"># <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">a <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">b <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了98.13%的用户<br>内存消耗: 8.4 MB, 在所有 cpp 提交中击败了91.48%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size();</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line">        <span class="keyword">bool</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : dp)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : i)</span><br><span class="line">                j = <span class="literal">false</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>)</span><br><span class="line">                dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p[j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i] != p[j - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">'.'</span>)</span><br><span class="line">                        dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                         dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] || dp[i + <span class="number">1</span>][j] || dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-解法三：有限状态自动机"><a href="#2-3-解法三：有限状态自动机" class="headerlink" title="2.3 解法三：有限状态自动机"></a>2.3 解法三：有限状态自动机</h3><p>没学过，日后再更。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>dynamic-programming</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>9-回文数</title>
    <url>/2019/10/26/LeetCode/9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">56.68%</td>
<td align="center">math</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 从左向右读, 为 <span class="number">-121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 从右向左读, 为 <span class="number">01</span> 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong><br>你能不将整数转为字符串来解决这个问题吗？</p>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/palindrome-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li><p>我们将该数字翻转得到的数字和原数字相等，此时它就是回文数。</p>
</li>
<li><p>考虑翻转后会溢出的问题，我们设置翻转后的数字设置为long类型即可。</p>
</li>
<li><p>当然2中方法并不适用所有情况，我们可以使用以下方法判断.</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (reverse &gt; INT_MAX / <span class="number">10</span> || (reverse &gt;= INT_MAX &amp;&amp; (temp % <span class="number">10</span>) &gt; <span class="number">7</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>执行用时: 4 ms, 在所有 cpp 提交中击败了99.52%的用户<br>内存消耗: 7.9 MB, 在所有 cpp 提交中击败了95.45%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">long</span> reverse = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            reverse = reverse * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (reverse == x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><ol>
<li>我们没有必要将整个数字翻转，只需要将后一半数字反转，再与前一半的数字相比较即可。</li>
<li>例如1234321，后一半的数是321，翻转得到123，前一半的数是123，两者相等，则是回文数。  </li>
</ol>
<p><strong>需要注意奇回文数和偶回文数的处理。</strong></p>
<blockquote>
<p>执行用时: 16 ms, 在所有 cpp 提交中击败了75.83%的用户<br>内存消耗: 8.1 MB, 在所有 cpp 提交中击败了82.64%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            temp = temp /<span class="number">10</span>;</span><br><span class="line">            digit ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        left = x / <span class="built_in">pow</span>(<span class="number">10</span>, (digit + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; digit / <span class="number">2</span>; ++ i) &#123;</span><br><span class="line">            right = right * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left == right ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>8-字符串转换整数 (atoi)</title>
    <url>/2019/10/24/LeetCode/8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">18.57%</td>
<td align="center">math / string</td>
<td align="center">amazon / bloomberg / microsoft / uber</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>请你来实现一个<code>atoi</code>函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"42"</span></span><br><span class="line">输出: <span class="number">42</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"   -42"</span></span><br><span class="line">输出: <span class="number">-42</span></span><br><span class="line">解释: 第一个非空白字符为 <span class="string">'-'</span>, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 <span class="number">-42</span> 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"4193 with words"</span></span><br><span class="line">输出: <span class="number">4193</span></span><br><span class="line">解释: 转换截止于数字 <span class="string">'3'</span> ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>:</span><br><span class="line">输入: <span class="string">"words and 987"</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 第一个非空字符是 <span class="string">'w'</span>, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>:</span><br><span class="line">输入: <span class="string">"-91283472332"</span></span><br><span class="line">输出: <span class="number">-2147483648</span></span><br><span class="line">解释: 数字 <span class="string">"-91283472332"</span> 超过 <span class="number">32</span> 位有符号整数范围。</span><br><span class="line">     因此返回 INT_MIN (−<span class="number">231</span>) 。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><ol>
<li>先找出第一个非空字符的下标 <code>noSpaceIndex</code></li>
<li>判断正负性 <code>negative</code>，找出数字开始的下标 <code>startIndex</code></li>
<li>计算出当前下标的数字 <code>curDigit</code>，判断是否溢出</li>
<li>horner法则求出和。</li>
</ol>
<p><strong>需要注意的是溢出的处理办法：</strong><br><code>if (res &gt; INT_MAX/10 || (res &gt;= INT_MAX/10 &amp;&amp; curDigit &gt; 7))</code></p>
<ol>
<li>首先我们知道 <code>INT_MAX = 2^31 - 1 = 2147483647，INT_MIN = -2^31 = -2147483648;</code>，<code>res</code>是结果的绝对值。  </li>
<li>我们要理解为什么正负溢出对的处理方式相同。<br>举四个例子即可：2147483647，2147483648，-2147483647，-2147483648。<br>其中只有 <code>2147483648</code> 和 <code>-2147483648</code> 会判断成溢出，实际上 <code>-2147483648</code> 是没有溢出的，但是我们最终得到的结果都是<code>INT_MIN = -2147483648</code>，所以并无大碍。</li>
</ol>
<blockquote>
<p>执行用时 :4 ms, 在所有 cpp 提交中击败了93.61%的用户<br>内存消耗 :8.3 MB, 在所有 cpp 提交中击败了93.80%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curDigit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (str[startIndex] == <span class="string">' '</span>)</span><br><span class="line">            startIndex ++;</span><br><span class="line">        <span class="keyword">if</span> (str[startIndex] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            negative = <span class="literal">true</span>;</span><br><span class="line">            startIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[startIndex] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            startIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = startIndex;i &lt; str.size() &amp;&amp; <span class="built_in">isdigit</span>(str[i]); ++ i) &#123;</span><br><span class="line">            curDigit = str[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX/<span class="number">10</span> || (res &gt;= INT_MAX/<span class="number">10</span> &amp;&amp; curDigit &gt; <span class="number">7</span>))</span><br><span class="line">                <span class="keyword">return</span> (negative ? INT_MIN : INT_MAX);</span><br><span class="line">            res = res * <span class="number">10</span> + curDigit;</span><br><span class="line">            <span class="comment">// res = res * 10 - 48 + static_cast&lt;int&gt;(str[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (negative ? -res : res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>7-整数反转</title>
    <url>/2019/10/22/LeetCode/7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">33.23%</td>
<td align="center">math</td>
<td align="center">apple / bloomberg</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">-123</span></span><br><span class="line">输出: <span class="number">-321</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong><br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>利用求余，求出<em>从后往前</em>每一位的值。<br>再利用horner法则(多项式求值)，令X=10求出翻转后的值。</p>
<blockquote>
<p>执行用时: 0 ms, 在所有 cpp 提交中击败了100%的用户<br>内存消耗: 8 MB, 在所有 cpp 提交中击败了93.37%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> remainder;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            remainder = x % <span class="number">10</span>;</span><br><span class="line">            x = (x - remainder) / <span class="number">10</span>;</span><br><span class="line">            res = <span class="number">10</span> * res + remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; INT_MIN || res &gt; INT_MAX)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>6-Z字形变换</title>
    <url>/2019/10/21/LeetCode/6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">45.35%</td>
<td align="center">string</td>
<td align="center">Unknown</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行<strong>Z</strong>字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：<br>string convert(string s, int numRows);</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: s = <span class="string">"LEETCODEISHIRING"</span>, numRows = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"LCIRETOESIIGEDHN"</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: s = <span class="string">"LEETCODEISHIRING"</span>, numRows = <span class="number">4</span></span><br><span class="line">输出: <span class="string">"LDREOEIIECIHNTSG"</span></span><br><span class="line">解释:</span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zigzag-conversion</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>按每行从左到右依次输出。<br>以示例2为例，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L     D      R</span><br><span class="line">E   O E    I I</span><br><span class="line">E C   I  H   N</span><br><span class="line">T     S      G</span><br><span class="line">对应的下标如下：</span><br><span class="line"><span class="number">0</span>     <span class="number">6</span>      <span class="number">12</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span> <span class="number">7</span>   <span class="number">11</span> <span class="number">13</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span>   <span class="number">8</span> <span class="number">10</span>   <span class="number">14</span></span><br><span class="line"><span class="number">3</span>     <span class="number">9</span>      <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>我们的任务是找出每一行的下标。  </p>
<ol>
<li>对于第一行和最后一行来说，它只有3个数，而其他行是它的二倍，有6个数。</li>
<li>我们以下标0-5为第一组，6-11为第二组，以此类推，每6个数一组，不足6个数的也算作一组。</li>
<li>6是怎么求的呢？<code>k = 2 * (numRows - 1) = 2*(4-1) = 6</code></li>
<li>一共有多少组呢？<code>loopNum = (n + k - 1) / k;(n为s的长度)</code>，注意：不足k个的也算作一组。</li>
<li>对于第一行和最后一行来说，初值为i（<code>start1 = i</code>），我们只需要每次循环加上k即可。</li>
<li>对于其他行，我们每组有两个数。前一个数和步骤5中一样，初值为i（<code>start1 = i</code>）；第二个数的初值是关键，<code>start2 = start1 + (numRows-(i+1))*2</code>；每次循环都加上k即可，循环总次数为numRows。</li>
</ol>
<blockquote>
<p>执行用时 :8 ms, 在所有 cpp 提交中击败了97.82%的用户<br>内存消耗 :10.3 MB, 在所有 cpp 提交中击败了88.53%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span> * (numRows - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> loopNum = (n + k - <span class="number">1</span>) / k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numRows; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> start1 = i;</span><br><span class="line">            <span class="keyword">int</span> start2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != (numRows <span class="number">-1</span>))</span><br><span class="line">                start2 = start1 + (numRows-(i+<span class="number">1</span>))*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; loopNum; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start1 &lt; n) &#123;</span><br><span class="line">                    str += s[start1];</span><br><span class="line">                    start1 += k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != (numRows <span class="number">-1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (start2 &lt; n) &#123;</span><br><span class="line">                        str += s[start2];</span><br><span class="line">                        start2 += k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (start1 &gt;= n &amp;&amp; start2 &gt;= n)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二"><a href="#2-2-解法二" class="headerlink" title="2.2 解法二"></a>2.2 解法二</h3><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/zigzag-conversion/comments/44833/" target="_blank" rel="noopener">麓山南路飞行员</a>  </p>
</blockquote>
<p>主要思想就是：一共有numRows行，找出每个字符所在的行数，依次添加到该行。<br>关键代码<code>int row = i % k &lt; numRows ? i % k : k - i % k;</code></p>
<p>以示例2为例，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">L     D      R</span><br><span class="line">E   O E    I I</span><br><span class="line">E C   I  H   N</span><br><span class="line">T     S      G</span><br><span class="line">对应的下标如下：    行数：</span><br><span class="line"><span class="number">0</span>     <span class="number">6</span>      <span class="number">12</span>     <span class="number">0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5</span> <span class="number">7</span>   <span class="number">11</span> <span class="number">13</span>     <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span>   <span class="number">8</span> <span class="number">10</span>   <span class="number">14</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     <span class="number">9</span>      <span class="number">15</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>易知<code>k = 6, numsRows = 4</code>，我们以下标0-5为例。第一种情况是下标0-3，第二种情况是下标4-5，这两种情况区分的标志是<code>i % k &lt; numRows</code>。</p>
<p>很容易知道第一种情况的行数为<code>i % k</code>；第二种情况，对于5来说，<code>row = 1 = 6 - 5</code>；对于11来说，<code>row = 1 = 6 - 11...</code>，11怎么才能变成5呢，当然是对6取余啦。所以第二种情况行数为<code>k - i % k</code>。</p>
<blockquote>
<p>执行用时 :20 ms, 在所有 cpp 提交中击败了58.47%的用户<br>内存消耗 :12.7 MB, 在所有 cpp 提交中击败了78.71%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span> * (numRows - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res(numRows);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> row = i % k &lt; numRows ? i % k : k - i % k;</span><br><span class="line">            res[row] += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : res)</span><br><span class="line">            str += i;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>5-最长回文子串</title>
    <url>/2019/10/21/LeetCode/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Hard</td>
<td align="center">36.29%</td>
<td align="center">string / dynamic-programming</td>
<td align="center">amazon / bloomberg / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串<code>s</code>，找到<code>s</code>中最长的回文子串。你可以假设<code>s</code>的最大长度为 1000。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/" target="_blank" rel="noopener">windliang</a></p>
</blockquote>
<h3 id="2-1-解法一：最长共同子串-动态规划法"><a href="#2-1-解法一：最长共同子串-动态规划法" class="headerlink" title="2.1 解法一：最长共同子串(动态规划法)"></a>2.1 解法一：最长共同子串(动态规划法)</h3><h4 id="2-1-1-为什么用可以最长共同子串？"><a href="#2-1-1-为什么用可以最长共同子串？" class="headerlink" title="2.1.1 为什么用可以最长共同子串？"></a>2.1.1 为什么用可以最长共同子串？</h4><ol>
<li>假设s2是s1的逆序字符串。  </li>
<li>若s1中有回文子串，则s1和s2中一定有相同的该子串。<br>例如：<code>s1 = &quot;afbcbfae&quot;</code>, 则<code>s2 = &quot;eafbcbfa&quot;</code>,那么<code>fbcbf</code>就是它俩的共同最长子串，也是s1的最长回文子串。  </li>
<li>不过需要注意一些特例：<code>s1 = &quot;abc123cba&quot;</code>, 则<code>s2 = &quot;abc321cba&quot;</code>;我们发现它俩有两个共同子串<code>abc</code>和<code>bca</code>，但是这两个都不是回文子串。</li>
<li>对于3中的情况，我们需要加一步判断来解决该问题。即s1中<code>abc</code>和s2中<code>abc</code>他们的下标是否对应。对于s2中子串<code>abc</code>来讲，其中<code>a</code>在s1逆置之前的下标应该是8(即:<code>s1.size() - 1</code>)。通用的说法就是，当<code>s2[j] == s[i]</code>时，设s2中的该字符c在s2中的下标为j，它在逆置之前，在s1中的下标为jBefore，那么<code>jBefore = s1.size() - 1 - j</code>，此时s1中下标为i，d[i][j]是该回文串的长度，那么就必须满足<code>i = jBefore + d[i][j] - 1</code>。那么我们可以推断出，当<code>s1[i] == s[j]</code>时，只要满足该条件，那么就是回文子串。</li>
</ol>
<h4 id="2-1-2-动态规划法"><a href="#2-1-2-动态规划法" class="headerlink" title="2.1.2 动态规划法"></a>2.1.2 动态规划法</h4><ol>
<li><p>我们设置一个二维<code>n*n</code>数组<code>d</code>表示两个字符串每个字符相等的关系。（字符串长度为n）</p>
</li>
<li><p>若<code>s1[i] == s[j]</code>，则<code>d[i][j] = d[i-1][j-1] + 1</code>。当<code>i=0</code>或者<code>j=0</code>时，上述公式会越界。所以我们直接令<code>d[i][j] = 1</code>。</p>
</li>
<li><p>例如<code>s1 = &quot;afbcbfae&quot;</code>，那么d为</p>
<table>
<thead>
<tr>
<th align="center">s1\s2</th>
<th align="center">e</th>
<th align="center">a</th>
<th align="center">f</th>
<th align="center">b</th>
<th align="center">c</th>
<th align="center">b</th>
<th align="center">f</th>
<th align="center">a</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>a</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>f</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>c</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">5</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>f</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">6</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>a</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center"><strong>e</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p> 我们只需记录下d中最大数对应的下标即可。<br> 我们观察到<code>d[2][3]=3</code>(行为i，列为j)，此时<code>j = 3, jBefroe = 8-1-3 = 4; i = 2而jBefore + d[i][j] - 1 = 4+3-1 = 6</code>,所以此时不是回文子串。<br> 再看<code>d[6][7]=7</code>，此时<code>j = 7, jBefroe = 8-1-7 = 0; i = 6而jBefore + d[i][j] - 1 = 0+7-1 = 6</code>,所以此时是回文子串。  </p>
</li>
<li><p>对于<code>s1 = &quot;abc123cba&quot;</code>来说，d为</p>
<table>
<thead>
<tr>
<th align="center">s1\s2</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">c</th>
<th align="center">b</th>
<th align="center">a</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>a</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>c</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>1</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>2</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>3</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>c</strong></td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>b</strong></td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><strong>a</strong></td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p> 我们观察到<code>d[2][2]=3</code>(行为i，列为j)，此时<code>j = 2, jBefroe = 9-1-2 = 6; i=2而jBefore + d[i][j] - 1 = 6+3-1 = 7</code>,所以此时不是回文子串。<br> 再看<code>d[8][8]=3</code>，此时<code>j = 8, jBefroe = 9-1-8 = 0; i = 8而jBefore + d[i][j] - 1 = 0+3-1 = 2</code>,所以此时也不是回文子串。</p>
</li>
</ol>
<blockquote>
<p>执行用时 :320 ms, 在所有 cpp 提交中击败了22.88%的用户<br>内存消耗 :13.3 MB, 在所有 cpp 提交中击败了47.92%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n^2),空间复杂度O(n^2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> s1 = s;</span><br><span class="line">        reverse(s1.begin(), s1.end());</span><br><span class="line">        <span class="keyword">int</span> d[n][n];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s1[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                        d[i][j] = d[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        d[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    d[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d[i][j] &gt; maxLen) &#123;</span><br><span class="line">                    <span class="keyword">int</span> jBeforeReverse = n - <span class="number">1</span> - j;</span><br><span class="line">                    <span class="keyword">if</span> (jBeforeReverse + d[i][j] - <span class="number">1</span> == i) &#123;</span><br><span class="line">                        maxLen = d[i][j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxEnd - maxLen + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2解法二：最长共同子串-改进"><a href="#2-2解法二：最长共同子串-改进" class="headerlink" title="2.2解法二：最长共同子串(改进)"></a>2.2解法二：最长共同子串(改进)</h3><p>在解法一中我们使用了二维数组，实际上使用一维数组也可以解决。<br>解法一中，当i=0时，我们计算出j=1…n的值，i=1时，我们又根据前一列计算出这一列的j=1…n的值。实际上，我们计算某一列的值时，只需要使用它的左上角的元素（<code>d[i][j] = d[i-1][j-1] + 1</code>），即前一列的信息。  </p>
<p>我们规定若<code>s1[i] == s[j]</code>，则<code>d[j] = d[j-1] + 1</code>。当<code>j=0</code>时，上述公式会越界。所以我们直接令<code>d[j] = 1</code>。  </p>
<p><strong>但是我们必须要注意到如下的问题：</strong><br>假设<code>i=0</code>时，我们已经求出一组d的值，当<code>i=1</code>时，如果我们j从0——n来循环，那么<br>比如求出<code>d[1] = d[0] + 1</code>（此时<code>d[0]</code>还是上一次的信息）。我们再求<code>d[2] = d[1] + 1</code>，但这时<code>d[1]</code>的值已经被修改了，不是<code>i=0</code>时的值了。<br>所以我们的j必须从n——0来循环。</p>
<blockquote>
<p>执行用时 :268 ms, 在所有 cpp 提交中击败了28.68%的用户<br>内存消耗 :8.7 MB, 在所有 cpp 提交中击败了96.28%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> s1 = s;</span><br><span class="line">        reverse(s1.begin(), s1.end());</span><br><span class="line">        <span class="keyword">int</span> d[n];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; -- j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s1[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                        d[j] = d[j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        d[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    d[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d[j] &gt; maxLen) &#123;</span><br><span class="line">                    <span class="keyword">int</span> jBeforeReverse = n - <span class="number">1</span> - j;</span><br><span class="line">                    <span class="keyword">if</span> (jBeforeReverse + d[j] - <span class="number">1</span> == i) &#123;</span><br><span class="line">                        maxLen = d[j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(maxEnd - maxLen + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-解法三：中心拓展法"><a href="#2-3-解法三：中心拓展法" class="headerlink" title="2.3 解法三：中心拓展法"></a>2.3 解法三：中心拓展法</h3><p>核心思想就是指定一个中心元素，分别比较两侧的元素是否相等。<br>当然我们会遇到奇数个或偶数个的回文子串。<br>对于奇数个的，我们指定一个中心元素；对于偶数个的，我们指定两个中心元素；然后向两侧拓展比较。</p>
<blockquote>
<p>执行用时 :20 ms, 在所有 cpp 提交中击败了90.24%的用户<br>内存消耗 :8.7 MB, 在所有 cpp 提交中击败了96.28%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(n^2),空间复杂度O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expandFromCenter(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expandFromCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">                maxLen = len;</span><br><span class="line">                start = i - (len - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandFromCenter</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            left --;</span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次到循环最后，left多减了1，right多加了1</span></span><br><span class="line">        <span class="keyword">return</span> (right - left - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-解法四：Manacher’s-Algorithm-马拉车算法"><a href="#2-4-解法四：Manacher’s-Algorithm-马拉车算法" class="headerlink" title="2.4 解法四：Manacher’s Algorithm 马拉车算法"></a>2.4 解法四：Manacher’s Algorithm 马拉车算法</h3><p>好复杂，日后再更。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>dynamic-programming</tag>
      </tags>
  </entry>
  <entry>
    <title>4-寻找两个有序数组的中位数</title>
    <url>/2019/10/19/LeetCode/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Hard</td>
<td align="center">36.29%</td>
<td align="center">array / binary-search / divide-and-conquer</td>
<td align="center">adobe / apple / dropbox / google / microsoft / yahoo / zenefits</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。<br>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 <strong>O(log(m + n))</strong>。<br>你可以假设 nums1 和 nums2 不会同时为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:  </span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">nums2 = [<span class="number">2</span>]  </span><br><span class="line">则中位数是 <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:  </span><br><span class="line">nums1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">nums2 = [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">则中位数是 (<span class="number">2</span> + <span class="number">3</span>)/<span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一：归并排序"><a href="#2-1-解法一：归并排序" class="headerlink" title="2.1 解法一：归并排序"></a>2.1 解法一：归并排序</h3><p>将两个数组进行归并排序，从小到大依次存入vector中。取中位数即可。</p>
<blockquote>
<p>执行用时: 24 ms, 在所有 cpp 提交中击败了76.59%的用户<br>内存消耗: 11.3 MB, 在所有 cpp 提交中击败了72.07%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i1 != nums1.size() &amp;&amp; i2 != nums2.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i1] &lt;= nums2[i2]) &#123;</span><br><span class="line">                v.push_back(nums1[i1]);</span><br><span class="line">                ++ i1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v.push_back(nums2[i2]);</span><br><span class="line">                ++ i2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i1 != nums1.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i1; i1 &lt; nums1.size(); ++ i1)</span><br><span class="line">                v.push_back(nums1[i1]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i2; i2 &lt; nums2.size(); ++ i2)</span><br><span class="line">                v.push_back(nums2[i2]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((nums1.size() + nums2.size())%<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> v[(nums1.size() + nums2.size())/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (v[(nums1.size() + nums2.size())/<span class="number">2</span>] + v[(nums1.size() + nums2.size())/<span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-解法二：递归二分法"><a href="#2-2-解法二：递归二分法" class="headerlink" title="2.2 解法二：递归二分法"></a>2.2 解法二：递归二分法</h3><ol>
<li>题目要求复杂度为O(log(m+n))，所以肯定要使用二分法。</li>
<li>同时我们可以将题目转化为求第k个最小数，即<code>k=(m+n)/2</code>；</li>
<li>对两个序列的第<code>k/2</code>个值进行比较，若<code>nums1[k] &gt; nums2[k]</code>，则nums2的前<code>k/2</code>个数中肯定没有我们要求的第k个最小数。我们将前nums2中前k/2个数剔除。</li>
<li>对新序列的nums1和nums2继续进行求第<code>k1(此时k1=k-k/2)</code>个最小数。</li>
<li>当然我们会遇到一些特殊情况，比如某序列太短，例如<code>(nums1.size() &lt; nums2.size())</code>，此时肯定是nums1可能会出现没有第k/2个数（nums2不会出现这种情况），此时替换为该序列的最后一个值即可。为了简化代码，如果<code>(nums1.size() &gt; nums2.size())</code>，我们就递归函数getKthElem重新传参，将参数调换（即nums1 &lt;-&gt; nums2等）。</li>
<li>由此产生的另外一种需要考虑的问题是，<strong>步骤4中的<code>k1=k-k/2</code>是否完全正确？我们每次剔除的元素该不该是k/2个？</strong> 当然不一定，因为有的序列可能没有那么多元素，这时我们需要令<code>k=k-我们剔除的数</code>，即：<code>k=k-min(k/2,len)</code>。在代码中我们不能将 <strong>min函数</strong> 作为一个参数，因为我们定义了<code>int i = start1 + min(k / 2, len1) - 1</code>, 在实际代码中我们使用<code>(j - start2 + 1)</code>来替代它。</li>
<li>那么问题来了，<strong>6中这种替换是正确的吗？</strong> 其实这种替换是无妨的，因为们剔除的元素始终小于k/2个，当<code>len &lt; k/2</code>时，剔除了len个元素，我们此时只是不是严格的二分了。我们每次少剔除几个元素在逻辑上是没有问题的（当然多的话就会有问题），<strong>因为在k/2前的这几个元素肯定不是我们要找的第k个最小数</strong>。</li>
<li><strong>递归函数什么时候结束呢？</strong> 两种情况：一是某个序列的长度变为了0，那么我们只需在另一个序列中找第k个最小数即可；二是<code>k=1</code>时，此时找的是两个序列的第1个最小值，那么就是两个序列第一个元素较小的那个。</li>
</ol>
<blockquote>
<p>执行用时: 8 ms, 在所有 cpp 提交中击败了99.98%的用户<br>内存消耗: 9.7 MB, 在所有 cpp 提交中击败了86.47%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> k = (m + n) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (getKthElem(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, k) + getKthElem(nums1, <span class="number">0</span>, m - <span class="number">1</span>, nums2, <span class="number">0</span>, n - <span class="number">1</span>, k + <span class="number">1</span>)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElem</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2)</span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> min(nums1[start1], nums2[start2]);</span><br><span class="line">        <span class="keyword">int</span> i = start1 + min(k / <span class="number">2</span>, len1) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + min(k / <span class="number">2</span>, len2) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j])</span><br><span class="line">            <span class="comment">// 注意：(j - start2 + 1) = min(k / 2, len1)</span></span><br><span class="line">            <span class="comment">// 但是我们不能将min函数作为参数。</span></span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getKthElem(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>divide-and-conquer</tag>
        <tag>binary-search</tag>
      </tags>
  </entry>
  <entry>
    <title>3-无重复字符的最长子串</title>
    <url>/2019/10/17/LeetCode/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Medium</td>
<td align="center">36.10%</td>
<td align="center">hash-table / two-pointers / string / sliding-window</td>
<td align="center">adobe / amazon / bloomberg / yelp</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个字符串，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是**子串**的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><h4 id="2-1-1-滑动窗口法："><a href="#2-1-1-滑动窗口法：" class="headerlink" title="2.1.1 滑动窗口法："></a>2.1.1 <strong>滑动窗口法：</strong></h4><p>我们依次将每个字符及其下标（从1开始，最后会解释为什么从1）存进map中。当遇到某个重复的字符 <code>ch</code> 时<strong>并且</strong> <code>m[s[i]] &gt;= left</code>，就把 <code>left</code> 设置为前一个与他重复的 <code>ch</code> 的value值加1，此时 <code>(i-left+1)</code>（i从0开始）就是上一个无重复子串的长度。<br>例如：<strong>jbpnbwwe</strong></p>
<ol>
<li><code>i=0, s[i]=&#39;j&#39;, left=1, m[&#39;j&#39;]=0</code> (因为m中没有‘j’),所以将 <code>m[&#39;j&#39;] = i+1 = 1</code>存入map。</li>
<li>同理 <code>&#39;b&#39;, &#39;p&#39;, &#39;n&#39;</code> 都是插入map中。</li>
<li>此时 <code>i=4, s[i]=&#39;b&#39;, left=1, m[&#39;b&#39;]=2 &gt; left</code> ; 此时无重复子串长度为4 <code>(&quot;jbpn&quot;)</code>, <code>left</code> 值变为 <code>&#39;b&#39;</code> 的下一位的下标值即5; 同时更新 <code>m[&#39;b&#39;]</code> 的值为5。</li>
<li>往后同理。</li>
</ol>
<h4 id="2-2-2-为什么-m-s-i-gt-left，而不是-m-s-i-gt-left"><a href="#2-2-2-为什么-m-s-i-gt-left，而不是-m-s-i-gt-left" class="headerlink" title="2.2.2 为什么 m[s[i]] &gt;= left，而不是 m[s[i]] &gt; left"></a>2.2.2 为什么 <code>m[s[i]] &gt;= left</code>，而不是 <code>m[s[i]] &gt; left</code></h4><p>考虑如果当前 <code>left</code> 所对应的字符就是下一次重复的字符。<br>极端情况例如 <code>&quot;abbbbb&quot;</code>。</p>
<h4 id="2-2-3-为什么-m-s-i-i-1-，而不直接等于-i？left为什么初值为1"><a href="#2-2-3-为什么-m-s-i-i-1-，而不直接等于-i？left为什么初值为1" class="headerlink" title="2.2.3 为什么 m[s[i]] = i + 1 ，而不直接等于 i？left为什么初值为1"></a>2.2.3 为什么 <code>m[s[i]] = i + 1</code> ，而不直接等于 <code>i</code>？<code>left</code>为什么初值为1</h4><p>考虑极端情况。<br>例如：只有一个字母 <code>a</code>（或者是无重复字符串 <code>&quot;abcd&quot;</code>）<br>假如 <code>left=0</code>，那么就会进入if语句中，<code>left</code> 会加1，而我们并没有重复的字符，<code>left</code> 不应该加1。<br>主要就是因为map中，如果没有元素c，那么 <code>m[c]</code> 会返回0。</p>
<blockquote>
<p>执行用时 :16 ms, 在所有 cpp 提交中击败了75.44%的用户<br>内存消耗 :10.8 MB, 在所有 cpp 提交中击败了79.63%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在不需要排序功能的情况下，建议使用unordered_map，它比map快。</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; s.size(); ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[s[i]] &gt;= left) &#123;</span><br><span class="line">                max = (max &gt; (i-left+<span class="number">1</span>) ? max : (i-left+<span class="number">1</span>));</span><br><span class="line">                left = m[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符s[i]对应的位置为i+1,因为map不存在该元素时会返回0；</span></span><br><span class="line">            m[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可能出现一种情况：整个字符串没有重复的，就需要如下代码。</span></span><br><span class="line">        max = (max &gt; (s.size()-left+<span class="number">1</span>) ? max : (s.size()-left+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>string</tag>
        <tag>hash-table</tag>
        <tag>two-pointers</tag>
        <tag>sliding-window</tag>
      </tags>
  </entry>
  <entry>
    <title>2-两数相加</title>
    <url>/2019/10/16/LeetCode/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">46.90%</td>
<td align="center">linked-list / math</td>
<td align="center">adobe / airbnb / amazon / bloomberg / microsoft</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入：(<span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span>) + (<span class="number">5</span> -&gt; <span class="number">6</span> -&gt; <span class="number">4</span>)</span><br><span class="line">输出：<span class="number">7</span> -&gt; <span class="number">0</span> -&gt; <span class="number">8</span></span><br><span class="line">原因：<span class="number">342</span> + <span class="number">465</span> = <span class="number">807</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/add-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>例如<br>(2 -&gt; 4 -&gt; 3) +<br>(5 -&gt; 6 -&gt; 4 -&gt; 2)</p>
<ol>
<li>新建一个链表h，用于存储每一步相加的结果。  </li>
<li>首先循环内的条件为 <code>l1 || l2</code> ，即 <code>l1</code> 或 <code>l2</code> 有一个不为空时。  </li>
<li>对于 <code>l1</code> 和 <code>l2</code>，如果没有到达尾部，则链表指向下一个（ <code>next</code>），并且 <code>sum</code> 加上其值；如果某链表到达尾部之后（即为NULL时），链表则不动，也不再加上该链表的值。  </li>
<li>将对应位置两个数相加，如果 <code>&gt;=10</code>，进位标志(carry)为 <code>true</code>。此时下一次循环的 <code>sum</code> 要额外加 <code>1</code>。</li>
<li>循环结束后，如果最后两个数字相加 <code>&gt;=10</code>（即carry==true），则还要增加一个节点，值为 <code>1</code>。</li>
</ol>
<p><strong>注意</strong>：我们并没有使用 <code>h</code> 的头结点，我们先是令其指向 <code>next</code> ，再赋值。主要是考虑最后一次循环，不这样的话会创建一个新的无用的节点。<br>最后我们释放掉无用的头结点，因为如果调用次数多会溢出。</p>
<blockquote>
<p>执行用时：28 ms, 在所有 cpp 提交中击败了91.26%的用户<br>内存消耗：10.3 MB, 在所有 cpp 提交中击败了84.73%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>); <span class="comment">//头结点，不保存任何信息</span></span><br><span class="line">        ListNode *h = head;</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        <span class="keyword">bool</span> carry = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                sum += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                sum += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (carry)</span><br><span class="line">                sum ++;</span><br><span class="line">            carry = (sum &gt;= <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry)</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放头结点（初始创建的val = -1 的节点），c++要手动释放，否则调用次数多会溢出</span></span><br><span class="line">        ListNode *ptrDelete = h;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> ptrDelete;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">        <span class="comment">// 参考https://leetcode-cn.com/u/chenlele/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title>1-两数之和</title>
    <url>/2019/10/15/LeetCode/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">Category</th>
<th align="center">Difficulty</th>
<th align="center">Pass rate</th>
<th align="center">Tags</th>
<th align="center">Companies</th>
</tr>
</thead>
<tbody><tr>
<td align="center">algorithms</td>
<td align="center">Easy</td>
<td align="center">46.90%</td>
<td align="center">array / hash-table</td>
<td align="center">adobe / airbnb / amazon / apple / bloomberg / dropbox / facebook /  linkedin / microsoft / uber / yahoo / yelp</td>
</tr>
</tbody></table>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1. 题目"></a>1. 题目</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找 出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>  </span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>  </span><br><span class="line">所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p>
<h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2. 解法"></a>2. 解法</h2><h3 id="2-1-解法一"><a href="#2-1-解法一" class="headerlink" title="2.1 解法一"></a>2.1 解法一</h3><p>例如：<code>nums = [1, 2, 3, 7, 11, 15], target = 9</code>。  </p>
<ol>
<li><code>2</code>和<code>7</code>是答案，对于<code>7</code>或者<code>2</code>(此例<code>7</code>在后面，所以是对于<code>7</code>)来说，在它前面的元素中必定有另一个答案。  </li>
<li>所以我们将每个元素及其前面的元素都加入<code>map</code>中，遍历到下一个元素时就可以判断另一个答案在不在<code>map</code>中。</li>
</ol>
<blockquote>
<p>执行用时: 12 ms, 在所有 cpp 提交中击败了92.01%的用户<br>内存消耗: 10.5 MB, 在所有 cpp 提交中击败了13.80%的用户</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复杂度为O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> another;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; nums.size(); ++ i) &#123;</span><br><span class="line">            another = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (m.find(another) != m.end()) &#123;</span><br><span class="line">                res.push_back(m[another]);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LeetCode(C++)</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>hash-table</tag>
      </tags>
  </entry>
  <entry>
    <title>记录LaTeX遇到的问题(持续更新...)</title>
    <url>/2019/01/21/other/%E8%AE%B0%E5%BD%95LaTeX%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...)/</url>
    <content><![CDATA[<p>用于记录使用 $\LaTeX$ 过程中遇到的问题，有以下几大方面：</p>
<ol>
<li>脚注</li>
<li>段落缩进</li>
<li>数学公式</li>
<li>图表</li>
<li>页面总体设计</li>
<li>插入代码</li>
<li>正文</li>
<li>列表</li>
<li>表格</li>
<li>参考文献<a id="more"></a>
<blockquote>
<p>@Author：CSU张扬<br>@Email：<a href="mailto:csuzhangyang@gmail.com" target="_blank" rel="noopener">csuzhangyang@gmail.com</a> or <a href="mailto:csuzhangyang@qq.com" target="_blank" rel="noopener">csuzhangyang@qq.com</a></p>
</blockquote>
</li>
</ol>
<h2 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h2><ol>
<li><p>对于在标题(section)中加脚注，要在\footnote前加上\protect。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\section&#123;语音信号的数字水印技术（LSB算法\protect\footnote&#123;即LeastSignificant Bits（最低有效位）算法。&#125;）&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果出现脚注计数不从1开始，可以在代码前加上命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\setcounter&#123;footnote&#125;&#123;0&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除目录中出现的脚注：中括号内放入目录（即标题）显示的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\section[语音信号的数字水印技术（LSB算法）]&#123;语音信号的数字水印技术（LSB算法\protect\footnote&#123;即LeastSignificant Bits（最低有效位）算法&#125;）&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="段落缩进"><a href="#段落缩进" class="headerlink" title="段落缩进"></a>段落缩进</h2><ol>
<li><p>强制缩进，在开头加上以下命令：（em是当前文字的宽度）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\hspace*&#123;2em&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ol>
<li><p>阴影盒子不加gather环境如何居中。前后加上$$即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\shadowbox&#123;$Y(k)=\frac&#123;1&#125;&#123;2&#125;\left(X(k+\omega\pi)+X(k-\omega\pi)\right)$&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行公式显示(加*表示不编号，不加则编号)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;equation*&#125;</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line">f&apos;(n) &amp;= f(n)+\sum_&#123;n=0&#125;^&#123;N－1&#125;g(k)W(k)cos[\frac &#123;(2n + 1)k\pi &#125;&#123;2N&#125;]\\</span><br><span class="line">      &amp;= f(n)+w(n,k)</span><br><span class="line"> \end&#123;split&#125;</span><br><span class="line"> \end&#123;equation*&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><ol>
<li><p>修改图表的图1，图2，变成按章节的图1.1，图2.2等。. 改成 - 可以显示成 图1-1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\renewcommand &#123;\thetable&#125; &#123;\thesection&#123;&#125;.\arabic&#123;table&#125;&#125;</span><br><span class="line">\renewcommand &#123;\thefigure&#125; &#123;\thesection&#123;&#125;.\arabic&#123;figure&#125;&#125;</span><br><span class="line">% 每一章都要手动清零</span><br><span class="line">\setcounter&#123;table&#125;&#123;0&#125;</span><br><span class="line">\setcounter&#123;figure&#125;&#123;0&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="页面总体设计"><a href="#页面总体设计" class="headerlink" title="页面总体设计"></a>页面总体设计</h2><ol>
<li><p>调节页边距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;geometry&#125;</span><br><span class="line">%\geometry&#123;a4paper,left=2.54cm,right=2.54cm,top=3.18cm,bottom=3.18cm&#125;</span><br><span class="line">% 中等</span><br><span class="line">\geometry&#123;a4paper,left=2.54cm,right=2.54cm,top=1.91cm,bottom=1.91cm&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>页眉和页脚（加在导言区）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;fancyhdr&#125;</span><br><span class="line">\usepackage&#123;lastpage&#125;</span><br><span class="line">\pagestyle&#123;fancy&#125;</span><br><span class="line">\fancyhf&#123;&#125;</span><br><span class="line">\fancyhead[C]&#123;\leftmark&#125;</span><br><span class="line">\fancyfoot[C]&#123;Page \thepage\ of \pageref&#123;LastPage&#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><ol>
<li><p>代码字体、大小控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage&#123;fontspec&#125;</span><br><span class="line">\newfontfamily\consolas&#123;Consolas&#125;</span><br><span class="line">\lstset&#123;numbers=left,language=Matlab,basicstyle=\footnotesize\consolas,numberstyle=\footnotesize,tabsize=2, keywordstyle= \color&#123;blue!70&#125;,frame=shadowbox, rulesepcolor= \color&#123;red!20!green!20!blue!20&#125; &#125; 	%插入代码的格式（序号位置，语言，代码字体大小、字体名称，序号字体大小，缩进，关键词颜色，阴影）</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol>
<li><p>局部文字 使用某种字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 导言区</span><br><span class="line">\usepackage&#123;fontspec&#125;</span><br><span class="line">\newfontfamily\consolas&#123;Consolas&#125;</span><br><span class="line">\newfontfamily\monaco&#123;Monaco&#125;</span><br><span class="line"></span><br><span class="line">%正文区</span><br><span class="line">&#123;\consolas def choosesave()&#125;</span><br><span class="line">&#123;\monaco def choosesave()&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制空行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 强制空行1cm</span><br><span class="line">\vspace&#123;1cm&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol>
<li><p>列表带圈数字可以增加到二位数<a href="https://liam0205.me/2014/05/08/latex-circled-numbers/" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;enumitem&#125;</span><br><span class="line">\usepackage&#123;tikz&#125;</span><br><span class="line">\usepackage&#123;etoolbox&#125;</span><br><span class="line">% line width可以调整圈的粗细，inner sep调节圈的大小(可以为负数)。</span><br><span class="line">\newcommand&#123;\circled&#125;[2][]&#123;\tikz[baseline=(char.base),line width = 0.7pt]</span><br><span class="line">    &#123;\node[shape = circle, draw, inner sep = 1pt]</span><br><span class="line">    (char) &#123;\phantom&#123;\ifblank&#123;#1&#125;&#123;#2&#125;&#123;#1&#125;&#125;&#125;;%</span><br><span class="line">    \node at (char.center) &#123;\makebox[0pt][c]&#123;#2&#125;&#125;;&#125;&#125;</span><br><span class="line">\robustify&#123;\circled&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\newcommand&#123;\dcircled&#125;[1]&#123;\circled[00]&#123;#1&#125;&#125;</span><br><span class="line">\begin&#123;enumerate&#125;[label=\dcircled&#123;\arabic*&#125;, noitemsep]</span><br><span class="line">\item I</span><br><span class="line">\item am</span><br><span class="line">\item happy</span><br><span class="line">\item to</span><br><span class="line">\item join</span><br><span class="line">\item with</span><br><span class="line">\item you</span><br><span class="line">\item today</span><br><span class="line">\item in</span><br><span class="line">\item what</span><br><span class="line">\item will</span><br><span class="line">\item go</span><br><span class="line">\item down</span><br><span class="line">\item in</span><br><span class="line">\item history</span><br><span class="line">\item as</span><br><span class="line">\item the</span><br><span class="line">\item greatest</span><br><span class="line">\item demonstration</span><br><span class="line">\item for</span><br><span class="line">\item freedom</span><br><span class="line">\item in</span><br><span class="line">\item the</span><br><span class="line">\item history</span><br><span class="line">\item of</span><br><span class="line">\item our</span><br><span class="line">\item nation.</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表编号加上颜色（创建一个新环境即可）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newenvironment&#123;colorlist&#125;[1]&#123;\begin&#123;list&#125;&#123;\textcolor&#123;blue&#125;&#123;\ding&#123;#1&#125;&#125;&#125;&#123;&#125;&#125;</span><br><span class="line">&#123;\end&#123;list&#125;&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;colorlist&#125;&#123;42&#125;</span><br><span class="line">\item</span><br><span class="line">\item</span><br><span class="line">\end&#123;colorlist&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表变为数字或字母</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;enumerate&#125;</span><br><span class="line">\begin&#123;enumerate&#125;[(i)]</span><br><span class="line">\item Xidian</span><br><span class="line">\item Computer</span><br><span class="line">\item Application</span><br><span class="line">\end&#123;enumerate&#125;</span><br><span class="line">% 可以使用 A，a，I，i，1 作为可选项产生 \Alph，\alph，\Roman，\roman，\arabic 的效果。</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表编号开始值，设置为任意数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">    % 对于数字编号</span><br><span class="line">    \begin&#123;enumerate&#125;</span><br><span class="line">    \addtocounter&#123;enumi&#125;&#123;41&#125;</span><br><span class="line">        \item This item is numbered `42.&apos;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">    % 对于字母编号</span><br><span class="line">    \begin&#123;enumerate&#125;[(a)]</span><br><span class="line">    \addtocounter&#123;enumi&#125;&#123;5&#125;% This cannot be more than 25</span><br><span class="line">        \item This one is ``numbered&apos;&apos; `(f)&apos;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">\end&#123;document&#125;</span><br><span class="line"></span><br><span class="line">% （如果您有更深层次的嵌套列表，相关的计数器是enumii，enumiii和enumiv。）</span><br><span class="line">% 双层嵌套</span><br><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">    % 对于数字编号</span><br><span class="line">    \begin&#123;enumerate&#125;</span><br><span class="line">    \addtocounter&#123;enumi&#125;&#123;41&#125;</span><br><span class="line">        \item This item is numbered `42.&apos;</span><br><span class="line">    % 对于字母编号</span><br><span class="line">    \begin&#123;enumerate&#125;[(a)]</span><br><span class="line">    \addtocounter&#123;enumii&#125;&#123;5&#125;% This cannot be more than 25</span><br><span class="line">        \item This one is ``numbered&apos;&apos; `(f)&apos;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">    \end&#123;enumerate&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>列表之间的行距缩小：导言区加入如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;enumitem&#125;</span><br><span class="line">\setenumerate[1]&#123;itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt&#125;</span><br><span class="line">\setitemize[1]&#123;itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt&#125;</span><br><span class="line">\setdescription&#123;itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol>
<li><p>表格不同的列使用不同的字体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;&gt;&#123;\heiti&#125;r &gt;&#123;\kaishu&#125;l&#125;</span><br><span class="line">黑体 &amp; 楷体</span><br><span class="line">还是黑体 &amp; 还是楷体</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格不同的列使用不同的字号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;&gt;&#123;\small&#125;r &gt;&#123;\Huge&#125;l&#125;</span><br><span class="line">小 &amp; 大</span><br><span class="line">小小 &amp; 大大</span><br><span class="line">\end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格设置文字两端对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;tabular&#125;&#123;&gt;&#123;\heiti&#125;r &gt;&#123;\kaishu&#125;l&#125;</span><br><span class="line">% 两端对齐，用4em是因为有最多四个字，根据实际情况修改该值。</span><br><span class="line">  \makebox[4em][s]&#123;课\hspace&#123;\fill&#125;程&#125;：&amp; 微机原理与接口技术\\</span><br><span class="line">  \makebox[4em][s]&#123;学生姓名&#125;：          &amp; 神奇海螺\\</span><br><span class="line">  \makebox[4em][s]&#123;三\hspace&#123;\fill&#125;个\hspace&#123;\fill&#125;字&#125;：          &amp; 杨老师\\</span><br><span class="line">  \makebox[4em][s]&#123;学\hspace&#123;\fill&#125;院&#125;：&amp; 信息科学与工程学院\\</span><br><span class="line">  \end&#123;tabular&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跨页表格（使用longtable环境）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;longtable&#125;</span><br><span class="line">\newcommand\meta[1]&#123;\emph&#123;$\langle$#1$\rangle$&#125;&#125;</span><br><span class="line">\begin&#123;longtable&#125;&#123;|l|l|&#125;</span><br><span class="line">\hline</span><br><span class="line">\endfirsthead</span><br><span class="line">\multicolumn&#123;2&#125;&#123;l&#125;&#123;（续表）&#125;\\</span><br><span class="line">\hline</span><br><span class="line">\endhead</span><br><span class="line">\multicolumn&#123;2&#125;&#123;c&#125;&#123;\itshape 接下一页表格......&#125;\\[2ex]</span><br><span class="line">\endfoot</span><br><span class="line">\hline</span><br><span class="line">\endlastfoot</span><br><span class="line">% 下面是你的表格内容</span><br><span class="line">% =================================================== %</span><br><span class="line">\hline</span><br><span class="line">D0～D7 &amp; 双向数据总线，以便和 CPU 之间传递命令、数据和状态。\\</span><br><span class="line">\hline</span><br><span class="line">CLK    &amp; 时钟输入线，以产生内部时钟 \\</span><br><span class="line">\hline</span><br><span class="line">% ==================================================== %</span><br><span class="line">\end&#123;longtable&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://blog.sina.com.cn/s/blog_6cb9ecd10100lpln.html" target="_blank" rel="noopener">表格内的内容添加脚注</a></p>
<p>在tabular环境中添加脚注，不能简单地使用\footnote{……}。应该在要添加脚注的地方使用\footnotemark[n]标记，其中n表示脚注的编号；在<strong>tabular或table环境外</strong>则用\footnotetext[n]{……}填入脚注内容，注意这里的[n]应该与表格中的\footnotemark中的[n]一一对应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;[htbp]</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;tabular&#125;&#123;ll&#125;</span><br><span class="line">  \toprule</span><br><span class="line">  % after \\: \hline or \cline&#123;col1-col2&#125; \cline&#123;col3-col4&#125; ...</span><br><span class="line">  $D_4 D_3$ &amp; 功能 \\</span><br><span class="line">  \midrule</span><br><span class="line">  00 &amp; 8字符显示，左端输入\footnotemark[1] \\</span><br><span class="line">  01 &amp; 16字符显示，左端输入 \\</span><br><span class="line">  10 &amp; 8字符显示，左端输入 \\</span><br><span class="line">  11 &amp; 16字符显示，右端输入 \\</span><br><span class="line">  \bottomrule</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;table&#125;</span><br><span class="line">\footnotetext[1]&#123;RESET后，设定该种方式&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格中添加列表环境(1)</p>
<p>缺点：表格中每一个格子内，必须有列表的序号（·或者123…）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass&#123;article&#125;</span><br><span class="line">\usepackage&#123;array&#125;</span><br><span class="line">\makeatletter</span><br><span class="line">\newcolumntype&#123;e&#125;[1]&#123;%--- Enumerated cells ---</span><br><span class="line">   &gt;&#123;\minipage[t]&#123;\linewidth&#125;%</span><br><span class="line">     \NoHyper%                Hyperref adds a vertical space</span><br><span class="line">     \let\\\tabularnewline</span><br><span class="line">     \enumerate</span><br><span class="line">        \addtolength&#123;\rightskip&#125;&#123;0pt plus 50pt&#125;% for raggedright</span><br><span class="line">        \setlength&#123;\itemsep&#125;&#123;-\parsep&#125;&#125;%</span><br><span class="line">   p&#123;#1&#125;%</span><br><span class="line">   &lt;&#123;\@finalstrut\@arstrutbox\endenumerate</span><br><span class="line">     \endNoHyper</span><br><span class="line">     \endminipage&#125;&#125;</span><br><span class="line"></span><br><span class="line">\newcolumntype&#123;i&#125;[1]&#123;%--- Itemized cells ---</span><br><span class="line">   &gt;&#123;\minipage[t]&#123;\linewidth&#125;%</span><br><span class="line">        \let\\\tabularnewline</span><br><span class="line">        \itemize</span><br><span class="line">           \addtolength&#123;\rightskip&#125;&#123;0pt plus 50pt&#125;%</span><br><span class="line">           \setlength&#123;\itemsep&#125;&#123;-\parsep&#125;&#125;%</span><br><span class="line">   p&#123;#1&#125;%</span><br><span class="line">   &lt;&#123;\@finalstrut\@arstrutbox\enditemize\endminipage&#125;&#125;</span><br><span class="line"></span><br><span class="line">\AtBeginDocument&#123;%</span><br><span class="line">    \@ifpackageloaded&#123;hyperref&#125;&#123;&#125;%</span><br><span class="line">        &#123;\let\NoHyper\relax\let\endNoHyper\relax&#125;&#125;</span><br><span class="line">\makeatother</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;tabular&#125;[t]&#123;|i&#123;2.5cm&#125;|e&#123;3cm&#125;|&#125;</span><br><span class="line">\hline</span><br><span class="line">  \item Item A</span><br><span class="line">  \item Item B   &amp;</span><br><span class="line">  \item Item 1</span><br><span class="line">  \item Item 2   \\</span><br><span class="line">\hline  </span><br><span class="line">  \item Item C   &amp;</span><br><span class="line">  \item Item 3</span><br><span class="line">  \item Item 4   \\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表格中添加列表环境(2)</p>
<p>特点：克服了(1)的缺点，但是每一个列表之间距离很大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">  \centering</span><br><span class="line">  \begin&#123;tabular&#125;&#123;|p&#123;2cm&#125;|p&#123;6cm&#125;|p&#123;6cm&#125;|&#125;</span><br><span class="line"> \hline</span><br><span class="line"> 结构 &amp; 背景 &amp; 重点/贡献\\</span><br><span class="line"> \hline</span><br><span class="line"> 三层结构 &amp;</span><br><span class="line"> \begin&#123;itemize&#125;</span><br><span class="line">   \item 雾计算基本结构</span><br><span class="line"> \end&#123;itemize&#125;</span><br><span class="line">    &amp;</span><br><span class="line">   \begin&#123;itemize&#125;</span><br><span class="line">   \item 将计算和存储设施扩展到网络边缘并减轻云数据中心的负担。</span><br><span class="line">  \end&#123;itemize&#125; \\</span><br><span class="line"> \hline</span><br><span class="line"> 基于SDN的雾计算 &amp;</span><br><span class="line"> \begin&#123;itemize&#125;</span><br><span class="line">   \item 数据和控制平面的分离。</span><br><span class="line">   \item 在边缘元素中集成控制器功能，即边缘切换。</span><br><span class="line">   \item 与雾和云管理软件进行通信。</span><br><span class="line">   \end&#123;itemize&#125; &amp;	</span><br><span class="line"> \begin&#123;itemize&#125;</span><br><span class="line">   \item 改进控制器开关延迟性能。</span><br><span class="line">   \item 有效地管理边缘切换的搜索，编译和网络资源。</span><br><span class="line">   \item 处理与雾相关的流量，旨在减少延迟和碳足迹。</span><br><span class="line"> \end&#123;itemize&#125; \\</span><br><span class="line">\hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">  \caption&#123;三层结构和 SDN 结构的区别&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><p>添加参考文献到目录中，加入第二行的代码，<strong>编译两次</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">\addcontentsline&#123;toc&#125;&#123;section&#125;&#123;参考文献&#125; % 加入这一行，编译两次</span><br><span class="line">\bibitem&#123;1&#125; 梁建武,杨迎泽. 微机原理与接口技术. 北京: 中国铁道出版社. 2016, 02.</span><br><span class="line">\bibitem&#123;2&#125; 王爽. 汇编语言(第三版). 北京:清华大学出版社. 2014, 04.</span><br><span class="line">\bibitem&#123;3&#125; Star ES8086使用说明.</span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>int main (int argc, char *argv[])中argc和argv的使用。</title>
    <url>/2018/12/22/CPP/summary/main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*test.c*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/* argc是命令行输入的参数的个数，argv数组存储每个参数的内容。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数应该为两个\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第一个参数：%s\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第二个参数：%s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先编译该文件，<code>gcc -o test test.c</code>，得到 <code>test</code> 文件。</p>
<p>（如果执行 <code>gcc test.c</code> ，得到的是 <code>a.out</code> ）</p>
<ol>
<li>如果我们在终端输入：<code>./test</code>。错误，输出为：<strong>参数应该为两个</strong></li>
<li>如果我们在终端输入：<code>./test Pineapple</code>。<br>正确，输出为：<br> <strong>第一个参数：./test</strong><br> <strong>第二个参数：Pineapple</strong></li>
<li>如果我们需要输入的第二参数是 <code>Pineapple Castle</code>，在终端输入：<code>./test Pineapple Castle</code>。错误，输出为：<strong>参数应该为两个</strong><br>因为程序会以空格键区分各个参数。</li>
<li>解决空格的问题，加上引号即可。在终端执行：<code>./test &quot;Pineapple Castle&quot;</code>。正确，输出为：<br> <strong>第一个参数：./test</strong><br> <strong>第二个参数：Pineapple Castle</strong></li>
</ol>
<p><img src="/2018/12/22/CPP/summary/main%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/argv1.png" alt="argv1"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《UNIX网络编程》第一步：编写自己的daytime客户端，并从daytime服务器获取时间</title>
    <url>/2018/11/12/other/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="1-首先下载《UNIX网络编程》配套源代码"><a href="#1-首先下载《UNIX网络编程》配套源代码" class="headerlink" title="1. 首先下载《UNIX网络编程》配套源代码"></a>1. 首先下载《UNIX网络编程》配套源代码</h2><p><a href="http://www.unpbook.com/" target="_blank" rel="noopener">源代码地址</a></p>
<hr>
<a id="more"></a>
<h2 id="2-复制到虚拟机内-以Ubuntu系统为例-并解压。"><a href="#2-复制到虚拟机内-以Ubuntu系统为例-并解压。" class="headerlink" title="2. 复制到虚拟机内(以Ubuntu系统为例),并解压。"></a>2. 复制到虚拟机内(以Ubuntu系统为例),并解压。</h2><p>解压命令：<strong><code>tar zxvf unpv13e.tar.gz</code></strong></p>
<hr>
<p><strong>以下加粗部分的代码块，均为要在终端执行的命令。</strong></p>
<h2 id="3-在终端进入unpv13e目录。"><a href="#3-在终端进入unpv13e目录。" class="headerlink" title="3. 在终端进入unpv13e目录。"></a>3. 在终端进入unpv13e目录。</h2><ul>
<li><p>终端执行 <strong><code>./configure</code></strong></p>
<p>如果出错，先执行命令 <strong><code>chmod +x configure</code></strong>  ，再执行   <strong><code>./configure</code></strong></p>
</li>
<li><p>进入lib目录  <strong><code>cd lib</code></strong>  ，并执行命令  <strong><code>make</code></strong></p>
</li>
<li><p>返回上一级目录 <strong><code>cd ..</code></strong> ，并进入libfree目录 <strong><code>cd libfree</code></strong> ，再执行 <strong><code>make</code></strong>（这一步可能会有error，没关系，只要在unpv13e文件夹中生成了libunp.a文件就可以）<br><strong><em>最终会在unpv13e文件夹中生成libunp.a文件</em></strong></p>
</li>
</ul>
<hr>
<h2 id="4-将libunp-a文件复制到-usr-lib"><a href="#4-将libunp-a文件复制到-usr-lib" class="headerlink" title="4. 将libunp.a文件复制到/usr/lib/"></a>4. 将libunp.a文件复制到/usr/lib/</h2><ul>
<li>返回到unpv13e目录， <strong><code>cd ..</code></strong></li>
<li>执行复制命令，<strong><code>sudo cp libunp.a /usr/lib</code></strong></li>
</ul>
<hr>
<h2 id="5-修改unpv13e-lib-unp-h，并将它和unpv13e-config-h拷贝到-usr-include中"><a href="#5-修改unpv13e-lib-unp-h，并将它和unpv13e-config-h拷贝到-usr-include中" class="headerlink" title="5. 修改unpv13e/lib/unp.h，并将它和unpv13e/config.h拷贝到/usr/include中"></a>5. 修改unpv13e/lib/unp.h，并将它和unpv13e/config.h拷贝到/usr/include中</h2><ul>
<li>用vim编辑unp.h, <strong><code>vim lib/unp.h</code></strong>, 将<em>#include “../config.h”*修改为</em>#include “config.h”*</li>
<li>拷贝unp.h,  <strong><code>sudo cp lib/unp.h /usr/include</code></strong></li>
<li>拷贝configure.h,  <strong><code>sudo cp config.h /usr/include</code></strong></li>
</ul>
<hr>
<h2 id="6-安装xinetd服务"><a href="#6-安装xinetd服务" class="headerlink" title="6.安装xinetd服务"></a>6.安装xinetd服务</h2><ul>
<li>Ubuntu系统中：执行命令， <strong><code>apt install xinetd</code></strong></li>
<li>Centos系统中：执行命令， <strong><code>yum  -y  install  xinetd*</code></strong></li>
</ul>
<hr>
<h2 id="7-执行daytime客户端"><a href="#7-执行daytime客户端" class="headerlink" title="7. 执行daytime客户端"></a>7. 执行daytime客户端</h2><ul>
<li><p>找到文件daytimetcpcli.c，在unpv13e/intro目录中，利用cd命令进入该目录。</p>
</li>
<li><p>编译该文件， <strong><code>gcc daytimetcpcli.c -lunp</code></strong></p>
</li>
<li><p>会生成a.out文件，再执行 <strong><code>./a.out 127.0.0.1</code></strong>，获取本机时间。</p>
</li>
</ul>
<p><strong>如果出现错误：</strong> connect error:Connection refused,表示daytime服务器程序没设置好。</p>
<p><strong>Ubuntu系统的解决办法：</strong></p>
<ul>
<li><p>找到/etc/xinetd.d目录，<strong><code>cd /etc/xinetd.d</code></strong></p>
</li>
<li><p>用vim编辑daytime文件，<strong><code>sudo vim daytime</code></strong>（要用超级用户权限才可以修改，因此要加上sudo）</p>
</li>
<li><p>daytime文件中的两个<em>disable = yes</em> 改为 <em>disable = no</em>，保存退出vim。</p>
</li>
<li><p>重启xinetd服务，执行命令，<strong><code>service xinetd restart</code></strong></p>
</li>
<li><p>此时再次执行步骤7。</p>
</li>
</ul>
<p><strong>Centos系统的解决办法：</strong></p>
<ul>
<li><p>找到/etc/xinetd.d目录，<strong><code>cd /etc/xinetd.d</code></strong></p>
</li>
<li><p>将daytime-stream和daytime-dgram两个文件中的<em>disable = yes</em> 均改为 <em>disable = no</em>。用vim编辑这两个文件，<strong><code>sudo vim daytime-stream</code></strong>和<strong><code>sudo vim daytime-dgram</code></strong>（要用超级用户权限才可以修改，因此要加上sudo）。</p>
</li>
<li><p>回到主目录，<strong><code>cd ~</code></strong>。重启xinetd服务，执行命令，<strong><code>/etc/init.d/xinetd restart</code></strong></p>
</li>
<li><p>此时再次执行步骤7。</p>
</li>
</ul>
<hr>
<h2 id="8-注"><a href="#8-注" class="headerlink" title="8. 注"></a>8. 注</h2><ul>
<li>daytime服务器有许多种，127.0.0.1只是本机地址时间，可以更换别的服务器。</li>
<li>目前手头只有Ubuntu 18系统和Centos6.8系统，因此只有这两个系统的教程。</li>
</ul>
<hr>
<h2 id="9-结果"><a href="#9-结果" class="headerlink" title="9. 结果"></a>9. 结果</h2><ol>
<li><p>Ubuntu下</p>
<p> <img src="/2018/11/12/other/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/ubuntu.jpg" alt="1"></p>
</li>
<li><p>Centos下</p>
<p> <img src="/2018/11/12/other/%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84daytime%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E4%BB%8Edaytime%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4/centos.png" alt="2"></p>
</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>UNIX</category>
        <category>UNIX网络编程</category>
      </categories>
      <tags>
        <tag>UNIX网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>利用graphviz软件和pycallgraph库自动生成Python代码函数调用关系图</title>
    <url>/2018/10/11/other/%E5%88%A9%E7%94%A8graphviz%E8%BD%AF%E4%BB%B6%E5%92%8Cpycallgraph%E5%BA%93%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Python%E4%BB%A3%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://pycallgraph.readthedocs.io/en/master/guide/index.html" target="_blank" rel="noopener">参考 https://pycallgraph.readthedocs.io/en/master/guide/index.html</a></p>
</blockquote>
<h2 id="1-下载并安装graphviz"><a href="#1-下载并安装graphviz" class="headerlink" title="1.下载并安装graphviz"></a>1.下载并安装graphviz</h2><ol>
<li><a href="https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi" target="_blank" rel="noopener">下载地址: https://graphviz.gitlab.io/_pages/Download/windows/graphviz-2.38.msi</a></li>
<li>安装（路径可任意选择）</li>
<li>配置环境变量，在Path中添加：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">例如我安装在F:\Program Files (x86)，那么就添加环境变量F:\Program Files (x86)\Graphviz2.38\bin</span><br></pre></td></tr></table></figure>

<h2 id="2-安装pycallgraph库"><a href="#2-安装pycallgraph库" class="headerlink" title="2.安装pycallgraph库"></a>2.安装pycallgraph库</h2><ul>
<li>cmd窗口命令行输入：<code>pip install pycallgraph</code></li>
</ul>
<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><p><strong>注意：你的程序, 只有你运行中使用了某个函数，才能显示在流图中。用户没有使用的功能则不会出现在流图中。</strong></p>
<p>在代码开头调用该库，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> PyCallGraph</span><br><span class="line"><span class="keyword">from</span> pycallgraph.output <span class="keyword">import</span> GraphvizOutput</span><br><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> pycallgraph <span class="keyword">import</span> GlobbingFilter</span><br></pre></td></tr></table></figure>

<p>主函数操作：</p>
<p>（最终会保存在你的.py文件相同的文件夹里，名字为graph.png）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 你的主函数代码。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    config = Config()</span><br><span class="line">    <span class="comment"># 关系图中包括(include)哪些函数名。</span></span><br><span class="line">    <span class="comment">#如果是某一类的函数，例如类gobang，则可以直接写'gobang.*'，表示以gobang.开头的所有函数。（利用正则表达式）。</span></span><br><span class="line">    config.trace_filter = GlobbingFilter(include=[</span><br><span class="line">        <span class="string">'main'</span>,</span><br><span class="line">        <span class="string">'draw_chessboard'</span>,</span><br><span class="line">        <span class="string">'draw_chessman'</span>,</span><br><span class="line">        <span class="string">'draw_chessboard_with_chessman'</span>,</span><br><span class="line">        <span class="string">'choose_save'</span>,</span><br><span class="line">        <span class="string">'choose_turn'</span>,</span><br><span class="line">        <span class="string">'choose_mode'</span>,</span><br><span class="line">        <span class="string">'choose_button'</span>,</span><br><span class="line">        <span class="string">'save_chess'</span>,</span><br><span class="line">        <span class="string">'load_chess'</span>,</span><br><span class="line">        <span class="string">'play_chess'</span>,</span><br><span class="line">        <span class="string">'pop_window'</span>,</span><br><span class="line">        <span class="string">'tip'</span>,</span><br><span class="line">        <span class="string">'get_score'</span>,</span><br><span class="line">        <span class="string">'max_score'</span>,</span><br><span class="line">        <span class="string">'win'</span>,</span><br><span class="line">        <span class="string">'key_control'</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="comment"># 该段作用是关系图中不包括(exclude)哪些函数。(正则表达式规则)</span></span><br><span class="line">    <span class="comment"># config.trace_filter = GlobbingFilter(exclude=[</span></span><br><span class="line">    <span class="comment">#     'pycallgraph.*',</span></span><br><span class="line">    <span class="comment">#     '*.secret_function',</span></span><br><span class="line">    <span class="comment">#     'FileFinder.*',</span></span><br><span class="line">    <span class="comment">#     'ModuleLockManager.*',</span></span><br><span class="line">    <span class="comment">#     'SourceFilLoader.*'</span></span><br><span class="line">    <span class="comment"># ])</span></span><br><span class="line">    graphviz = GraphvizOutput()</span><br><span class="line">    graphviz.output_file = <span class="string">'graph.png'</span></span><br><span class="line">    <span class="keyword">with</span> PyCallGraph(output=graphviz, config=config):</span><br><span class="line">        main()</span><br></pre></td></tr></table></figure>

<p>产生的图片效果如下所示：</p>
<p><img src="/2018/10/11/other/%E5%88%A9%E7%94%A8graphviz%E8%BD%AF%E4%BB%B6%E5%92%8Cpycallgraph%E5%BA%93%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90Python%E4%BB%A3%E7%A0%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE/pycallgraph.png" alt="basic"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>graphviz</tag>
        <tag>pycallgraph</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保存MATLAB GUI界面中的图片</title>
    <url>/2018/09/16/other/%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98MATLAB%20GUI%E7%95%8C%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>代码来源自网络，作者未知，侵删。<br>原生支持png，bmp，jpg格式。另外自行添加了清晰度比较高的eps格式（荐）。</p>
</blockquote>
<a id="more"></a>

<p>新建一个按钮，按钮的代码如下。</p>
<p>其中第二行的 <code>new_axes=copyobj(handles.axes1,new_f_handle)</code> 的 <code>handles.axes1</code> 意思是保存的是axes1中的图，以此类推。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushbutton19_Callback</span><span class="params">(hObject, eventdata, handles)</span></span></span><br><span class="line"><span class="comment">% hObject    handle to pushbutton19 (see GCBO)</span></span><br><span class="line"><span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span></span><br><span class="line"><span class="comment">% handles    structure with handles and user data (see GUIDATA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 以下内容拷贝到按钮函数下。</span></span><br><span class="line">    new_f_handle=<span class="built_in">figure</span>(<span class="string">'visible'</span>,<span class="string">'off'</span>); <span class="comment">%新建一个不可见的figure</span></span><br><span class="line">    new_axes=copyobj(handles.axes1,new_f_handle); <span class="comment">%axes1是GUI界面内要保存图线的Tag，将其copy到不可见的figure中</span></span><br><span class="line">    set(new_axes,<span class="string">'Units'</span>,<span class="string">'normalized'</span>,<span class="string">'Position'</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.8</span> <span class="number">0.8</span>]);<span class="comment">%将图线缩放</span></span><br><span class="line">    [filename pathname fileindex]=uiputfile(&#123;<span class="string">'*.png'</span>;<span class="string">'*.bmp'</span>;<span class="string">'*.jpg'</span>;<span class="string">'*.eps'</span>;&#125;,<span class="string">'图片保存为'</span>);</span><br><span class="line">    <span class="keyword">if</span>  filename~=<span class="number">0</span><span class="comment">%未点“取消”按钮或未关闭</span></span><br><span class="line">        file=strcat(pathname,filename);</span><br><span class="line">        <span class="keyword">switch</span> fileindex <span class="comment">%根据不同的选择保存为不同的类型</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-dpng'</span>,file);<span class="comment">% print(new_f_handle,'-dpng',filename);效果一样，将图像打印到指定文件中</span></span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-dbmp'</span>,file);</span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-djpg'</span>,file);</span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span></span><br><span class="line">                print(new_f_handle,<span class="string">'-depsc'</span>,file);</span><br><span class="line">                fprintf(<span class="string">'&gt;&gt;已保存到：%s\n'</span>,file);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        msgbox(<span class="string">'          图线已成功保存！'</span>,<span class="string">'完成！'</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
</search>
